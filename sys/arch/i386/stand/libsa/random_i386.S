/*	$OpenBSD: random_i386.S,v 1.11 2020/05/25 14:58:02 deraadt Exp $	*/

/*
 * Copyright (c) 2013 Joel Sing <jsing@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/specialreg.h>

/*
 * Random data is xored into the buffer in 4 byte blocks. If the buffer size
 * is not a multiple of 4, the remaining bytes may be left untouched.
 */
ENTRY(mdrandom)
	pushal

	// See if we have CPU identification.
	pushfl
	popl	%eax
	movl	%eax, %ecx
	orl	$PSL_ID, %eax
	pushl	%eax
	popfl
	pushfl
	popl	%eax
	pushl	%ecx
	popfl
	andl	$PSL_ID, %eax
	movl	$-1, %eax
	jz	done

	// CPUID leaf = 1, subleaf = 0
	movl	$1, %eax
	movl	$0, %ecx
	cpuid
	movl	%edx, %eax

	movl	36(%esp), %ebx
	movl	40(%esp), %edx
	xorl	%edi, %edi

	andl	$CPUIDECX_RDRAND, %ecx	// See if we have rdrand.
	jnz	userand

	movl	%edx, %ecx
	andl	$CPUID_TSC, %eax	// See if we have rdtsc.
	jnz	usetsc

	movl	$-1, %eax
	jmp	done

userand:
	shrl	$2, %edx		// 4 bytes at a time
1:
	rdrand	%eax
	xorl	%eax, (%ebx,%edi,4)
	incl	%edi
	cmpl	%edi, %edx
	jne	1b
	movl	$0, %eax
	jmp	done

usetsc:
	rdtsc				// Populates edx:eax.

	/*
	 *   Cope with high=0
	 * high = (high << 1) | 1;
	 *   Spread bits
	 * bits = low * high;
	 *   Accumulate spread bits into a byte
	 * bits = bits ^ (bits>>8) ^ (bits>>16) ^ (bits>>24);
	 * buf[i] ^= (u_char) bits;
	 */
	shll	$1, %edx
	orl	$1, %edx
	mull	%edx
	movl	%eax, %edx
	shrl	$8, %edx
	xorl	%edx, %eax
	shrl	$8, %edx
	xorl	%edx, %eax
	shrl	$8, %edx
	xorl	%edx, %eax

	xorb	%al, (%ebx,%edi)

	incl	%edi
	cmpl	%edi, %ecx
	jne	usetsc
	movl	$0, %eax
	jmp	done

done:
	popal
	ret
