	$NetBSD: syscalls.master,v 1.9 1995/11/28 08:39:56 thorpej Exp $

;	@(#)syscalls.master	8.1 (Berkeley) 7/19/93

; NetBSD COMPAT_HPUX system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/exec.h>
#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_syscallargs.h>

0	NOARGS		{ int sys_nosys(void); } syscall
1	NOARGS		{ int sys_exit(int rval); }
2	STD		{ int hpux_sys_fork(void); }
3	STD		{ int hpux_sys_read(int fd, char *buf, u_int nbyte); }
4	STD		{ int hpux_sys_write(int fd, char *buf, u_int nbyte); }
5	STD		{ int hpux_sys_open(char *path, int flags, int mode); }
6	NOARGS		{ int sys_close(int fd); }
7	STD		{ int hpux_sys_wait(int *status); }
8	STD		{ int hpux_sys_creat(char *path, int mode); }
9	NOARGS	 	{ int sys_link(char *path, char *link); }
10	STD		{ int hpux_sys_unlink(char *path); }
11	STD		{ int hpux_sys_execv(char * path, char * * argp); }
12	STD		{ int hpux_sys_chdir(char *path); }
13	STD		{ int hpux_sys_time_6x(time_t *t); }
14	STD		{ int hpux_sys_mknod(char *path, int mode, int dev); }
15	STD		{ int hpux_sys_chmod(char *path, int mode); }
16	STD		{ int hpux_sys_chown(char *path, int uid, int gid); }
17	NOARGS		{ int sys_obreak(char *nsize); }
18	STD		{ int hpux_sys_stat_6x(char *path, \
			    struct hpux_ostat *sb); }
19	NOARGS		{ long compat_43_sys_lseek(int fd, long offset, \
			    int whence); }
20	NOARGS		{ pid_t sys_getpid(void); }
21	UNIMPL		mount
22	UNIMPL		umount
23	NOARGS		{ int sys_setuid(uid_t uid); }
24	NOARGS		{ uid_t sys_getuid(void); }
25	STD		{ int hpux_sys_stime_6x(int time); }
26	STD		{ int hpux_sys_ptrace(int req, int pid, int *addr, \
			    int data); }
27	STD		{ int hpux_sys_alarm_6x(int deltat); }
28	STD		{ int hpux_sys_fstat_6x(int fd, \
			    struct hpux_ostat *sb); }
29	STD		{ int hpux_sys_pause_6x(void); }
30	STD		{ int hpux_sys_utime_6x(char *fname, time_t *tptr); }
31	STD		{ int hpux_sys_stty_6x(int fd, caddr_t arg); }
32	STD		{ int hpux_sys_gtty_6x(int fd, caddr_t arg); }
33	STD		{ int hpux_sys_access(char *path, int flags); }
34	STD		{ int hpux_sys_nice_6x(int nval); }
35	STD		{ int hpux_sys_ftime_6x(struct hpux_timeb *tp); }
36	NOARGS		{ int sys_sync(void); }
37	STD		{ int hpux_sys_kill(pid_t pid, int signo); }
38	STD		{ int hpux_sys_stat(char *path, struct hpux_stat *sb); }
39	STD		{ int hpux_sys_setpgrp_6x(void); }
40	STD		{ int hpux_sys_lstat(char *path, struct hpux_stat *sb); }
41	STD		{ int hpux_sys_dup(int fd); }
42	NOARGS		{ int sys_pipe(void); }
43	STD		{ int hpux_sys_times_6x(struct tms *tms); }
44	NOARGS		{ int sys_profil(caddr_t samples, u_int size, \
			    u_int offset, u_int scale); }

45	UNIMPL		ki_syscall
46	NOARGS		{ int sys_setgid(gid_t gid); }
47	NOARGS		{ gid_t sys_getgid(void); }
48	STD		{ int hpux_sys_ssig_6x(int signo, sig_t fun); }
49	UNIMPL		reserved for USG
50	UNIMPL		reserved for USG
51	UNIMPL		acct
52	UNIMPL
53	UNIMPL
54	STD		{ int hpux_sys_ioctl(int fd, int com, caddr_t data); }
55	UNIMPL		reboot
56	STD		{ int hpux_sys_symlink(char *path, char *link); }
57	STD		{ int hpux_sys_utssys(struct hpux_utsname *uts, \
					  int dev, int request); }
58	STD		{ int hpux_sys_readlink(char *path, char *buf, \
					  int count); }
59	NOARGS		{ int sys_execve(char *path, char **argp, \
			    char **envp); }
60	NOARGS		{ int sys_umask(int newmask); }
61	NOARGS		{ int sys_chroot(char *path); }
62	STD		{ int hpux_sys_fcntl(int fd, int cmd, int arg); }
63	STD		{ int hpux_sys_ulimit(int cmd, int newlimit); }
64	UNIMPL
65	UNIMPL
66	STD		{ int hpux_sys_vfork(void); }
67	NOARGS		{ int hpux_sys_read(int fd, char *buf, u_int nbyte); } vread
68	NOARGS		{ int hpux_sys_write(int fd, char *buf, u_int nbyte); } vwrite
69	UNIMPL
70	UNIMPL
71	STD		{ int hpux_sys_mmap(caddr_t addr, size_t len, \
			    int prot, int flags, int fd, long pos); }
72	UNIMPL
73	NOARGS		{ int sys_munmap(caddr_t addr, size_t len); }
74	NOARGS		{ int sys_mprotect(caddr_t addr, size_t len, \
			    int prot); }
75	UNIMPL
76	UNIMPL
77	UNIMPL
78	UNIMPL
79	NOARGS		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
80	NOARGS		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
81	STD		{ int hpux_sys_getpgrp2(pid_t pid); }
82	STD		{ int hpux_sys_setpgrp2(pid_t pid, pid_t pgid); }
83	NOARGS		{ int sys_setitimer(u_int which, \
			    struct itimerval *itv, struct itimerval *oitv); }
84	STD		{ int hpux_sys_wait3(int *status, int options, \
			    int rusage); }
85	UNIMPL		swapon
86	NOARGS		{ int sys_getitimer(u_int which, \
			    struct itimerval *itv); }
87	UNIMPL
88	UNIMPL
89	UNIMPL
90	NOARGS		{ int sys_dup2(u_int from, u_int to); }
91	UNIMPL
92	STD		{ int hpux_sys_fstat(int fd, struct hpux_stat *sb); }
93	NOARGS		{ int sys_select(u_int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval *tv); }
94	UNIMPL
95	NOARGS		{ int sys_fsync(int fd); }
96	UNIMPL
97	UNIMPL
98	UNIMPL
99	UNIMPL
100	UNIMPL
101	UNIMPL
102	UNIMPL
103	NOARGS		{ int sys_sigreturn(struct sigcontext *sigcntxp); }
104	UNIMPL
105	UNIMPL
106	UNIMPL
107	UNIMPL
108	STD		{ int hpux_sys_sigvec(int signo, struct sigvec *nsv, \
			    struct sigvec *osv); }
109	STD		{ int hpux_sys_sigblock(int mask); }
110	STD		{ int hpux_sys_sigsetmask(int mask); }
111	STD		{ int hpux_sys_sigpause(int mask); }
112	NOARGS		{ int compat_43_sys_sigstack(struct sigstack *nss, \
			    struct sigstack *oss); }
113	UNIMPL
114	UNIMPL
115	UNIMPL
116	NOARGS		{ int sys_gettimeofday(struct timeval *tp); }
117	UNIMPL
118	UNIMPL
119	UNIMPL		io_stub
120	STD		{ int hpux_sys_readv(int fd, struct iovec *iovp, \
			    u_int iovcnt); }
121	STD		{ int hpux_sys_writev(int fd, struct iovec *iovp, \
			    u_int iovcnt); }
122	NOARGS		{ int sys_settimeofday(struct timeval *tv, \
			    struct timezone *tzp); }
123	NOARGS		{ int sys_fchown(int fd, int uid, int gid); }
124	NOARGS		{ int sys_fchmod(int fd, int mode); }
125	UNIMPL
126	STD		{ int hpux_sys_setresuid(uid_t r, uid_t e, uid_t s); }
127	STD		{ int hpux_sys_setresgid(gid_t r, gid_t e, gid_t s); }
128	STD		{ int hpux_sys_rename(char *from, char *to); }
129	STD		{ int hpux_sys_truncate(char *path, long length); }
130	NOARGS		{ int compat_43_sys_ftruncate(int fd, long length); }
131	UNIMPL
132	STD		{ int hpux_sys_sysconf(int name); }
133	UNIMPL
134	UNIMPL
135	UNIMPL
136	STD		{ int hpux_sys_mkdir(char *path, int mode); }
137	STD		{ int hpux_sys_rmdir(char *path); }
138	UNIMPL
139	UNIMPL
140	UNIMPL
141	UNIMPL
142	UNIMPL
143	UNIMPL
144	STD		{ int hpux_sys_getrlimit(u_int which, \
			    struct ogetrlimit *rlp); }
145	STD		{ int hpux_sys_setrlimit(u_int which, \
			    struct ogetrlimit *rlp); }
146	UNIMPL
147	UNIMPL
148	UNIMPL
149	UNIMPL
150	UNIMPL
151	UNIMPL		privgrp
152	STD		{ int hpux_sys_rtprio(pid_t pid, int prio); }
153	UNIMPL		plock
154	STD		{ int hpux_sys_netioctl(int call, int *args); }
155	STD		{ int hpux_sys_lockf(int fd, int func, long size); }
#ifdef SYSVSEM
156	NOARGS		{ int sys_semget(key_t key, int nsems, int semflg); }
157	NOARGS		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
158	NOARGS		{ int sys_semop(int semid, struct sembuf *sops, \
			    u_int nsops); }
#else
156	UNIMPL		semget
157	UNIMPL		semctl
158	UNIMPL		semop
#endif
#ifdef SYSVMSG
159	NOARGS		{ int sys_msgget(key_t key, int msgflg); }
160	NOARGS		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
161	NOARGS		{ int sys_msgsnd(int msqid, void *msgp, size_t msgsz, \
			    int msgflg); }
162	NOARGS		{ int sys_msgrcv(int msqid, void *msgp, size_t msgsz, \
			    long msgtyp, int msgflg); }
#else
159	UNIMPL		msgget
160	UNIMPL		msgctl
161	UNIMPL		msgsnd
162	UNIMPL		msgrcv
#endif
#ifdef SYSVSHM
163	NOARGS		{ int sys_shmget(key_t key, int size, int shmflg); }
164	STD		{ int hpux_sys_shmctl(int shmid, int cmd, \
			    caddr_t buf); }
165	NOARGS		{ int sys_shmat(int shmid, void *shmaddr, int shmflg); }
166	NOARGS		{ int sys_shmdt(void *shmaddr); }
#else
163	UNIMPL		shmget
164	UNIMPL		shmctl
165	UNIMPL		shmat
166	UNIMPL		shmdt
#endif
167	STD		{ int hpux_sys_advise(int arg); }
168	UNIMPL		nsp_init
169	UNIMPL		cluster
170	UNIMPL		mkrnod
171	UNIMPL
172	UNIMPL		unsp_open
173	UNIMPL
174	STD		{ int hpux_sys_getcontext(char *buf, int len); }
175	UNIMPL
176	UNIMPL
177	UNIMPL
178	UNIMPL		lsync
179	UNIMPL
180	UNIMPL		mysite
181	UNIMPL		sitels
182	UNIMPL
183	UNIMPL
184	UNIMPL		dskless_stats
185	UNIMPL
186	UNIMPL		setacl
187	UNIMPL		fsetacl
188	UNIMPL		getacl
189	UNIMPL		fgetacl
190	STD		{ int hpux_sys_getaccess(char *path, uid_t uid, \
			    int ngroups, gid_t *gidset, void *label, \
			    void *privs); }
191	UNIMPL		getaudid
192	UNIMPL		setaudid
193	UNIMPL		getaudproc
194	UNIMPL		setaudproc
195	UNIMPL		getevent
196	UNIMPL		setevent
197	UNIMPL		audwrite
198	UNIMPL		audswitch
199	UNIMPL		audctl
200	STD		{ int hpux_sys_waitpid(pid_t pid, int *status, \
			    int options, struct rusage *rusage); }
201	UNIMPL
202	UNIMPL
203	UNIMPL
204	UNIMPL
205	UNIMPL
206	UNIMPL
207	UNIMPL
208	UNIMPL
209	UNIMPL
210	UNIMPL
211	UNIMPL
212	UNIMPL
213	UNIMPL
214	UNIMPL
215	UNIMPL
216	UNIMPL
217	UNIMPL
218	UNIMPL
219	UNIMPL
220	UNIMPL
221	UNIMPL
222	UNIMPL
223	UNIMPL
224	UNIMPL
225	NOARGS		{ int sys_pathconf(char *path, int name); }
226	NOARGS		{ int sys_fpathconf(int fd, int name); }
227	UNIMPL
228	UNIMPL
229	UNIMPL		async_daemon
230	UNIMPL		nfs_fcntl
231	NOARGS		{ int compat_43_sys_getdirentries(int fd, char *buf, \
			    u_int count, long *basep); }
232	NOARGS		{ int compat_09_sys_getdomainname(char *domainname, \
			    int len); }
233	UNIMPL		nfs_getfh
234	UNIMPL		vfsmount
235	UNIMPL		nfs_svc
236	NOARGS		{ int compat_09_sys_setdomainname(char *domainname, \
			    int len); }
237	UNIMPL		statfs
238	UNIMPL		fstatfs
239	STD		{ int hpux_sys_sigaction(int signo, \
			    struct hpux_sigaction *nsa, \
			    struct hpux_sigaction *osa); }
240	STD		{ int hpux_sys_sigprocmask(int how, \
			    hpux_sigset_t *set, hpux_sigset_t *oset); }
241	STD		{ int hpux_sys_sigpending(hpux_sigset_t *set); }
242	STD		{ int hpux_sys_sigsuspend(hpux_sigset_t *set); }
243	UNIMPL		fsctl
244	UNIMPL
245	UNIMPL		pstat
246	UNIMPL
247	UNIMPL
248	UNIMPL
249	UNIMPL
250	UNIMPL
251	UNIMPL
252	UNIMPL
253	UNIMPL
254	UNIMPL
255	UNIMPL
256	UNIMPL
257	UNIMPL
258	UNIMPL
259	UNIMPL
260	UNIMPL
261	UNIMPL
262	UNIMPL
263	UNIMPL
264	UNIMPL
265	UNIMPL
266	UNIMPL
267	UNIMPL
268	NOARGS		{ int compat_43_sys_getdtablesize(void); }
269	UNIMPL
270	UNIMPL
271	UNIMPL
272	NOARGS		{ int sys_fchdir(int fd); }
273	UNIMPL
274	UNIMPL
275	NOARGS		{ int compat_43_sys_accept(int s, caddr_t name, \
			    int *anamelen); }
276	NOARGS		{ int sys_bind(int s, caddr_t name, int namelen); }
277	NOARGS		{ int sys_connect(int s, caddr_t name, int namelen); }
278	NOARGS		{ int compat_43_sys_getpeername(int fdes, caddr_t asa, \
			    int *alen); }
279	NOARGS		{ int compat_43_sys_getsockname(int fdec, caddr_t asa, \
			    int *alen); }
280	NOARGS		{ int sys_getsockopt(int s, int level, int name, \
			    caddr_t val, int *avalsize); }
281	NOARGS		{ int sys_listen(int s, int backlog); }
282	NOARGS		{ int compat_43_sys_recv(int s, caddr_t buf, int len, \
			    int flags); }
283	NOARGS		{ int compat_43_sys_recvfrom(int s, caddr_t buf, \
			    size_t len, int flags, caddr_t from, \
			    int *fromlenaddr); }
284	NOARGS		{ int compat_43_sys_recvmsg(int s, \
			    struct omsghdr *msg, int flags); }
285	NOARGS		{ int compat_43_sys_send(int s, caddr_t buf, int len, \
			    int flags); }
286	NOARGS		{ int compat_43_sys_sendmsg(int s, caddr_t msg, \
			    int flags); }
287	NOARGS		{ int sys_sendto(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t to, int tolen); }
288	STD		{ int hpux_sys_setsockopt2(int s, int level, int name, \
			    caddr_t val, int valsize); }
289	NOARGS		{ int sys_shutdown(int s, int how); }
290	NOARGS		{ int sys_socket(int domain, int type, int protocol); }
291	NOARGS		{ int sys_socketpair(int domain, int type, \
			    int protocol, int *rsv); }
292	UNIMPL
293	UNIMPL
294	UNIMPL
295	UNIMPL
296	UNIMPL
297	UNIMPL
298	UNIMPL
299	UNIMPL
300	UNIMPL
301	UNIMPL
302	UNIMPL
303	UNIMPL
304	UNIMPL
305	UNIMPL
306	UNIMPL
307	UNIMPL
308	UNIMPL
309	UNIMPL
310	UNIMPL
311	UNIMPL
#ifdef SYSVSEM
312	NOARGS		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } nsemctl
#else
312	UNIMPL		semctl
#endif
#ifdef SYSVMSG
313	NOARGS		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); } nmsgctl
#else
313	UNIMPL		msgctl
#endif
#ifdef SYSVSHM
314	STD		{ int hpux_sys_nshmctl(int shmid, int cmd, \
			    caddr_t buf); }
#else
314	UNIMPL		shmctl
#endif
