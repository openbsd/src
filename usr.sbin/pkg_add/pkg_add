#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: pkg_add,v 1.439 2009/12/27 22:27:03 espie Exp $
#
# Copyright (c) 2003-2009 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;

package OpenBSD::AddDelete;
use OpenBSD::Dependencies;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageLocator;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::Add;
use OpenBSD::SharedLibs;
use OpenBSD::UpdateSet;
use OpenBSD::Handle;

our ($state, %defines, $bad, $opt_B);

package OpenBSD::PackingList;

sub uses_old_libs
{
	my $plist = shift;
	require OpenBSD::RequiredBy;

	return  grep {/^\.libs\d*\-/o} 
	    OpenBSD::Requiring->new($plist->pkgname)->list;
}

sub has_new_sig
{
	my ($plist, $state) = @_;
	if (!defined $plist->{new_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname)->signature;
		my $o = $plist->signature;
		$state->say("Comparing full signature for ", $plist->pkgname, " \"$o\" vs. \"$n\": ", $n eq $o ? "equal" : "different") 
		    if $state->verbose >= 3;
		$plist->{new_sig} = $n ne $o;
	}
	return $plist->{new_sig};
}

package OpenBSD::State;
our @ISA=(qw(OpenBSD::UI));

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $set, @deps) = @_;

	if (defined $state->{deptree}->{$set}) {
		$set = $state->{deptree}->{$set};
	}
	for my $dep (@deps) {
		$state->{deptree}->{$dep} = $set unless
		    defined $state->{deptree}->{$dep};
	}
}

sub todo
{
	my $state = shift;
	return $state->tracker->sets_todo;
}

sub deptree_header
{
	my ($state, $pkg) = @_;
	if (defined $state->{deptree}->{$pkg}) {
		return $state->{deptree}->{$pkg}->short_print.':';
	} else {
		return '';
	}
}

sub set_name_from_handle
{
	my ($state, $h, $extra) = @_;
	$extra //= '';
	$state->log->set_context($extra.$h->pkgname);
}

sub updater
{
	my $state = shift;
	if (!defined $state->{updater}) {
		require OpenBSD::Update;
		$state->{updater} = OpenBSD::Update->new;
	}
	return $state->{updater};
}

sub tracker
{
	my $state = shift;
	if (!defined $state->{tracker}) {
		require OpenBSD::Tracker;
		$state->{tracker} = OpenBSD::Tracker->new;
	}
	return $state->{tracker};
}

sub quirks
{
	my $state = shift;

	return $state->{quirks};
}

package OpenBSD::UpdateSet;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

sub setup_header
{
	my ($set, $state, $handle, $info) = @_;

	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->print;
	}
	if (defined $info) {
		$header.=" ($info)";
	}

	if (!$state->progress->set_header($header)) {
		return unless $state->verbose;
		if (!defined $info) {
			$header = "Adding $header";
		}
		if (defined $state->{lastheader} && 
		    $header eq $state->{lastheader}) {
			return;
		}
		$state->{lastheader} = $header;
		print $header;
		print "(pretending) " if $state->{not};
		if ($state->{do_faked}) {
			print " under ", $state->{destdir};
		}
		print "\n";
	}
}

sub complete
{
	my ($set, $state) = @_;

	for my $n ($set->newer) {
		$n->complete($state);
		return 1 if $n->has_error;
	}
	for my $o ($set->older) {
		$o->complete_old($state);
	}

	return 1 if defined $set->{installable};

	$set->{installable} = $set->can_install($state);
	return 0 if !defined $set->{installable};

	if (!$set->{installable}) {
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		$state->tracker->cant($set);
	}
	return 1;
}

sub find_conflicts
{
	my ($set, $state) = @_;

	my @conflicts;

	for my $handle ($set->newer) {
		push(@conflicts, 
		    OpenBSD::PkgCfl::find_all($handle->plist, $state));
	}
	my %conflicts = map {($_,1)} @conflicts;
	return keys %conflicts;
}

sub mark_as_manual_install
{
	my $set = shift;

	for my $handle ($set->newer) {
		my $plist = $handle->plist;
		$plist->has('manual-installation') or
		    OpenBSD::PackingElement::ManualInstallation->add($plist);
	}
}

sub can_install
{
	my ($set, $state) = @_;

	my @conflicts = $set->find_conflicts($state);

	return 1 if @conflicts == 0;
	if (!$state->{allow_replacing}) {
		$state->errsay("Can't install ", $set->print, 
		    " because of conflicts (",join(',', @conflicts), ")");
		return 0;
	}


	my $later = 0;
	for my $toreplace (@conflicts) {
		if ($state->tracker->is_installed($toreplace)) {
			$state->errsay("Cannot replace $toreplace in ", 
			    $set->print, ": just got installed");
			return 0;
		}

		next if $set->{older}->{$toreplace};

		$later = 1;
		my $s = $state->tracker->is_to_update($toreplace);
		if (defined $s) {
			$set->merge($state->tracker, $s);
		} else {
			$set->add_older(OpenBSD::Handle->create_old($toreplace, 
			    $state));
		}
	}

	return if $later;

	require OpenBSD::ForwardDependencies;
	if (!defined $set->{forward}) {
		$set->{forward} = OpenBSD::ForwardDependencies->find($set);
		my $bad = $set->{forward}->check($set, $state);

		if (keys %$bad > 0) {
#			for my $m (keys %$bad) {
#				my $s = $state->tracker->is_to_update($m);
#				if (defined $s) {
#					$set->merge($state->tracker, $s);
#				} else {
#					$set->add_older(OpenBSD::Handle->create_old($m, 
#					    $state));
#				}
#			}
#			$state->say("Merging ", $set->print, $state->ntogo);
#			return;
			if ($state->{defines}->{updatedepends}) {
			    $state->errsay("Forcing update");
			} elsif ($state->{interactive}) {
				if ($state->confirm("Proceed with update anyways", 0)) {
				}
			} else {
				return 0;
			}
		}
	}


	my $manual_install = 0;

	for my $old ($set->older) {
		my $name = $old->pkgname;
		
		if ($old->has_error(OpenBSD::Handle::NOT_FOUND)) {
			Fatal "Can't find $name as an installed package\n";
		}
		if ($old->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			Fatal "Couldn't find packing-list for $name\n";
		}

		if ($old->plist->has('manual-installation')) {
			$manual_install = 1;
		}
	}

	$set->mark_as_manual_install if $manual_install;

	require OpenBSD::Replace;

	return OpenBSD::Replace::is_set_safe($set, $state);
}

sub recheck_conflicts
{
	my ($set, $state) = @_;
	
	# no conflicts between newer sets nor kept sets
	for my $h ($set->newer, $set->kept) {
		for my $h2 ($set->newer, $set->kept) {
			next if $h2 == $h;
			if ($h->plist->conflict_list->conflicts_with($h2->pkgname)) {
				$state->errsay($set->print, ": internal conflict between ", $h->pkgname, " and ", $h2->pkgname);
				return 0;
			}
		}
	}

	return 1;
}

package OpenBSD::AddDelete;

sub failed_message
{
	my ($base_msg, $interrupted, @l) = @_;
	my $msg = $base_msg;
	if ($interrupted) {
		$msg = "Caught SIG$interrupted. $msg";
	}
	if (@l > 0) {
		$msg.= ", partial installation recorded as ".join(',', @l);
	}
	return $msg;
}

sub save_partial_set
{
	my ($set, $state) = @_;

	return () if $state->{not};
	my @l = ();
	for my $h ($set->newer) {
		next unless defined $h->{partial};
		push(@l, OpenBSD::Add::record_partial_installation($h->plist, $state, $h->{partial}));
	}
	return @l;
}

sub partial_install
{
	my ($base_msg, $set, $state) = @_;
	return failed_message($base_msg, $state->{interrupted}, save_partial_set($set, $state));
}

sub build_before
{
	my %known = map {($_->pkgname, 1)} @_;
	require OpenBSD::RequiredBy;
	for my $c (@_) {
		for my $d (OpenBSD::RequiredBy->new($c->pkgname)->list) {
			push(@{$c->{before}}, $d) if $known{$d};
		}
	}
}

sub okay
{
	my ($h, $c) = @_;

	for my $d (@{$c->{before}}) {
		return 0 if !$h->{$d};
	}
	return 1;
}

sub iterate
{
	my $sub = pop @_;
	my $done = {};
	my $something_done;

	do {
		$something_done = 0;

		for my $c (@_) {
			next if $done->{$c->pkgname};
			if (okay($done, $c)) {
				&$sub($c);
				$done->{$c->pkgname} = 1;
				$something_done = 1;
			}
		}
	} while ($something_done);
	# if we can't do stuff in order, do it anyways
	for my $c (@_) {
		next if $done->{$c->pkgname};
		&$sub($c);
	}
}

sub really_add
{
	my ($set, $state) = @_;

	for my $h ($set->newer) {
		$h->plist->set_infodir($h->location->info);
	}

	$set->validate_plists($state);

	my $errors = 0;
	for my $handle ($set->newer) {
		$state->set_name_from_handle($handle, '+');
		my $plist = $handle->plist;
		if ($plist->is_signed) {
			if ($state->{defines}->{nosig}) {
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR ",
				    $plist->pkgname);
				$state->{check_digest} = 0;
			} else {
				require OpenBSD::x509;

				if (!OpenBSD::x509::check_signature($plist, 
				    $state)) {
					Fatal "fatal issues in ", $set->print;
				}
				$state->{check_digest} = 1;
				$state->{packages_with_sig}++;
			}
		} else {
			$state->{packages_without_sig}{$plist->pkgname} = 1;
			$state->{check_digest} = 0;
		}
	}

	if ($state->{not}) {
		$state->status->what("Pretending to add");
	} else {
		$state->status->what("Adding");
	}
	$set->setup_header($state);

	# XXX in `combined' updates, some dependencies may remove extra 
	# packages, so we do a double-take on the list of packages we 
	# are actually replacing.
	my $replacing = 0;
	if ($set->older_to_do) {
		$replacing = 1;
	} 
#	if (defined $plist->{old_libs}) {
#		$replacing = 1;
#	}
	$state->{replacing} = $replacing;

	$ENV{'PKG_PREFIX'} = $state->{localbase};

	my $handler = sub {
		$state->{interrupted} = shift;
	};
	local $SIG{'INT'} = $handler;
	local $SIG{'QUIT'} = $handler;
	local $SIG{'HUP'} = $handler;
	local $SIG{'KILL'} = $handler;
	local $SIG{'TERM'} = $handler;

	if ($replacing) {
		require OpenBSD::Replace;
		OpenBSD::Replace::save_old_libraries($set, $state);
	}

	$set->compute_size;

	if ($replacing) {
		for my $handle ($set->newer) {
			next if $state->{size_only};
			$set->setup_header($state, $handle, "extracting");

			try {
				OpenBSD::Replace::perform_extraction($handle, 
				    $state);
			} catchall {
				unless ($state->{interrupted}) {
					$state->errprint($_);
					$errors++;
				}
			};
			$state->progress->clear;
			if ($state->{interrupted} || $errors) {
				Fatal partial_install("Installation of ".
				    $handle->pkgname." failed", $set, $state);
			}
		}

		$set->{solver}->record_old_dependencies($state);
		build_before($set->older_to_do);
		iterate($set->older_to_do, sub {
			return if $state->{size_only};
			my $o = shift;
			$set->setup_header($state, $o, "deleting");
			my $oldname = $o->pkgname;
			$state->set_name_from_handle($o, '-');
			require OpenBSD::Delete;
			try {
			    OpenBSD::Delete::delete_plist($o->plist, $state);
			} catchall {
				$state->errprint($_);
				Fatal partial_install(
				    "Deinstallation of $oldname failed", 
				    $set, $state);
			};

			if (defined $state->{updatedepends}) {
				delete $state->{updatedepends}->{$oldname};
			}
			OpenBSD::PkgCfl::unregister($o->plist, $state);
			$state->progress->clear;
		});
		# Here there should be code to handle old libs
	}

	my $first = 1;
	iterate($set->newer, sub {
		return if $state->{size_only};
		my $handle = shift;

		if (!$first) {
			$state->progress->next;
			$first = 0;
		}
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		$set->setup_header($state, $handle,
		    $replacing ? "installing" : undef);
		$state->set_name_from_handle($handle, '+');

		try {
			OpenBSD::Add::perform_installation($handle, $state);
			if (!$state->{interrupted} && $plist->has(INSTALL)) {
				$plist->get(INSTALL)->run($state, 'POST-INSTALL');
			}
		} catchall {
			unless ($state->{interrupted}) {
				$state->errprint($_);
				$errors++;
			}
		};

		unlink($plist->infodir.CONTENTS);
		if ($state->{interrupted} || $errors) {
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
		}
	});
	$set->setup_header($state);
	$state->progress->next($state->ntogo(-1));
	for my $handle ($set->newer) {
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
		OpenBSD::Add::tweak_plist_status($plist, $state);
		$plist->to_cache;
		OpenBSD::Add::register_installation($plist);
		add_installed($pkgname);
		delete $handle->{partial};
		OpenBSD::PkgCfl::register($plist, $state);
		if ($plist->has(DISPLAY)) {
			$plist->get(DISPLAY)->prepare($state);
		}
	}
	for my $handle ($set->newer) {
		$set->{solver}->register_dependencies($state);
	}
	$set->{solver}->adjust_old_dependencies($state);
	if ($state->{repairdependencies}) {
		$set->{solver}->repair_dependencies($state);
	}
}

sub install_set
{
	my ($set, $state) = @_;

	$set = $set->real_set;

	if ($set->{finished}) {
		return ();
	}

	if (!$state->updater->process_set($set, $state)) {
		return ();
	}

	for my $handle ($set->newer) {
		if ($state->tracker->is_installed($handle->pkgname)) {
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return ();
		}
	}

	if (!$set->complete($state)) {
		return $set;
	}

	for my $handle ($set->newer) {
		if ($handle->has_error(OpenBSD::Handle::ALREADY_INSTALLED)) {
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return ();
		}
		if ($handle->has_error) {
			$state->set_name_from_handle($handle);
			$state->log("Can't install ", $handle->pkgname, ":",
				$handle->error_message, "\n"); 
			$bad++;
			$set->cleanup($handle->has_error);
			$state->tracker->cant($set);
			return ();
		}

		if ($handle->plist->has('arch')) {
			unless ($handle->plist->{arch}->check($state->{arch})) {
				$state->set_name_from_handle($handle);
				$state->log($handle->pkgname, " is not for the right architecture");
				if (!$defines{arch}) {
					$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
					$state->tracker->cant($set);
					return ();
				}
			}
		}
	}

	if (!defined $set->{solver} || $set->{solver}->{not_ready}) {
		delete $set->{solver};
		$set->{solver} = OpenBSD::Dependencies::Solver->new($set);
		my @deps = $set->{solver}->solve_depends($state);
		if ($state->verbose >= 2) {
			$set->{solver}->dump;
		}
		if (@deps > 0) {
			$state->build_deptree($set, @deps);
			if ($set->{solver}->check_for_loops($state)) {
				return $set;
			}
			return (@deps, $set);
		}
	}

	# verify dependencies have been installed
	my @baddeps = $set->{solver}->check_depends;

	if (@baddeps) {
		$state->errsay("Can't install ", $set->print,
		    ": can't resolve ", join(',', @baddeps));
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
		$bad++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		$state->tracker->cant($set);
		return ();
	}

#	print "Didn't need to process: ", join(',', @{$set->{solver}->{todo}}), "\n";
	if (!$set->{solver}->solve_wantlibs($state)) {
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		$state->tracker->cant($set);
		$bad++;
		return ();
	}
#	if (!$set->{solver}->solve_tags($state)) {
#		$location->close_now;
#		if (!$defines{libdepends}) {
#			$bad++;
#			return ();
#		}
#	}
	if (!$set->recheck_conflicts($state)) {
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		$state->tracker->cant($set);
		return ();
	}
	really_add($set, $state);
	$set->cleanup;
	$state->tracker->done($set);
	return ();
}



our ($opt_a, $opt_A, $opt_P, $opt_Q, $opt_r, $opt_u, $opt_U, $opt_l, $opt_z);

handle_options('aqchruUzl:A:P:Q:', {},
    'pkg_add [-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
    '[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');

local $SIG{'INFO'} = sub { $state->status->print($state); };
$state->{do_faked} = 0;
$state->{arch} = $opt_A;

if (defined $opt_Q and defined $opt_B) {
	Usage "-Q and -B are incompatible options";
}
if (defined $opt_Q and defined $opt_r) {
	Usage "-r and -Q are incompatible options";
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$state->{cdrom_only} = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$state->{ftp_only} = 1;
	}
	else {
	    Usage "bad option: -P $opt_P";
	}
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
	delete $ENV{'PKG_DESTDIR'};
}


$state->{automatic} = $opt_a;
$state->{allow_replacing} = $opt_r || $opt_u || $opt_U;
$state->{newupdates} = $opt_u || $opt_U;

if (@ARGV == 0 && !$opt_u && !$opt_l) {
	Usage "Missing pkgname";
}

# Here we create the list of packages to install
# actually, an updateset list (@todo2), and we hope to do this lazily
# later for the most part...
my @todo2 = ();

sub inform_user_of_problems
{
	my $state = shift;
	my @cantupdate = $state->tracker->cant_list;
	if (@cantupdate > 0) {
		$state->print("Couldn't find updates for ", join(', ', @cantupdate), "\n");
	}
	if (defined $state->{issues}) {
		$state->say("There were some ambiguities. ",
		    "Please run in interactive mode again.");
	}
}

# if we already have quirks, we update it. If not, we try to install it.
sub quirk_set
{
	require OpenBSD::PackageRepository::Installed;
	require OpenBSD::Search;

	my $set = OpenBSD::UpdateSet->new;
	$set->{quirks} = 1;
	my $l = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::Stem->new('quirks'));
	if (@$l > 0) {
		$set->add_older(map {OpenBSD::Handle->from_location($_)} @$l);
	} else {
		$set->add_hints2('quirks');
	}
	return $set;
}

sub do_quirks
{
	my $state = shift;

	install_set(quirk_set(), $state);
	eval {
		require OpenBSD::Quirks;
		# interface version number.
		$state->{quirks} = OpenBSD::Quirks->new(1);
	};
}

sub process_parameters
{
	# match fuzzily against a list
	if ($opt_l) {
		open my $f, '<', $opt_l or die "$!: bad list $opt_l";
		my $_;
		while (<$f>) {
			chomp;
			s/\s.*//;
			push(@todo2, OpenBSD::UpdateSet->new->add_hints($_));
		}
	}

	# update existing stuff
	if ($opt_u) {
		require OpenBSD::PackageRepository::Installed;

		if (@ARGV == 0) {
			@ARGV = sort(installed_packages());
		}
		my $inst = OpenBSD::PackageRepository::Installed->new;
		for my $pkgname (@ARGV) {
			my $l;

			if (OpenBSD::PackageName::is_stem($pkgname)) {
				$l = $state->updater->stem2location($inst, $pkgname, $state);
			} else {
				$l = $inst->find($pkgname, $state->{arch});
			}
			if (!defined $l) {
				$state->say("Problem finding $pkgname");
			} else {
				push(@todo2, OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l)));
			}
		}
	} else {

	# actual names
		my $m = $opt_z ? "add_hints" : "add_hints2";
		for my $pkgname (@ARGV) {
			next if $pkgname =~ m/^quirks\-\d/;
			push(@todo2, OpenBSD::UpdateSet->new->$m($pkgname));
		}
	}
}

sub finish_display
{
	OpenBSD::Add::manpages_index($state);


	# and display delayed thingies.
	if ($state->{packages_with_sig}) {
		$state->print("Packages with signatures: ", 
		    $state->{packages_with_sig});
		if ($state->{packages_without_sig}) {
			print ". UNSIGNED PACKAGES: ", 
			    join(', ', keys %{$state->{packages_without_sig}});
		}
		print "\n";
	}
	if (defined $state->{updatedepends} && %{$state->{updatedepends}}) {
		print "Forced updates, bogus dependencies for ", 
		    join(' ', sort(keys %{$state->{updatedepends}})),
		    " may remain\n";
	}
	inform_user_of_problems($state);
}


framework(
sub {
	if ($state->{allow_replacing}) {
		$state->progress->set_header("Looking for packages");
		do_quirks($state);
	}

	$state->tracker->todo(@todo2);
	# This is the actual very small loop that adds all packages
	while (my $set = shift @todo2) {
		$state->progress->set_header("Looking for packages");

		$state->status->what->set($set);
		unshift(@todo2, install_set($set, $state));
		eval {
			$state->quirks->tweak_list(\@todo2, $state);
		};
	}
});

