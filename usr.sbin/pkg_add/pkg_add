#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: pkg_add,v 1.132 2004/12/02 00:04:38 espie Exp $
#
# Copyright (c) 2003-2004 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# this is it ! The hard one
use strict;
use warnings;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageLocator;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::PkgSpec;
use OpenBSD::Vstat;
use OpenBSD::Getopt;
use OpenBSD::Error;
use OpenBSD::ProgressMeter;
use OpenBSD::Add;
use OpenBSD::SharedLibs;

our %forced = ();

package main;

sub fill_conflict_lists
{
	my $state = shift;
	# first, find all possible potential conflicts
	for my $pkg (installed_packages()) {
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::ConflictOnly);
		next unless defined $plist;
		$state->{conflict_list}->{$plist->pkgname()} = 
		    OpenBSD::PkgCfl->make_conflict_list($plist);
	}
}

my $errors = 0;

sub find_conflicts($$)
{
	my ($pkgname, $state) = @_;
	my @bad = ();
	if (is_installed $pkgname) {
		push(@bad, $pkgname);
	}
	while (my ($name, $l) = each %{$state->{conflict_list}}) {
		next if $name eq $pkgname;
		if ($l->conflicts_with($pkgname)) {
			push(@bad, $name);
		}
	}
	return @bad;
}

sub can_install($$)
{
	my ($pkgname, $state) = @_;

	my @l = find_conflicts($pkgname, $state);

	return 1 if @l == 0;
	if (!$state->{replace} || @l >= 2) {
		print "Can't install $pkgname because of conflicts (",join(',', @l), ")\n";
		$errors++;
		return undef;
	}

	require OpenBSD::Update;

	my $plist = OpenBSD::Update::can_do($l[0], $pkgname, $state);
	if ($plist) {
		$plist->{dir} = installed_info($l[0]);
		return $plist;
	} else {
		print "Can't update $l[0] into $pkgname\n";
		$errors++;
		return undef;
	}
}


# This does pre_add a package: finding it and reading its package information
sub pre_add($$)
{
	my ($pkg, $state) = @_;
	my $pkgname1;
	my $toreplace;
	
	if ($pkg ne '-') {
		if ($state->{verbose}) {
			if (defined $state->{deptree}->{$pkg}) {
			    print $state->{deptree}->{$pkg},":";
			}
			print "parsing $pkg\n";
		}
		$pkgname1 = OpenBSD::PackageName::url2pkgname($pkg);
		$toreplace = can_install($pkgname1, $state);
		return undef unless $toreplace;
	}

	my $handle = OpenBSD::PackageLocator->find($pkg);
	if (!$handle) {
		print "Can't find $pkg\n";
		$errors++;
		return undef;
	}
	my $dir = $handle->info();
    	my $plist = $handle->{plist} = 
	    OpenBSD::PackingList->fromfile($dir.CONTENTS);
	unless (defined $plist) {
		print "Can't find CONTENTS from $pkg\n";
		$errors++;
		return undef;
	}
	if ($plist->pkgbase() ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->pkgbase(), " , user wants: ", $state->{localbase}, "\n";
		$errors++;
		return undef;
	}
	my $pkgname = $plist->pkgname();
	if (defined $pkgname1) {
		if ($pkgname ne $pkgname1) {
			print "Package name is not consistent ???\n";
			$errors++;
			return undef;
		}
	} else {
		if ($state->{verbose}) {
			if (defined $state->{deptree}->{$pkg}) {
			    print $state->{deptree}->{$pkg},":";
			}
			print "parsing $pkgname\n";
		}
		$toreplace = can_install($pkgname, $state);
		return undef unless $toreplace;
	}
	my $avoid = '';
	if ($toreplace ne '1') {
		$plist->{replacing} = $toreplace;
		$avoid = $toreplace->pkgname();

		require OpenBSD::Update;

		if (!OpenBSD::Update::is_safe($plist, $state)) {
			print "Can't safely update $avoid to $pkgname\n";
			$errors++;
		}
	}
	# second handling of conflicts
	my $l = OpenBSD::PkgCfl->make_conflict_list($plist);
	$handle->{conflicts} = $l;
	if ($l->conflicts_with(grep {$_ ne $avoid} installed_packages())) {
		print "package $pkg has conflicts: ", 
		    join(' ', $l->conflicts_with(installed_packages())), "\n";
		$errors++;
		return undef unless $forced{conflicts};
	}
	return $handle;
}


sub solve_dependencies
{
	my ($verbose, $handle, @extra) = @_;
	my $plist = $handle->{plist};
	my $to_register = $handle->{solved_dependencies} = {};
	my $to_install;

	# do simple old style pkgdep first
	my @deps = ();
	for my $dep (@{$plist->{pkgdep}}) {
		if (!is_installed($dep->{name})) {
			push(@deps, $dep->{name});
		}
		$to_register->{$dep->{name}} = 1;
	}
	for my $dep (@{$plist->{depend}}, @{$plist->{newdepend}}, @{$plist->{libdepend}}) {
	    next if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
	    my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, installed_packages());
	    if (@candidates >= 1) {
		    $to_register->{$candidates[0]} = 1;
	    } else {
	    	if (!defined $to_install) {
			$to_install = {};
			for my $fullname (@extra) {
			    $to_install->{OpenBSD::PackageName::url2pkgname($fullname)} = $fullname;
			}
		}
	    	# try against list of packages to install
	    	my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@candidates >= 1) {
		    push(@deps, $to_install->{$candidates[0]});
		    $to_register->{$candidates[0]} = 1;
		} else {
		    # try with list of packages
		    my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, OpenBSD::PackageLocator::available());
		    # one single choice
		    if (@candidates == 1) {
			push(@deps, $candidates[0]);
			$to_register->{$candidates[0]} = 1;
		    } elsif (@candidates > 1) {
			# grab default if available
		    	if (grep {$_ eq $dep->{def}} @candidates) {
			    push(@deps, $dep->{def});
			    $to_register->{$dep->{def}} = 1;
			# grab first one otherwise
			} else {
			    push(@deps, $candidates[0]);
			    $to_register->{$candidates[0]} = 1;
			}
		    } else {
			# can't get a list of packages, assume default
			# will be there.
			push(@deps, $dep->{def});
			$to_register->{$dep->{def}} = 1;
		    }
		}
	    }
	}

	if ($verbose && %$to_register) {
	    print "Dependencies for ", $plist->pkgname(), " resolve to: ", 
	    	join(', ', keys %$to_register);
	    print " (todo: ", join(',', @deps), ")" if @deps > 0;
	    print "\n";
	}
	return @deps;
}

sub check_lib_spec
{
	my ($verbose, $base, $spec, $dependencies) = @_;
	my @r = OpenBSD::SharedLibs::lookup_libspec($base, $spec);
	for my $candidate (@r) {
		if ($dependencies->{$candidate}) {
			print " found in $candidate\n" if $verbose;
			return 1;
		}
	}
	print " not found." if $verbose;
	return undef;
}

sub do_script
{
	my ($plist, $name, $state, $args) = @_;
	$state->{dir} = $plist->{dir};
	return unless $plist->has($name);
	$plist->get($name)->run($state, $args);
}


sub really_add($$)
{
	my ($handle, $state) = @_;
	my $destdir = $state->{destdir};
	my $not = $state->{not};
	my $plist = $handle->{plist};
	my $dir = $handle->info();
	my $pkgname = $plist->pkgname();
	$state->{archive} = $handle;
	$plist->{dir} = $dir;
	$state->set_pkgname($pkgname);
	if (defined $plist->{replacing}) {
		$state->{replacing} = 1;
	} else {
		$state->{replacing} = 0;
	}

	my $header = $pkgname;

	if (defined $state->{deptree}->{$pkgname}) {
	    $header = $state->{deptree}->{$pkgname}.":".$header;
	}
	if (defined $plist->{replacing}) {
		$header.=" (replacing ". $plist->{replacing}->pkgname(). ")";
	}
	if (!OpenBSD::ProgressMeter::set_header($header)) {
	    print $state->{not} ? "Pretending to add " : "Adding ";
	    print $header;
	    if ($state->{do_faked}) {
		    print " under ", $state->{destdir};
	    }
	    print "\n";
	}
	my $totsize = OpenBSD::Add::validate_plist($plist, $state);

	if (!defined $handle) {
		Fatal "Archive in $pkgname broken";
	}

	$ENV{'PKG_PREFIX'} = $plist->pkgbase();

	my $interrupted;
	local $SIG{'INT'} = sub {
		$interrupted = 1;
	};

	if (defined $plist->{replacing}) {
		require OpenBSD::Update;

		OpenBSD::ProgressMeter::set_header("$pkgname (extracting)");
		OpenBSD::Update::save_old_libraries($plist, $state);
		my $donesize = 0;
		$plist->{done} = [];
		for my $item (@{$plist->{items}}) {
			eval { $item->extract($state); };
			if ($@) {
				Warn $@;
				$errors++;
				last;
			}
			push(@{$plist->{done}}, $item);
			if (defined $item->{size}) {
				$donesize += $item->{size};
				OpenBSD::ProgressMeter::show($donesize, $totsize);
			}
			last if $interrupted;
		}
		OpenBSD::ProgressMeter::next();
		if ($interrupted || $errors) {
			if ($not) {
				Fatal "Installation of $pkgname failed";
		    	} else {
				OpenBSD::Add::borked_installation($plist, $dir);
			}
		}

		OpenBSD::ProgressMeter::set_header($plist->{replacing}->pkgname()." (deleting)");
		$state->set_pkgname($plist->{replacing}->pkgname());
		require OpenBSD::Delete;
		OpenBSD::Delete::delete_plist($plist->{replacing}, $state);
		delete_installed($plist->{replacing}->pkgname());

		OpenBSD::ProgressMeter::set_header("$pkgname (installing)");
		$state->set_pkgname($pkgname);
	}

	do_script($plist, REQUIRE, $state, "INSTALL");

	do_script($plist, INSTALL, $state, "PRE-INSTALL");

	$plist->{done} = [];
	my $donesize = 0;
	$state->{end_faked} = 0;
	for my $item (@{$plist->{groups}}, @{$plist->{users}}, @{$plist->{items}}) {
		eval { $item->install($state); };
		if ($@) {
			Warn $@;
			$errors++;
			last;
		}
		push(@{$plist->{done}}, $item);
		if (defined $item->{size}) {
                        $donesize += $item->{size};
                        OpenBSD::ProgressMeter::show($donesize, $totsize);
                }

		last if $interrupted;
		# stop faked installation there...
		if ($state->{do_faked} && $state->{end_faked}) {
			last;
		}
	}

	$handle->close();
	OpenBSD::ProgressMeter::next();

	if (!($interrupted || $errors)) {
		eval { do_script($plist, INSTALL, $state, "POST-INSTALL") };
		if ($@) {
			Warn $@;
			$errors++;
		}
	}

	unlink($dir.CONTENTS);
	if ($interrupted || $errors) {
		if ($not) {
			Fatal "Installation of $pkgname failed";
		} else {
			OpenBSD::Add::borked_installation($plist, $dir);
		}
	}
	if ($not) {
		$plist->to_cache();
	} else {
		my $dest = installed_info($pkgname);
		OpenBSD::Add::register_installation($dir, $dest, $plist);
		if (!$state->{replace}) {
			$plist->forget();
		}
		if (defined $handle->{solved_dependencies}) {
			require OpenBSD::RequiredBy;

			my $r = OpenBSD::Requiring->new($pkgname);

			for my $dep (keys %{$handle->{solved_dependencies}}) {
				OpenBSD::RequiredBy->new($dep)->add($pkgname);
				$r->add($dep);
			}
		}
	}
	add_installed($pkgname);
	if ($plist->has(DISPLAY)) {
		$plist->get(DISPLAY)->prepare($state);
	}
	# and add dependencies corresponding to the replacement
	if (defined $plist->{replacing}) {
		require OpenBSD::RequiredBy;
		require OpenBSD::Update;

		print "Adjusting dependencies for $pkgname\n" 
		    if $state->{beverbose};
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@{$plist->{replacing}->{wantlist}}) {
			print "\t$dep\n" if $state->{beverbose};
			$d->add($dep) unless $state->{not};
			OpenBSD::Update::adjust_dependency($dep, $plist->{replacing}->pkgname(), $pkgname) unless $state->{not};
		}
	}
}

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $pkg, @deps) = @_;

	my $tree = $state->{deptree};
	$pkg = OpenBSD::PackageName::url2pkgname($pkg);
	# flatten info
	if (defined $tree->{$pkg}) {
		$pkg = $tree->{$pkg};
	}
	for my $i (@deps) {
		$tree->{$i} = $pkg unless defined $tree->{$i};
	}
}

sub find_old_lib
{
	my ($state, $base, $pattern, $lib, $dependencies) = @_;

	$pattern = ".libs-".$pattern;
	for my $try (OpenBSD::PkgSpec::match($pattern, installed_packages())) {
		OpenBSD::SharedLibs::add_package_libs($try);
		if (check_lib_spec($state->{very_verbose},
		    $state->{destdir}.$base, $lib, {$try => 1})) {
			Warn "Found library ", $lib, " in old package $try\n";
			$dependencies->{$try} = 1;
			return 1;
		}
	}
	return 0;
}

sub lookup_library
{
	my ($state, $lib, $plist, $dependencies, $harder) = @_;

	print "checking libspec $lib..." if $state->{very_verbose};
	if (check_lib_spec($state->{very_verbose},
	    $state->{destdir}.$plist->pkgbase(), $lib, $dependencies)) {
	    return 1;
	}
	if ($harder && $lib !~ m|/|) {

		OpenBSD::SharedLibs::add_system_libs($state->{destdir});
		if (check_lib_spec($state->{very_verbose},
		    $state->{destdir}."/usr", $lib, {system => 1})) {
			return 1;
		}
		if (check_lib_spec($state->{very_verbose},
		    $state->{destdir}."/usr/X11R6", $lib, {system => 1})) {
			return 1;
		}
	}
	for my $dep (@{$plist->{depends}}) {
		if (find_old_lib($state, $plist->pkgbase(), $dep->{pattern}, $lib, $dependencies)) {
			return 1;
		}
    	}
	if ($harder) {
		# lookup through the full tree...
		my $done = {};
		my @todo = keys %$dependencies;
		while (my $dep = pop @todo) {
			require OpenBSD::RequiredBy;

			next if $done->{$dep};
			$done->{$dep} = 1;
			for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
				push(@todo, $dep2) unless $done->{$dep2};
			}
			next if $dependencies->{$dep};
			OpenBSD::SharedLibs::add_package_libs($dep);
			if (check_lib_spec($state->{very_verbose},
			    $state->{destdir}.$plist->pkgbase(), $lib, {$dep => 1})) {
				Warn "Found library ", $lib, " in dependent package $dep\n";
				$dependencies->{$dep} = 1;
				return 1;
			}
		}
	}
	print "\n" if $state->{very_verbose};
}


sub install_package
{
	my ($pkg, $state, @todo) = @_;
	my $cache = $state->{cache};

	if (!defined $cache->{$pkg}) {
		$cache->{$pkg} = pre_add($pkg, $state);
	}

	my $handle = $cache->{$pkg};
	if ($errors > 0) {
		Fatal "Fatal error" unless defined $handle;
	} else {
		return () unless defined $handle;
	}

	my $plist = $handle->{plist};

	if (is_installed($plist->pkgname()) && !$state->{forced}->{installed}) {
		if ($state->{replace}) {
			if (!OpenBSD::Update::is_needed($plist, $state)) {
				$handle->close();
				return ();
			}
		} else {
			$handle->close();
			return ();
		}
	}
	if ($plist->has('arch')) {
		unless ($plist->{arch}->check($state->{arch})) {
			print "$pkg is not for the right architecture\n";
			return () unless $forced{arch};
		}
	}
	if (!defined $handle->{solved_dependencies}) {
		my @deps = solve_dependencies($state->{verbose}, $handle, @todo);
		if (@deps > 0) {
			build_deptree($state, $pkg, @deps);
			return (@deps, $pkg);
		}
	}

	# verify dependencies and register them

	for my $dep (keys %{$handle->{solved_dependencies}}) {
		next if is_installed($dep);
		print "Can't install $pkg: can't resolve $dep\n";
		return ();
	}

	# grab libraries
	for my $dep (keys %{$handle->{solved_dependencies}}) {
		OpenBSD::SharedLibs::add_package_libs($dep);
	}
	for my $dep (@{$plist->{libdepend}}) {
		return () if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
		for my $spec (split(/,/, $dep->{libspec})) {
		    if (!lookup_library($state, $spec, $plist,
			$handle->{solved_dependencies}, 0)) {
			    Warn "Can't install $pkg: lib not found $spec\n";
			    return () unless $forced{libdepends};
		    }
		}
	}
	for my $lib (@{$plist->{wantlib}}) {
		if (!lookup_library($state, $lib->{name}, $plist,
		    $handle->{solved_dependencies}, 1)) {
		    	Warn "Can't install $pkg: lib not found ", $lib->{name}, "\n";
			return () unless $forced{libdepends};
		}
	}
	really_add($handle, $state);
	$state->{conflict_list}->{$plist->pkgname()} = $handle->{conflicts};
	return ();
}

our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c);
$opt_v = 0;
getopts('aqcvnrxIL:f:B:A:P:Q:',
	{'v' => sub {++$opt_v;},
	 'f' => sub { 
	 		for my $o (split/,/, shift) { 
				$forced{$o} = 1;
			}
	    	}});
$opt_L = '/usr/local' unless defined $opt_L;

my $state = new OpenBSD::Error;
$state->{cache} = {};
$state->{deptree} = {};
$state->{do_faked} = 0;
$state->{replace} = $opt_r;
$state->{localbase} = $opt_L;
$state->{arch} = $opt_A;
$state->{forced} = \%forced;

if (defined $opt_Q and defined $opt_B) {
	Fatal "-Q and -B are incompatible options";
}
if (defined $opt_Q and defined $opt_r) {
	Fatal "-r and -Q are incompatible options";
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$state->{cdrom_only} = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$state->{ftp_only} = 1;
	}
	else {
	    Fatal "bad option: -P $opt_P";
	}
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
}


$state->{conflict_list} = {};
$state->{not} = $opt_n;
$state->{quick} = $opt_q;
$state->{extra} = $opt_c;
$state->{dont_run_scripts} = $opt_I;
$state->{very_verbose} = $opt_v >= 2;
$state->{verbose} = $opt_v;
$state->{beverbose} = $opt_n || ($opt_v >= 2);

if (!$opt_x && !$state->{beverbose}) {
	OpenBSD::ProgressMeter::enable();
}

if ($< && !$forced{nonroot}) {
	if ($state->{not}) {
		Warn "$0 should be run as root\n";
	} else {
		Fatal "$0 must be run as root";
	}
}

fill_conflict_lists($state);
my @todo = (@ARGV);

eval {
while (my $pkg = shift @todo) {
	unshift(@todo, install_package($pkg, $state, @todo));
}
};

my $dielater = $@;

OpenBSD::PackingElement::Fontdir::finish_fontdirs($state);
OpenBSD::Add::manpages_index($state);
OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
# delayed directory/user/group removal
if (defined $state->{dirs_to_rm} or defined $state->{users_to_rm} or
	defined $state->{groups_to_rm}) {
	require OpenBSD::SharedItems;

	OpenBSD::SharedItems::cleanup($state);
}

if ($state->{beverbose}) {
	OpenBSD::Vstat::tally();
}
$state->delayed_output();
if ($dielater) {
	die $dielater;
}
