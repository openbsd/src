#!/usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: pkg_delete,v 1.126 2009/11/28 09:36:32 espie Exp $
#
# Copyright (c) 2003-2007 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;

package OpenBSD::State;
our @ISA=(qw(OpenBSD::UI));

package OpenBSD::AddDelete;
our ($state, %defines, $bad, $opt_B);

use OpenBSD::PackingList;
use OpenBSD::RequiredBy;
use OpenBSD::Delete;
use OpenBSD::PackageInfo;
use OpenBSD::UpdateSet;

our ($opt_d, $opt_p, $opt_i);

handle_options('chixDdnqpS:', {},
    'pkg_delete [-cIinqvx] [-B pkg-destdir] [-F keywords] pkg-name [...]');

$opt_B = $ENV{'PKG_DESTDIR'} unless defined $opt_B;
$opt_B = '' unless defined $opt_B;
if ($opt_B ne '') {
	$opt_B.='/' unless $opt_B =~ m/\/$/o;
}
$ENV{'PKG_DESTDIR'} = $opt_B;

if (defined $opt_p) {
	Usage "Option p is obsolete";
}
if (defined $opt_d) {
	Usage "Option d is obsolete";
}

$state->{destdir} = $opt_B;
if ($opt_B eq '') {
    $state->{destdirname} = '';
} else {
    $state->{destdirname} = '${PKG_DESTDIR}';
}

$ENV{'PKG_DELETE_EXTRA'} = $state->{extra} ? "Yes" : "No";


my %done;
my $removed;

# Resolve pkg names
my @realnames;
my @todo;

sub process_parameters
{
	OpenBSD::PackageInfo::solve_installed_names(\@ARGV, \@realnames, 
	    "(removing them all)", $state);

	@todo = OpenBSD::RequiredBy->compute_closure(@realnames);

	if (@todo > @realnames) {
		my $details = $state->{very_verbose} || $defines{verbosedeps};
		my $show    = sub {
			my ($p, $d) = @_;
			$state->say("Can't remove ", join(' ', @$p), 
			    " without also removing:\n",
			    join(' ', @$d));
		};
		if ($state->{interactive} || !$details) {
			my %deps = map {($_, 1)} @todo;
			for my $p (@realnames) {
				delete $deps{$p};
			}
			&$show([@realnames], [keys %deps]);
			if (@realnames > 1 && (keys %deps) > 1 && 
			    $state->confirm("Do you want details", 1)) {
				$details = 1;
			}
		}
		if ($details) {
			for my $pkg (@realnames) {
				my @deps = OpenBSD::RequiredBy->compute_closure($pkg);
				next unless @deps > 1;
				@deps = grep {$_ ne $pkg} @deps;
				&$show([$pkg], [@deps]);
			}
		}
		my $them = @todo > 1 ? 'them' : 'it';
		if ($defines{dependencies} or 
		    $state->confirm("Do you want to remove $them as well", 0)) {
			$state->say("(removing $them as well)");
		} else {
			$bad = 1;
		}
	}
}

sub finish_display
{
}

framework(
sub {
	# and finally, handle the removal
	do {
		$removed = 0;
		DELETE: while (my $pkgname = pop @todo) {
			$state->{todo} = scalar @todo;
			next if $done{$pkgname};
			unless (is_installed($pkgname)) {
				$state->say("$pkgname was not installed");
				$done{$pkgname} = 1;
				$removed++;
				next;
			}
			my $r = OpenBSD::RequiredBy->new($pkgname);
			if ($r->list > 0) {
				if ($defines{baddepend}) {
					for my $p ($r->list) {
						if ($done{$p}) {
							$r->delete($p);
						} else {
							next DELETE;
						}
					}
				} else {
					next;
				}
			}
			if (!$state->progress->set_header($pkgname)) {
				print $state->{not} ? "Pretending to delete " : 
				    "Deleting ", 
				    "$pkgname\n";
			}
			$state->log->set_context($pkgname);
			OpenBSD::Delete::delete_package($pkgname, $state);
			$done{$pkgname} = 1;
			$removed++;
		}
	} while ($removed);
});
