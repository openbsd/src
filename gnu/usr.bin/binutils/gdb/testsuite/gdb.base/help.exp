#   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@cygnus.com)

#
# test gdb help commands
#

set prms_id 0
set bug_id 0

# force the height of the debugger to be pretty large so no pagers getused
send "set height 400\n"
expect -re "$prompt $"

# use a larger expect input buffer for long help outputs.
match_max 6000

# test help add-symbol-file
send "help add-symbol-file\n"
expect 	{
	-re "Usage: add-symbol-file FILE ADDR.*
Load the symbols from FILE, assuming FILE has been dynamically loaded..*
ADDR is the starting address of the file\'s text..*$prompt $" \
 			{ pass "help add-symbol-file" }
	-re ".*$prompt $"	{ fail "help add-symbol-file" }
	timeout		{ fail "(timeout) help add-symbol-file" }
	}


# test help aliases
send "help aliases\n"
expect {
	-re "Aliases of other commands..*
List of commands\:.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help aliases" }
	-re "$prompt $" { fail "help aliases" }
	timeout		{ fail "(timeout) help aliases" }
	}


send "help attach\n"
expect {
	-re "Attach to a process or file outside of GDB..*
This command attaches to another target, of the same type as your last.*
`target' command .`info files' will show your target stack.*
The command may take as argument a process id or a device file..*
For a process id, you must have permission to send the process a signal,.*
and it must have the same effective uid as the debugger..*
When using \"attach\", you should use the \"file\" command to specify.*
the program running in the process, and to load its symbol table..*$prompt $"\
			{ pass "help attach" }
	-re "$prompt $"	{ fail "help attach" }
	timeout		{ fail "(timeout) help attach" }
	} 

#	-re "$prompt $"	{ fail "help attach" }

# test help breakpoint "b" abbreviation
send "help b\n"
expect {
	-re "Set breakpoint at specified line or function..*
Argument may be line number, function name, or \"\[*\]\" and an address..*
If line number is specified, break at start of code for that line..*
If function is specified, break at start of code for that function..*
If an address is specified, break at that exact address..*
With no arg, uses current execution address of selected stack frame..*
This is useful for breaking on return to a stack frame..*
Multiple breakpoints at one place are permitted, and useful if conditional..*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help breakpoint \"b\" abbreviation" }
	-re "$prompt $"	{ fail "help breakpoint \"b\" abbreviation" }
	timeout		{ fail "(timeout) help breakpoint \"b\" abbreviation" }
	}


# test help breakpoint "br" abbreviation
send "help br\n"
expect {
	-re "Set breakpoint at specified line or function..*
Argument may be line number, function name, or \"\[*\]\" and an address..*
If line number is specified, break at start of code for that line..*
If function is specified, break at start of code for that function..*
If an address is specified, break at that exact address..*
With no arg, uses current execution address of selected stack frame..*
This is useful for breaking on return to a stack frame..*
Multiple breakpoints at one place are permitted, and useful if conditional..*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help breakpoint \"br\" abbreviation" }
	-re "$prompt $"	{ fail "help breakpoint \"br\" abbreviation" }
	timeout		{ fail "(timeout) help breakpoint \"br\" abbreviation" }
	}


# test help breakpoint "bre" abbreviation
send "help bre\n"
expect {
	-re "Set breakpoint at specified line or function..*
Argument may be line number, function name, or \"\[*\]\" and an address..*
If line number is specified, break at start of code for that line..*
If function is specified, break at start of code for that function..*
If an address is specified, break at that exact address..*
With no arg, uses current execution address of selected stack frame..*
This is useful for breaking on return to a stack frame..*
Multiple breakpoints at one place are permitted, and useful if conditional..*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help breakpoint \"bre\" abbreviation" }
	-re "$prompt $"	{ fail "help breakpoint \"bre\" abbreviation" }
	timeout		{ fail "(timeout) help breakpoint \"bre\" abbreviation" }
	}


# test help breakpoint "brea" abbreviation
send "help brea\n"
expect {
	-re "Set breakpoint at specified line or function..*
Argument may be line number, function name, or \"\[*\]\" and an address..*
If line number is specified, break at start of code for that line..*
If function is specified, break at start of code for that function..*
If an address is specified, break at that exact address..*
With no arg, uses current execution address of selected stack frame..*
This is useful for breaking on return to a stack frame..*
Multiple breakpoints at one place are permitted, and useful if conditional..*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help breakpoint \"brea\" abbreviation" }
	-re "$prompt $"	{ fail "help breakpoint \"brea\" abbreviation" }
	timeout		{ fail "(timeout) help breakpoint \"brea\" abbreviation" }
	}


# test help breakpoint "break" abbreviation
send "help break\n"
expect {
	-re "Set breakpoint at specified line or function..*
Argument may be line number, function name, or \"\[*\]\" and an address..*
If line number is specified, break at start of code for that line..*
If function is specified, break at start of code for that function..*
If an address is specified, break at that exact address..*
With no arg, uses current execution address of selected stack frame..*
This is useful for breaking on return to a stack frame..*
Multiple breakpoints at one place are permitted, and useful if conditional..*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help breakpoint \"break\" abbreviation" }
	-re "$prompt $"	{ fail "help breakpoint \"break\" abbreviation" }
	timeout		{ fail "(timeout) help breakpoint \"break\" abbreviation" }
	}


# test help breakpoints
send "help breakpoints\n"
expect {
	-re "Making program stop at certain points..*
List of commands\:.*
watch -- Set a watchpoint for an expression.*
catch -- Set breakpoints to catch exceptions that are raised.*
break -- Set breakpoint at specified line or function.*
clear -- Clear breakpoint at specified line or function.*
delete -- Delete some breakpoints or auto-display expressions.*
disable -- Disable some breakpoints.*
enable -- Enable some breakpoints.*
tbreak -- Set a temporary breakpoint.*
condition -- Specify breakpoint number N to break only if COND is true.*
commands -- Set commands to be executed when a breakpoint is hit.*
ignore -- Set ignore-count of breakpoint number N to COUNT.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help breakpoints" }
	-re "$prompt $"	{ fail "help breakpoints" }
	timeout		{ fail "(timeout) help breakpoints" }
	}


# test help backtrace "bt" abbreviation
send "help bt\n"
expect {
	-re "Print backtrace of all stack frames, or innermost COUNT frames..*
With a negative argument, print outermost -COUNT frames..*$prompt $"\
			{ pass "help backtrace \"bt\" abbreviation" }
	-re "$prompt $"	{ fail "help backtrace \"bt\" abbreviation" }
	timeout		{ fail "(timeout) help backtrace \"bt\" abbreviation" }
	}


# test help backtrace
send "help backtrace\n"
expect {
	-re "Print backtrace of all stack frames, or innermost COUNT frames..*
With a negative argument, print outermost -COUNT frames..*$prompt $"\
			{ pass "help backtrace" }
	-re "$prompt $"	{ fail "help backtrace" }
	timeout		{ fail "(timeout) help backtrace" }
	}


# test help continue "c" abbreviation
send "help c\n"
expect {
	-re "Continue program being debugged.*$prompt $"\
			{ pass "help continue \"c\" abbreviation" }
	-re "$prompt $"	{ fail "help continue \"c\" abbreviation" }
	timeout		{ fail "(timeout) help continue \"c\" abbreviation" }
	}


# test help continue
send "help continue\n"
expect {
	-re "Continue program being debugged.*$prompt $"\
			{ pass "help continue" }
	-re "$prompt $"	{ fail "help continue" }
	timeout		{ fail "(timeout) help continue" }
	}


# test help call
send "help call\n"
expect {
	-re "Call a function.*$prompt $"\
			{ pass "help call" }
	-re "$prompt $"	{ fail "help call" }
	timeout		{ fail "(timeout) help call" }
	}


# test help catch
send "help catch\n"
expect {
	-re "Set breakpoints to catch exceptions that are raised..*
Argument may be a single exception to catch, multiple exceptions.*
to catch, or the default exception \"default\".  If no arguments.*
are given, breakpoints are set at all exception handlers catch clauses.*
within the current scope..*
A condition specified for the catch applies to all breakpoints set.*
with this command.*
Do \"help breakpoints\" for info on other commands dealing with breakpoints..*$prompt $"\
			{ pass "help catch" }
	-re "$prompt $"	{ fail "help catch" }
	timeout		{ fail "(timeout) help catch" }
	}


# test help cd
send "help cd\n"
expect {
	-re "Set working directory to DIR for debugger and program being debugged..*
The change does not take effect for the program being debugged.*
until the next time it is started..*$prompt $"\
			{ pass "help cd" }
	-re "$prompt $"	{ fail "help cd" }
	timeout		{ fail "(timeout) help cd" }
	}


# test help clear
send "help clear\n"
expect {
	-re "Clear breakpoint at specified line or function.*
Argument may be line number, function name, or .* and an address.*
If line number is specified, all breakpoints in that line are cleared.*
If function is specified, breakpoints at beginning of function are cleared.*
If an address is specified, breakpoints at that address are cleared.*
With no argument, clears all breakpoints in the line that the selected frame.*
is executing in..*
See also the \"delete\" command which clears breakpoints by number..*$prompt $"\
			{ pass "help clear" }
	-re "$prompt $"	{ fail "help clear" }
	timeout		{ fail "(timeout) help clear" }
	}


# test help commands
send "help commands\n"
expect {
	-re "Set commands to be executed when a breakpoint is hit..*
Give breakpoint number as argument after \"commands\"..*
With no argument, the targeted breakpoint is the last one set..*
The commands themselves follow starting on the next line..*
Type a line containing \"end\" to indicate the end of them..*
Give \"silent\" as the first line to make the breakpoint silent;.*
then no output is printed when it is hit, except what the commands print..*$prompt $"\
			{ pass "help commands" }
	-re "$prompt $"	{ fail "help commands" }
	timeout		{ fail "(timeout) help commands" }
	}


# test help condition
send "help condition\n"
expect {
	-re "Specify breakpoint number N to break only if COND is true..*
Usage is `condition N COND', where N is an integer and COND is an.*
expression to be evaluated whenever breakpoint N is reached.  .*$prompt $"\
			{ pass "help condition" }
	-re "$prompt $"	{ fail "help condition" }
	timeout		{ fail "(timeout) help condition" }
	}


# test help core-file
send "help core-file\n"
expect {
	-re "Use FILE as core dump for examining memory and registers..*
No arg means have no core file.  This command has been superseded by the.*
`target core' and `detach' commands..*$prompt $"\
			{ pass "help core-file" }
	-re "$prompt $"	{ fail "help core-file" }
	timeout		{ fail "(timeout) help core-file" }
	}


# test help delete "d" abbreviation
send "help d\n"
expect {
	-re "Delete some breakpoints or auto-display expressions..*
Arguments are breakpoint numbers with spaces in between..*
To delete all breakpoints, give no argument..*
Also a prefix command for deletion of other GDB objects..*
The \"unset\" command is also an alias for \"delete\"..*
List of delete subcommands:.*
delete display -- Cancel some expressions to be displayed when program stops.*
delete breakpoints -- Delete some breakpoints or auto-display expressions.*
Type \"help delete\" followed by delete subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help delete \"d\" abbreviation" }
	-re "$prompt $"	{ fail "help delete \"d\" abbreviation" }
	timeout		{ fail "(timeout) help delete \"d\" abbreviation" }
	}


# test help delete
send "help delete\n"
expect {
	-re "Delete some breakpoints or auto-display expressions..*
Arguments are breakpoint numbers with spaces in between..*
To delete all breakpoints, give no argument..*
Also a prefix command for deletion of other GDB objects..*
The \"unset\" command is also an alias for \"delete\"..*
List of delete subcommands:.*
delete display -- Cancel some expressions to be displayed when program stops.*
delete breakpoints -- Delete some breakpoints or auto-display expressions.*
Type \"help delete\" followed by delete subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help delete" }
	-re "$prompt $"	{ fail "help delete" }
	timeout		{ fail "(timeout) help delete" }
	}


# test help data
send "help data\n"
expect {
	-re ".*
Examining data..*
List of commands:.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help data" }
	-re "$prompt $"	{ fail "help data" }
	timeout		{ fail "(timeout) help data" }
	}


# test help define
send "help define\n"
expect {
	-re "Define a new command.*$prompt $"\
			{ pass "help define" }
	-re "$prompt $"	{ fail "help define" }
	timeout		{ fail "(timeout) help define" }
	}


# test help delete breakpoints
send "help delete breakpoints\n"
expect {
	-re "Delete some breakpoints or auto-display expressions..*
Arguments are breakpoint numbers with spaces in between..*
To delete all breakpoints, give no argument..*
This command may be abbreviated \"delete\"..*$prompt $"\
			{ pass "help delete breakpoints" }
	-re "$prompt $"	{ fail "help delete breakpoints" }
	timeout		{ fail "(timeout) help delete breakpoints" }
	}


# test help delete display
send "help delete display\n"
expect {
	-re "Cancel some expressions to be displayed when program stops..*
Arguments are the code numbers of the expressions to stop displaying..*
No argument means cancel all automatic-display expressions..*
Do \"info display\" to see current list of code numbers..*$prompt $"\
			{ pass "help delete display" }
	-re "$prompt $"	{ fail "help delete display" }
	timeout		{ fail "(timeout) help delete display" }
	}


# test help detach
send "help detach\n"
expect {
	-re "Detach a process or file previously attached..*
If a process, it is no longer traced, and it continues its execution.  If you.*
were debugging a file, the file is closed and gdb no longer accesses it..*$prompt $"\
			{ pass "help detach" }
	-re "$prompt $"	{ fail "help detach" }
	timeout		{ fail "(timeout) help detach" }
	}


# test help directory
send "help directory\n"
expect {
	-re "Add directory DIR to beginning of search path for source files..*
Forget cached info on source file locations and line positions..*
DIR can also be .cwd for the current working directory, or .cdir for the.*
directory in which the source file was compiled into object code..*
With no argument, reset the search path to .cdir:.cwd, the default..*$prompt $"\
			{ pass "help directory" }
	-re "$prompt $"	{ fail "help directory" }
	timeout		{ fail "(timeout) help directory" }
	}


# test help disable "dis" abbreviation
send "help dis\n"
expect {
	-re "Disable some breakpoints..*
Arguments are breakpoint numbers with spaces in between..*
To disable all breakpoints, give no argument..*
A disabled breakpoint is not forgotten, but has no effect until reenabled..*
List of disable subcommands:.*
disable display -- Disable some expressions to be displayed when program stops.*
disable breakpoints -- Disable some breakpoints.*
Type \"help disable\" followed by disable subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help disable \"dis\" abbreviation" }
	-re "$prompt $"	{ fail "help disable \"dis\" abbreviation" }
	timeout		{ fail "(timeout) help disable \"dis\" abbreviation" }
	}


# test help disable "disa" abbreviation
send "help disa\n"
expect {
	-re "Disable some breakpoints..*
Arguments are breakpoint numbers with spaces in between..*
To disable all breakpoints, give no argument..*
A disabled breakpoint is not forgotten, but has no effect until reenabled..*
List of disable subcommands:.*
disable display -- Disable some expressions to be displayed when program stops.*
disable breakpoints -- Disable some breakpoints.*
Type \"help disable\" followed by disable subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help disable \"disa\" abbreviation" }
	-re "$prompt $"	{ fail "help disable \"disa\" abbreviation" }
	timeout		{ fail "(timeout) help disable \"disa\" abbreviation" }
	}


# test help disable
send "help disable\n"
expect {
	-re "Disable some breakpoints..*
Arguments are breakpoint numbers with spaces in between..*
To disable all breakpoints, give no argument..*
A disabled breakpoint is not forgotten, but has no effect until reenabled..*
List of disable subcommands:.*
disable display -- Disable some expressions to be displayed when program stops.*
disable breakpoints -- Disable some breakpoints.*
Type \"help disable\" followed by disable subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help disable" }
	-re "$prompt $"	{ fail "help disable" }
	timeout		{ fail "(timeout) help disable" }
	}


# test help disable breakpoints
send "help disable breakpoints\n"
expect {
	-re "Disable some breakpoints..*
Arguments are breakpoint numbers with spaces in between..*
To disable all breakpoints, give no argument..*
A disabled breakpoint is not forgotten, but has no effect until reenabled..*
This command may be abbreviated \"disable\"..*$prompt $"\
			{ pass "help disable breakpoints" }
	-re "$prompt $"	{ fail "help disable breakpoints" }
	timeout		{ fail "(timeout) help disable breakpoints" }
	}


# test help disable display
send "help disable display\n"
expect {
	-re "Disable some expressions to be displayed when program stops..*
Arguments are the code numbers of the expressions to stop displaying..*
No argument means disable all automatic-display expressions..*
Do \"info display\" to see current list of code numbers..*$prompt $"\
			{ pass "help disable display" }
	-re "$prompt $"	{ fail "help disable display" }
	timeout		{ fail "(timeout) help disable display" }
	}


# test help disassemble
send "help disassemble\n"
expect {
	-re "Disassemble a specified section of memory..*
Default is the function surrounding the pc of the selected frame..*
With a single argument, the function surrounding that address is dumped..*
Two arguments are taken as a range of memory to dump..*$prompt $"\
			{ pass "help disassemble" }
	-re "$prompt $"	{ fail "help disassemble" }
	timeout		{ fail "(timeout) help disassemble" }
	}


# test help display
send "help display\n"
expect {
	-re "Print value of expression EXP each time the program stops..*
/FMT may be used before EXP as in the \"print\" command..*
/FMT \"i\" or \"s\" or including a size-letter is allowed,.*
as in the \"x\" command, and then EXP is used to get the address to examine.*
and examining is done as in the \"x\" command..*
With no argument, display all currently requested auto-display expressions..*
Use \"undisplay\" to cancel display requests previously made..*$prompt $"\
			{ pass "help display" }
	-re "$prompt $"	{ fail "help display" }
	timeout		{ fail "(timeout) help display" }
	}


# test help do
send "help do\n"
expect {
	-re "Select and print stack frame called by this one..*
An argument says how many frames down to go..*$prompt $"\
			{ pass "help do" }
	-re "$prompt $"	{ fail "help do" }
	timeout		{ fail "(timeout) help do" }
	}


# test help document
send "help document\n"
expect {
	-re "Document a user-defined command..*
Give command name as argument.  Give documentation on following lines..*
End with a line of just \"end\"..*$prompt $"\
			{ pass "help document" }
	-re "$prompt $"	{ fail "help document" }
	timeout		{ fail "(timeout) help document" }
	}



# test help down
send "help down\n"
expect {
	-re "Select and print stack frame called by this one..*
An argument says how many frames down to go..*$prompt $"\
			{ pass "help down" }
	-re "$prompt $"	{ fail "help down" }
	timeout		{ fail "(timeout) help down" }
	}


# test help down-silently
send "help down-silently\n"
expect {
	-re "Same as the `down' command, but does not print anything..*
This is useful in command scripts..*$prompt $"\
			{ pass "help down-silently" }
	-re "$prompt $"	{ fail "help down-silently" }
	timeout		{ fail "(timeout) help down-silently" }
	}


# this command was removed from GDB 4.5.8
# test help dump-me
#send "help dump-me\n"
#expect {
#	-re "Get fatal error; make debugger dump its core..*$prompt $"\
#			{ pass "help dump-me" }
#	-re "$prompt $"	{ fail "help dump-me" }
#	timeout		{ fail "(timeout) help dump-me" }
#	}

# test help echo
send "help echo\n"
expect {
	-re "Print a constant string.  Give string as argument..*
C escape sequences may be used in the argument..*
No newline is added at the end of the argument;.*
use \".n\" if you want a newline to be printed..*
Since leading and trailing whitespace are ignored in command arguments,.*
if you want to print some you must use \".\" before leading whitespace.*
to be printed or after trailing whitespace..*$prompt $"\
			{ pass "help echo" }
	-re "$prompt $"	{ fail "help echo" }
	timeout		{ fail "(timeout) help echo" }
	}


# test help enable breakpoints delete
send "help enable breakpoints delete\n"
expect {
	-re "Enable breakpoints and delete when hit.  Give breakpoint numbers..*
If a breakpoint is hit while enabled in this fashion, it is deleted..*$prompt $"\
			{ pass "help enable breakpoints delete" }
	-re "$prompt $"	{ fail "help enable breakpoints delete" }
	timeout		{ fail "(timeout) help enable breakpoints delete" }
	}


# test help enable breakpoints once
send "help enable breakpoints once\n"
expect {
	-re "Enable breakpoints for one hit..*$prompt $"\
			{ pass "help enable breakpoints once" }
	-re "$prompt $"	{ fail "help enable breakpoints once" }
	timeout		{ fail "(timeout) help enable breakpoints once" }
	}


# test help enable breakpoints
send "help enable breakpoints\n"
expect {
	-re "Enable some breakpoints..*
Give breakpoint numbers .separated by spaces. as arguments..*
This is used to cancel the effect of the \"disable\" command..*
May be abbreviated to simply \"enable\"..*.*
List of enable breakpoints subcommands:.*
enable breakpoints delete -- Enable breakpoints and delete when hit.*
enable breakpoints once -- Enable breakpoints for one hit.*
Type \"help enable breakpoints\" followed by enable breakpoints subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help enable breakpoints" }
	-re "$prompt $"	{ fail "help enable breakpoints" }
	timeout		{ fail "(timeout) help enable breakpoints" }
	}


# test help enable delete
send "help enable delete\n"
expect {
	-re "Enable breakpoints and delete when hit.  Give breakpoint numbers..*
If a breakpoint is hit while enabled in this fashion, it is deleted..*$prompt $"\
			{ pass "help enable delete" }
	-re "$prompt $"	{ fail "help enable delete" }
	timeout		{ fail "(timeout) help enable delete" }
	}


# test help enable display
send "help enable display\n"
expect {
	-re "Enable some expressions to be displayed when program stops..*
Arguments are the code numbers of the expressions to resume displaying..*
No argument means enable all automatic-display expressions..*
Do \"info display\" to see current list of code numbers..*$prompt $"\
			{ pass "help enable display" }
	-re "$prompt $"	{ fail "help enable display" }
	timeout		{ fail "(timeout) help enable display" }
	}


# test help enable once
send "help enable once\n"
expect {
	-re "Enable breakpoints for one hit.*$prompt $"\
			{ pass "help enable once" }
	-re "$prompt $"	{ fail "help enable once" }
	timeout		{ fail "(timeout) help enable once" }
	}


# test help enable
send "help enable\n"
expect {
	-re "Enable some breakpoints..*
Give breakpoint numbers .separated by spaces. as arguments..*
With no subcommand, breakpoints are enabled until you command otherwise..*
This is used to cancel the effect of the \"disable\" command..*
With a subcommand you can enable temporarily..*
List of enable subcommands:.*
enable display -- Enable some expressions to be displayed when program stops.*
enable once -- Enable breakpoints for one hit.*
enable delete -- Enable breakpoints and delete when hit.*
Type \"help enable\" followed by enable subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help enable" }
	-re "$prompt $"	{ fail "help enable" }
	timeout		{ fail "(timeout) help enable" }
	}


# test help exec-file
send "help exec-file\n"
expect {
	-re "Use FILE as program for getting contents of pure memory..*
If FILE cannot be found as specified, your execution directory path.*
is searched for a command of that name..*
No arg means have no executable file..*$prompt $"\
			{ pass "help exec-file" }
	-re "$prompt $"	{ fail "help exec-file" }
	timeout		{ fail "(timeout) help exec-file" }
	}


# test help frame "f" abbreviation
send "help f\n"
expect {
	-re "Select and print a stack frame..*
With no argument, print the selected stack frame.  .See also \"info frame\".*
An argument specifies the frame to select..*
It can be a stack frame number or the address of the frame..*
With argument, nothing is printed if input is coming from.*
a command file or a user-defined command..*$prompt $"\
			{ pass "help frame \"f\" abbreviation" }
	-re "$prompt $"	{ fail "help frame \"f\" abbreviation" }
	timeout		{ fail "(timeout) help frame \"f\" abbreviation" }
	}


# test help frame
send "help frame\n"
expect {
	-re "Select and print a stack frame..*
With no argument, print the selected stack frame.  .See also \"info frame\"...*
An argument specifies the frame to select..*
It can be a stack frame number or the address of the frame..*
With argument, nothing is printed if input is coming from.*
a command file or a user-defined command..*$prompt $"\
			{ pass "help frame" }
	-re "$prompt $"	{ fail "help frame" }
	timeout		{ fail "(timeout) help frame" }
	}


# test help fg
send "help fg\n"
expect {
	-re "Continue program being debugged.*$prompt $"\
			{ pass "help fg" }
	-re "$prompt $"	{ fail "help fg" }
	timeout		{ fail "(timeout) help fg" }
	}


# test help file
send "help file\n"
expect {
	-re "Use FILE as program to be debugged..*
It is read for its symbols, for getting the contents of pure memory,.*
and it is the program executed when you use the `run' command..*
If FILE cannot be found as specified, your execution directory path.*
..PATH. is searched for a command of that name..*
No arg means to have no executable file and no symbols..*$prompt $"\
			{ pass "help file" }
	-re "$prompt $"	{ fail "help file" }
	timeout		{ fail "(timeout) help file" }
	}


# test help files
send "help files\n"
expect {
	-re "Specifying.*$prompt $"  { pass "help files" }
	-re "$prompt $"	{ fail "help files" }
	timeout		{ fail "(timeout) help files" }
	}


# test help finish
send "help finish\n"
expect {
	-re "Execute until selected stack frame returns..*
Upon return, the value returned is printed and put in the value history..*$prompt $"\
			{ pass "help finish" }
	-re "$prompt $"	{ fail "help finish" }
	timeout		{ fail "(timeout) help finish" }
	}


# test help forward-search
send "help forward-search\n"
expect {
	-re "Search for regular expression .see regex.3.. from last line listed..*$prompt $"\
			{ pass "help forward-search" }
	-re "$prompt $"	{ fail "help forward-search" }
	timeout		{ fail "(timeout) help forward-search" }
	}


# test help help "h" abbreviation 
send "help h\n"
expect {
	-re "Print list of commands..*$prompt $"\
			{ pass "help help \"h\" abbreviation" }
	-re "$prompt $"	{ fail "help help \"h\" abbreviation" }
	timeout		{ fail "(timeout) help help \"h\" abbreviation" }
	}


# test help help
send "help help\n"
expect {
	-re "Print list of commands..*$prompt $"\
			{ pass "help help" }
	-re "$prompt $"	{ fail "help help" }
	timeout		{ fail "(timeout) help help" }
	}


# test help handle
send "help handle\n"
expect {
	-re "Specify how to handle a signal..*$prompt $"\
			{ pass "help handle" }
	-re "$prompt $"	{ fail "help handle" }
	timeout		{ fail "(timeout) help handle" }
	}


# test help info "i" abbreviation
send "help i\n"
expect {
	-re "Generic command for showing things about the program being debugged..*
List of info subcommands:.*
Type \"help info\" followed by info subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help info \"i\" abbreviation" }
	-re "$prompt $"	{ fail "help info \"i\" abbreviation" }
	timeout		{ fail "(timeout) help info \"i\" abbreviation" }
	}


# test help info
send "help info\n"
expect {
	-re "Generic command for showing things about the program being debugged..*
List of info subcommands:.*
Type \"help info\" followed by info subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help info" }
	-re "$prompt $"	{ fail "help info" }
	timeout		{ fail "(timeout) help info" }
	}


# test help ignore
send "help ignore\n"
expect {
	-re "Set ignore-count of breakpoint number N to COUNT..*
Usage is `ignore N COUNT'..*$prompt $"\
			{ pass "help ignore" }
	-re "$prompt $"	{ fail "help ignore" }
	timeout		{ fail "(timeout) help ignore" }
	}


# test help info address
send "help info address\n"
expect {
	-re "Describe where variable VAR is stored..*$prompt $"\
			{ pass "help info address" }
	-re "$prompt $"	{ fail "help info address" }
	timeout		{ fail "(timeout) help info address" }
	}


# test help info all-registers
send "help info all-registers\n"
expect {
	-re "List of all registers and their contents, for selected stack frame..*
Register name as argument means describe only that register..*$prompt $"\
			{ pass "help info all-registers" }
	-re "$prompt $"	{ fail "help info all-registers" }
	timeout		{ fail "(timeout) help info all-registers" }
	}


# test help info args
send "help info args\n"
expect {
	-re "Argument variables of current stack frame..*$prompt $"\
			{ pass "help info args" }
	-re "$prompt $"	{ fail "help info args" }
	timeout		{ fail "(timeout) help info args" }
	}


# test help info breakpoints
send "help info breakpoints\n"
expect {
	-re "Status of user-settable breakpoints, or breakpoint number NUMBER..*
breakpoint set..*$prompt $"\
			{ pass "help info breakpoints" }
	-re "$prompt $"	{ fail "help info breakpoints" }
	timeout		{ fail "(timeout) help info breakpoints" }
	}


# test help info catch
send "help info catch\n"
expect {
	-re "Exceptions that can be caught in the current stack frame..*$prompt $"\
			{ pass "help info catch" }
	-re "$prompt $"	{ fail "help info catch" }
	timeout		{ fail "(timeout) help info catch" }
	}


# test help info copying
send "help info copying\n"
expect {
	-re "Conditions for redistributing copies of GDB..*$prompt $"\
			{ pass "help info copying" }
	-re "$prompt $"	{ fail "help info copying" }
	timeout		{ fail "(timeout) help info copying" }
	}


# test help info display
send "help info display\n"
expect {
	-re "Expressions to display when program stops, with code numbers..*$prompt $"\
			{ pass "help info display" }
	-re "$prompt $"	{ fail "help info display" }
	timeout		{ fail "(timeout) help info display" }
	}


# test help info frame "f" abbreviation
send "help info f\n"
expect {
	-re "All about selected stack frame, or frame at ADDR..*$prompt $"\
			{ pass "help info frame \"f\" abbreviation" }
	-re "$prompt $"	{ fail "help info frame \"f\" abbreviation" }
	timeout		{ fail "(timeout) help info frame \"f\" abbreviation" }
	}


# test help info frame
send "help info frame\n"
expect {
	-re "All about selected stack frame, or frame at ADDR..*$prompt $"\
			{ pass "help info frame" }
	-re "$prompt $"	{ fail "help info frame" }
	timeout		{ fail "(timeout) help info frame" }
	}


# test help info files
send "help info files\n"
expect {
	-re "Names of targets and files being debugged..*
Shows the entire stack of targets currently in use .including the exec-file,.*
core-file, and process, if any., as well as the symbol file name..*$prompt $"\
			{ pass "help info files" }
	-re "$prompt $"	{ fail "help info files" }
	timeout		{ fail "(timeout) help info files" }
	}


# test help info float
send "help info float\n"
expect {
	-re "Print the status of the floating point unit.*$prompt $"\
			{ pass "help info float" }
	-re "$prompt $"	{ fail "help info float" }
	timeout		{ fail "(timeout) help info float" }
	}


# test help info functions
send "help info functions\n"
expect {
	-re "All function names, or those matching REGEXP..*$prompt $"\
			{ pass "help info functions" }
	-re "$prompt $"	{ fail "help info functions" }
	timeout		{ fail "(timeout) help info functions" }
	}


# test help info line
send "help info line\n"
expect {
	-re "Core addresses of the code for a source line..*
Line can be specified as.*
  LINENUM, to list around that line in current file,.*
  FILE:LINENUM, to list around that line in that file,.*
  FUNCTION, to list around beginning of that function,.*
  FILE:FUNCTION, to distinguish among like-named static functions..*
Default is to describe the last source line that was listed..*
This sets the default address for \"x\" to the line's first instruction.*
so that \"x.i\" suffices to start examining the machine code..*
The address is also stored as the value of \"._\"..*$prompt $"\
			{ pass "help info line" }
	-re "$prompt $"	{ fail "help info line" }
	timeout		{ fail "(timeout) help info line" }
	}


# test help info locals
send "help info locals\n"
expect {
	-re "Local variables of current stack frame..*$prompt $"\
			{ pass "help info locals" }
	-re "$prompt $"	{ fail "help info locals" }
	timeout		{ fail "(timeout) help info locals" }
	}


# test help info program
send "help info program\n"
expect {
	-re "Execution status of the program..*$prompt $"\
			{ pass "help info program" }
	-re "$prompt $"	{ fail "help info program" }
	timeout		{ fail "(timeout) help info program" }
	}


# test help info registers
send "help info registers\n"
expect {
	-re "List of integer registers and their contents, for selected stack frame..*
Register name as argument means describe only that register..*$prompt $"\
			{ pass "help info registers" }
	-re "$prompt $"	{ fail "help info registers" }
	timeout		{ fail "(timeout) help info registers" }
	}


# test help info stack "s" abbreviation
send "help info s\n"
expect {
	-re "Backtrace of the stack, or innermost COUNT frames..*$prompt $"\
			{ pass "help info stack \"s\" abbreviation" }
	-re "$prompt $"	{ fail "help info stack \"s\" abbreviation" }
	timeout		{ fail "(timeout) help info stack \"s\" abbreviation" }
	}


# test help info stack
send "help info stack\n"
expect {
	-re "Backtrace of the stack, or innermost COUNT frames..*$prompt $"\
			{ pass "help info stack" }
	-re "$prompt $"	{ fail "help info stack" }
	timeout		{ fail "(timeout) help info stack" }
	}


# test help info set
send "help info set\n"
expect {
	-re "Show all GDB settings..*$prompt $"\
			{ pass "help info set" }
	-re "$prompt $"	{ fail "help info set" }
	timeout		{ fail "(timeout) help info set" }
	}


# test help info signals
send "help info signals\n"
expect {
	-re "What debugger does when program gets various signals.*$prompt $"\
			{ pass "help info signals" }
	-re "$prompt $"	{ fail "help info signals" }
	timeout		{ fail "(timeout) help info signals" }
	}


# test help info source
send "help info source\n"
expect {
	-re "Information about the current source file..*$prompt $"\
			{ pass "help info source" }
	-re "$prompt $"	{ fail "help info source" }
	timeout		{ fail "(timeout) help aliases" }
	}


# test help info sources
send "help info sources\n"
expect {
	-re "Source files in the program..*$prompt $"\
			{ pass "help info sources" }
	-re "$prompt $"	{ fail "help info sources" }
	timeout		{ fail "(timeout) help info sources" }
	}


# test help info target
send "help info target\n"
expect {
	-re "Names of targets and files being debugged..*
Shows the entire stack of targets currently in use .including the exec-file,.*
core-file, and process, if any., as well as the symbol file name..*$prompt $"\
			{ pass "help info target" }
	-re "$prompt $"	{ fail "help info target" }
	timeout		{ fail "(timeout) help info target" }
	}


# test help info terminal
send "help info terminal\n"
expect {
	-re "Print inferior's saved terminal status..*$prompt $"\
			{ pass "help info terminal" }
	-re "$prompt $"	{ fail "help info terminal" }
	timeout		{ fail "(timeout) help info terminal" }
	}


# test help info types
send "help info types\n"
expect {
	-re "All type names, or those matching REGEXP..*$prompt $"\
			{ pass "help info types" }
	-re "$prompt $"	{ fail "help info types" }
	timeout		{ fail "(timeout) help info types" }
	}


# test help info variables
send "help info variables\n"
expect {
	-re "All global and static variable names, or those matching REGEXP..*$prompt $"\
			{ pass "help info variables" }
	-re "$prompt $"	{ fail "help info variables" }
	timeout		{ fail "(timeout) help info variables" }
	}


# test help info warranty
send "help info warranty\n"
expect {
	-re "Various kinds of warranty you do not have..*$prompt $"\
			{ pass "help info warranty" }
	-re "$prompt $"	{ fail "help info warranty" }
	timeout		{ fail "(timeout) help info warranty" }
	}


# test help info watchpoints
send "help info watchpoints\n"
expect {
	-re "Synonym for ``info breakpoints''..*$prompt $"\
			{ pass "help info watchpoints" }
	-re "$prompt $"	{ fail "help info watchpoints" }
	timeout		{ fail "(timeout) help info watchpoints" }
	}


# test help inspect
send "help inspect\n"
expect {
	-re "Same as \"print\" command, except that if you are running in the epoch.*
environment, the value is printed in its own window..*$prompt $"\
			{ pass "help inspect" }
	-re "$prompt $"	{ fail "help inspect" }
	timeout		{ fail "(timeout) help inspect" }
	}


# test help jump
send "help jump\n"
expect {
	-re "Continue program being debugged at specified line or address..*
Give as argument either LINENUM or \[*\]+ADDR, where ADDR is an expression.*
for an address to start at..*$prompt $"\
			{ pass "help jump" }
	-re "$prompt $"	{ fail "help jump" }
	timeout		{ fail "(timeout) help jump" }
	}


# test help kill
send "help kill\n"
expect {
	-re "Kill execution of program being debugged..*$prompt $"\
			{ pass "help kill" }
	-re "$prompt $"	{ fail "help kill" }
	timeout		{ fail "(timeout) help kill" }
	}


# test help list "l" abbreviation
send "help l\n"
expect {
	-re "List specified function or line..*
With no argument, lists ten more lines after or around previous listing..*
\"list -\" lists the ten lines before a previous ten-line listing..*
One argument specifies a line, and ten lines are listed around that line..*
Two arguments with comma between specify starting and ending lines to list..*
Lines can be specified in these ways:.*
  LINENUM, to list around that line in current file,.*
  FILE:LINENUM, to list around that line in that file,.*
  FUNCTION, to list around beginning of that function,.*
  FILE:FUNCTION, to distinguish among like-named static functions..*
  \[*\]+ADDRESS, to list around the line containing that address..*
With two args if one is empty it stands for ten lines away from the other arg..*$prompt $"\
			{ pass "help list \"l\" abbreviation" }
	-re "$prompt $"	{ fail "help list \"l\" abbreviation" }
	timeout		{ fail "(timeout) help list \"l\" abbreviation" }
	}


# test help list
send "help list\n"
expect {
	-re "List specified function or line..*
With no argument, lists ten more lines after or around previous listing..*
\"list -\" lists the ten lines before a previous ten-line listing..*
One argument specifies a line, and ten lines are listed around that line..*
Two arguments with comma between specify starting and ending lines to list..*
Lines can be specified in these ways:.*
  LINENUM, to list around that line in current file,.*
  FILE:LINENUM, to list around that line in that file,.*
  FUNCTION, to list around beginning of that function,.*
  FILE:FUNCTION, to distinguish among like-named static functions..*
  \[*\]+ADDRESS, to list around the line containing that address..*
With two args if one is empty it stands for ten lines away from the other arg..*$prompt $"\
			{ pass "help list" }
	-re "$prompt $"	{ fail "help list" }
	timeout		{ fail "(timeout) help list" }
	}


# test help load
send "help load\n"
expect {
	-re "Dynamically load FILE into the running program, and record its symbols.*
for access from GDB..*$prompt $"\
			{ pass "help load" }
	-re "$prompt $"	{ fail "help load" }
	timeout		{ fail "(timeout) help load" }
	}


# test help make
send "help make\n"
expect {
	-re "Run the ``make'' program using the rest of the line as arguments..*$prompt $"\
			{ pass "help make" }
	-re "$prompt $"	{ fail "help make" }
	timeout		{ fail "(timeout) help make" }
	}


# test help next "n" abbreviation
send "help n\n"
expect {
	-re "Step program, proceeding through subroutine calls..*
Like the \"step\" command as long as subroutine calls do not happen;.*
when they do, the call is treated as one instruction..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help next \"n\" abbreviation" }
	-re "$prompt $"	{ fail "help next \"n\" abbreviation" }
	timeout		{ fail "(timeout) help next \"n\" abbreviation" }
	}


# test help next
send "help next\n"
expect {
	-re "Step program, proceeding through subroutine calls..*
Like the \"step\" command as long as subroutine calls do not happen;.*
when they do, the call is treated as one instruction..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help next" }
	-re "$prompt $"	{ fail "help next" }
	timeout		{ fail "(timeout) help next" }
	}


# test help nexti
send "help ni\n"
expect {
	-re "Step one instruction, but proceed through subroutine calls..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help nexti" }
	-re "$prompt $"	{ fail "help nexti" }
	timeout		{ fail "(timeout) help nexti" }
	}


# all the commands that used to be here are now in "maintainance" instead
# test help obscure
send "help obscure\n"
expect {
	-re "Obscure features..*
List of commands:.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help obscure" }
	-re "$prompt $"	{ fail "help obscure" }
	timeout		{ fail "(timeout) help obscure" }
	}


# test help output
send "help output\n"
expect {
	-re "Like \"print\" but don't put in value history and don't print newline..*
This is useful in user-defined commands..*$prompt $"\
			{ pass "help output" }
	-re "$prompt $"	{ fail "help output" }
	timeout		{ fail "(timeout) help output" }
	}


# test help print "p" abbreviation
send "help p\n"
expect {
	-re "Print value of expression EXP..*
Variables accessible are those of the lexical environment of the selected.*
EXP may be preceded with /FMT, where FMT is a format letter.*
but no count or size letter .see \"x\" command...*$prompt $"\
			{ pass "help print \"p\" abbreviation" }
	-re "$prompt $"	{ fail "help print \"p\" abbreviation" }
	timeout		{ fail "(timeout) help print \"p\" abbreviation" }
	}


# test help print
send "help print\n"
expect {
	-re "Print value of expression EXP..*
Variables accessible are those of the lexical environment of the selected.*
EXP may be preceded with /FMT, where FMT is a format letter.*
but no count or size letter .see \"x\" command...*$prompt $"\
			{ pass "help print" }
	-re "$prompt $"	{ fail "help print" }
	timeout		{ fail "(timeout) help print" }
	}


# test help path
send "help path\n"
expect {
	-re "Add directory DIR.s. to beginning of search path for object files..*
.cwd in the path means the current working directory..*
This path is equivalent to the .PATH shell variable.  It is a list of.*
directories, separated by colons.  These directories are searched to find.*
fully linked executable files and separately compiled object files as needed..*$prompt $"\
			{ pass "help path" }
	-re "$prompt $"	{ fail "help path" }
	timeout		{ fail "(timeout) help path" }
	}


# test help printcmds
send "help printcmds\n"
expect {
	-re "Undefined command: \"printcmds\".  Try \"help\"..*$prompt $"\
			{ pass "help printcmds" }
	-re "$prompt $"	{ fail "help printcmds" }
	timeout		{ fail "(timeout) help printcmds" }
	}


# test help printf
send "help printf\n"
expect {
	-re "printf \"printf format string\", arg1, arg2, arg3, ..., argn.*
This is useful for formatted output in user-defined commands..*$prompt $"\
			{ pass "help printf" }
	-re "$prompt $"	{ fail "help printf" }
	timeout		{ fail "(timeout) help printf" }
	}


# this command doesn't exist in GDB 4.5.8
# test help printsyms
#send "help printsyms\n"
#expect {
#	-re "Print dump of current symbol definitions to file OUTFILE..*
#If a SOURCE file is specified, dump only that file's symbols..*$prompt $"\
#			{ pass "help printsyms" }
#	-re "$prompt $"	{ fail "help printsyms" }
#	timeout		{ fail "(timeout) help printsyms" }
#	}

# test help ptype
send "help ptype\n"
expect {
	-re "Print definition of type.*$prompt $"\
			{ pass "help ptype" }
	-re "$prompt $"	{ fail "help ptype" }
	timeout		{ fail "(timeout) help ptype" }
	}


# test help pwd
send "help pwd\n"
expect {
	-re "Print working directory.  This is used for your program as well..*$prompt $"\
			{ pass "help pwd" }
	-re "$prompt $"	{ fail "help pwd" }
	timeout		{ fail "(timeout) help pwd" }
	}


# test help quit "q" abbreviation
send "help q\n"
expect {
	-re "Exit gdb..*$prompt $"\
			{ pass "help quit \"q\" abbreviation" }
	-re "$prompt $"	{ fail "help quit \"q\" abbreviation" }
	timeout		{ fail "(timeout) help quit \"q\" abbreviation" }
	}


# test help quit
send "help quit\n"
expect {
	-re "Exit gdb..*$prompt $"\
			{ pass "help quit" }
	-re "$prompt $"	{ fail "help quit" }
	timeout		{ fail "(timeout) help quit" }
	}


# test help run "r" abbreviation
send "help r\n"
expect {
	-re "Start debugged program.  You may specify arguments to give it..*
Args may include .*, or .*; they are expanded using \"sh\"..*
Input and output redirection with \".\", \".\", or \"..\" are also allowed..*
With no arguments, uses arguments last specified .with \"run\" or \"set args\"...*
To cancel previous arguments and run with no arguments,.*
use \"set args\" without arguments..*$prompt $"\
			{ pass "help run \"r\" abbreviation" }
	-re "$prompt $"	{ fail "help run \"r\" abbreviation" }
	timeout		{ fail "(timeout) help run \"r\" abbreviation" }
	}


# test help run
send "help run\n"
expect {
	-re "Start debugged program.  You may specify arguments to give it..*
Args may include .*, or .*; they are expanded using \"sh\"..*
Input and output redirection with \".\", \".\", or \"..\" are also allowed..*
With no arguments, uses arguments last specified .with \"run\" or \"set args\"...*
To cancel previous arguments and run with no arguments,.*
use \"set args\" without arguments..*$prompt $"\
			{ pass "help run" }
	-re "$prompt $"	{ fail "help run" }
	timeout		{ fail "(timeout) help run" }
	}


# test help rbreak
send "help rbreak\n"
expect {
	-re "Set a breakpoint for all functions matching REGEXP..*$prompt $"\
			{ pass "help rbreak" }
	-re "$prompt $"	{ fail "help rbreak" }
	timeout		{ fail "(timeout) help rbreak" }
	}


# test help return
send "help return\n"
expect {
	-re "Make selected stack frame return to its caller..*
Control remains in the debugger, but when you continue.*
execution will resume in the frame above the one now selected..*
If an argument is given, it is an expression for the value to return..*$prompt $"\
			{ pass "help return" }
	-re "$prompt $"	{ fail "help return" }
	timeout		{ fail "(timeout) help return" }
	}


# test help reverse-search
send "help reverse-search\n"
expect {
	-re "Search backward for regular expression .see regex.3.. from last line listed..*$prompt $"\
			{ pass "help reverse-search" }
	-re "$prompt $"	{ fail "help reverse-search" }
	timeout		{ fail "(timeout) help reverse-search" }
	}


# test help running
send "help running\n"
expect {
	-re "Running the program..*
List of commands:.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help running" }
	-re "$prompt $"	{ fail "help running" }
	timeout		{ fail "(timeout) help running" }
	}


# test help step "s" abbreviation
send "help s\n"
expect {
	-re "Step program until it reaches a different source line..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help step \"s\" abbreviation" }
	-re "$prompt $"	{ fail "help step \"s\" abbreviation" }
	timeout		{ fail "(timeout) help step \"s\" abbreviation" }
	}


# test help step
send "help step\n"
expect {
	-re "Step program until it reaches a different source line..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help step" }
	-re "$prompt $"	{ fail "help step" }
	timeout		{ fail "(timeout) help step" }
	}


# test help search
send "help search\n"
expect {
	-re "Search for regular expression .see regex.3.. from last line listed..*$prompt $"\
			{ pass "help search" }
	-re "$prompt $"	{ fail "help search" }
	timeout		{ fail "(timeout) help search" }
	}


# test help section
send "help section\n"
expect {
	-re "Change the base address of section SECTION of the exec file to ADDR..*
This can be used if the exec file does not contain section addresses,.*
.such as in the a.out format., or when the addresses specified in the.*
file itself are wrong.  Each section must be changed separately.  The.*
``info files'' command lists all the sections and their addresses..*$prompt $"\
			{ pass "help section" }
	-re "$prompt $"	{ fail "help section" }
	timeout		{ fail "(timeout) help section" }
	}


#test help set annotate
send "help set annotate\n"
expect {
	-re "Set annotation_level.*
0 == normal;     1 == fullname \\(for use when running under emacs\\).*
2 == output annotated suitably for use by programs that control GDB..*$prompt $"\
			{ pass "help set annotate" }
	-re "$prompt $"	{ fail "help set annotate" }
	timeout		{ fail "(timeout) help set annotate" }
	}


# test help set args
send "help set args\n"
expect {
	-re "Set arguments to give program being debugged when it is started..*
Follow this command with any number of args, to be passed to the program..*$prompt $"\
			{ pass "help set args" }
	-re "$prompt $"	{ fail "help set args" }
	timeout		{ fail "(timeout) help set args" }
	}


# test help set check "c" abbreviation
send "help set c\n"
expect {
	-re "Set the status of the type/range checker.*
List of set check subcommands:.*
set check range -- Set range checking.*
set check type -- Set type checking.*
Type \"help set check\" followed by set check subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set check \"c\" abbreviation" }
	-re "$prompt $"	{ fail "help set check \"c\" abbreviation" }
	timeout		{ fail "(timeout) help set check \"c\" abbreviation" }
	}


# test help set check "ch" abbreviation
send "help set ch\n"
expect {
	-re "Set the status of the type/range checker.*
List of set check subcommands:.*
set check range -- Set range checking.*
set check type -- Set type checking.*
Type \"help set check\" followed by set check subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set check \"ch\" abbreviation" }
	-re "$prompt $"	{ fail "help set check \"ch\" abbreviation" }
	timeout		{ fail "(timeout) help set check \"ch\" abbreviation" }
	}


# test help set check
send "help set check\n"
expect {
	-re "Set the status of the type/range checker.*
List of set check subcommands:.*
set check range -- Set range checking.*
set check type -- Set type checking.*
Type \"help set check\" followed by set check subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set check" }
	-re "$prompt $"	{ fail "help set check" }
	timeout		{ fail "(timeout) help set check" }
	}


# test help set check range
send "help set check range\n"
expect {
	-re "Set range checking.  .on/warn/off/auto..*$prompt $"\
			{ pass "help set check range" }
	-re "$prompt $"	{ fail "help set check range" }
	timeout		{ fail "(timeout) help set check range" }
	}


# test help set check type
send "help set check type\n"
expect {
	-re "Set type checking.  .on/warn/off/auto..*$prompt $"\
			{ pass "help set check type" }
	-re "$prompt $"	{ fail "help set check type" }
	timeout		{ fail "(timeout) help set check type" }
	}


# test help set complaints
send "help set complaints\n"
expect {
	-re "Set max number of complaints about incorrect symbols..*$prompt $"\
			{ pass "help set complaints" }
	-re "$prompt $"	{ fail "help set complaints" }
	timeout		{ fail "(timeout) help set complaints" }
	}


# test help set confirm
send "help set confirm\n"
expect {
	-re "Set whether to confirm potentially dangerous operations..*$prompt $"\
			{ pass "help set confirm" }
	-re "$prompt $"	{ fail "help set confirm" }
	timeout		{ fail "(timeout) help set confirm" }
	}


# test help set editing
send "help set editing\n"
expect {
	-re "Set editing of command lines as they are typed..*
Use \"on\" to enable to enable the editing, and \"off\" to disable it..*
Without an argument, command line editing is enabled.  To edit, use.*
EMACS-like or VI-like commands like control-P or ESC..*$prompt $"\
			{ pass "help set editing" }
	-re "$prompt $"	{ fail "help set editing" }
	timeout		{ fail "(timeout) help set editing" }
	}


# test help set environment
send "help set environment\n"
expect {
	-re "Set environment variable value to give the program..*
Arguments are VAR VALUE where VAR is variable name and VALUE is value..*
VALUES of environment variables are uninterpreted strings..*
This does not affect the program until the next \"run\" command..*$prompt $"\
			{ pass "help set environment" }
	-re "$prompt $"	{ fail "help set environment" }
	timeout		{ fail "(timeout) help set environment" }
	}


# test help set height
send "help set height\n"
expect {
	-re "Set number of lines gdb thinks are in a page..*$prompt $"\
			{ pass "help set height" }
	-re "$prompt $"	{ fail "help set height" }
	timeout		{ fail "(timeout) help set height" }
	}


# test help set history expansion
send "help set history expansion\n"
expect {
	-re "Set history expansion on command input..*
Without an argument, history expansion is enabled..*$prompt $"\
			{ pass "help set history expansion" }
	-re "$prompt $"	{ fail "help set history expansion" }
	timeout		{ fail "(timeout) help set history expansion" }
	}


# test help set history filename
send "help set history filename\n"
expect {
	-re "Set the filename in which to record the command history.*
 .the list of previous commands of which a record is kept...*$prompt $"\
			{ pass "help set history filename" }
	-re "$prompt $"	{ fail "help set history filename" }
	timeout		{ fail "(timeout) help set history filename" }
	}


# test help set history save
send "help set history save\n"
expect {
	-re "Set saving of the history record on exit..*
Use \"on\" to enable to enable the saving, and \"off\" to disable it..*
Without an argument, saving is enabled..*$prompt $"\
			{ pass "help set history save" }
	-re "$prompt $"	{ fail "help set history save" }
	timeout		{ fail "(timeout) help set history save" }
	}


# test help set history size
send "help set history size\n"
expect {
	-re "Set the size of the command history, .*
ie. the number of previous commands to keep a record of..*$prompt $"\
			{ pass "help set history size" }
	-re "$prompt $"	{ fail "help set history size" }
	timeout		{ fail "(timeout) help set history size" }
	}


# test help set history
send "help set history\n"
expect {
	-re "Generic command for setting command history parameters..*
List of set history subcommands:.*
set history filename -- Set the filename in which to record the command history.*
set history size -- Set the size of the command history.*
set history save -- Set saving of the history record on exit.*
set history expansion -- Set history expansion on command input.*
Type \"help set history\" followed by set history subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set history" }
	-re "$prompt $"	{ fail "help set history" }
	timeout		{ fail "(timeout) help set history" }
	}


# test help set language
send "help set language\n"
expect {
	-re "Set the current source language..*$prompt $"\
			{ pass "help set language" }
	-re "$prompt $"	{ fail "help set language" }
	timeout		{ fail "(timeout) help set language" }
	}


# test help set listsize
send "help set listsize\n"
expect {
	-re "Set number of source lines gdb will list by default..*$prompt $"\
			{ pass "help set listsize" }
	-re "$prompt $"	{ fail "help set listsize" }
	timeout		{ fail "(timeout) help set listsize" }
	}


# test help set print "p" abbreviation
# FIXME -- Ultrix hangs randomly on this very long output from gdb and
# continues with its output only if something is sent to gdb.
# This behaviour throws expect and gdb out of sync, so we better skip this 
# test.
# Also, if the system is slow, it may time out because the output is large.
# Just skip the test rather than bothering with increasing the timeout.
if 0 then {
send "help set p\n"
expect {
	-re ".*
Generic command for setting how things print..*
List of set print subcommands:.*
Type \"help set print\" followed by set print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set print \"p\" abbreviatio" }
	-re "$prompt $"	{ fail "help set print \"p\" abbreviatio" }
	timeout		{ fail "(timeout) help set print \"p\" abbreviatio" }
	}

# test help set print "pr" abbreviation
send "help set pr\n"
expect {
	-re ".*
Generic command for setting how things print..*
List of set print subcommands:.*
Type \"help set print\" followed by set print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set print \"pr\" abbreviation" }
	-re "$prompt $"	{ fail "help set print \"pr\" abbreviation" }
	timeout		{ fail "(timeout) help set print \"pr\" abbreviation" }
	}


# test help set print
send "help set print\n"
expect {
	-re ".*
Generic command for setting how things print..*
List of set print subcommands:.*
Type \"help set print\" followed by set print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help set print" }
	-re "$prompt $"	{ fail "help set print" }
	timeout		{ fail "(timeout) help set print" }
	}
}

# test help set print address
send "help set print address\n"
expect {
	-re "Set printing of addresses..*$prompt $"\
			{ pass "help set print address" }
	-re "$prompt $"	{ fail "help set print address" }
	timeout		{ fail "(timeout) help set print address" }
	}


# test help set print array
send "help set print array\n"
expect {
	-re "Set prettyprinting of arrays..*$prompt $"\
			{ pass "help set print array" }
	-re "$prompt $"	{ fail "help set print array" }
	timeout		{ fail "(timeout) help set print array" }
	}


# test help set print asm-demangle
send "help set print asm-demangle\n"
expect {
	-re "Set demangling of C\[+\]+ names in disassembly listings..*$prompt $"\
			{ pass "help set print asm-demangle" }
	-re "$prompt $"	{ fail "help set print asm-demangle" }
	timeout		{ fail "(timeout) help set print asm-demangle" }
	}


# test help set print demangle
send "help set print demangle\n"
expect {
	-re "Set demangling of encoded C\[+\]+ names when displaying symbols..*$prompt $"\
			{ pass "help set print demangle" }
	-re "$prompt $"	{ fail "help set print demangle" }
	timeout		{ fail "(timeout) help set print demangle" }
	}


# test help set print elements
send "help set print elements\n"
expect {
	-re "Set limit on string chars or array elements to print..*
\"set print elements 0\" causes there to be no limit..*$prompt $"\
			{ pass "help set print elements" }
	-re "$prompt $"	{ fail "help set print elements" }
	timeout		{ fail "(timeout) help set print elements" }
	}


# test help set print object
send "help set print object\n"
expect {
	-re "Set printing of object's derived type based on vtable info..*$prompt $"\
			{ pass "help set print object" }
	-re "$prompt $"	{ fail "help set print object" }
	timeout		{ fail "(timeout) help set print object" }
	}


# test help set print pretty
send "help set print pretty\n"
expect {
	-re "Set prettyprinting of structures..*$prompt $"\
			{ pass "help set print pretty" }
	-re "$prompt $"	{ fail "help set print pretty" }
	timeout		{ fail "(timeout) help set print pretty" }
	}


# test help set print sevenbit-strings
send "help set print sevenbit-strings\n"
expect {
	-re "Set printing of 8-bit characters in strings as .nnn..*$prompt $"\
			{ pass "help set print sevenbit-strings" }
	-re "$prompt $"	{ fail "help set print sevenbit-strings" }
	timeout		{ fail "(timeout) help set print sevenbit-strings" }
	}


# test help set print union
send "help set print union\n"
expect {
	-re "Set printing of unions interior to structures..*$prompt $"\
			{ pass "help set print union" }
	-re "$prompt $"	{ fail "help set print union" }
	timeout		{ fail "(timeout) help set print union" }
	}


# test help set print vtbl
send "help set print vtbl\n"
expect {
	-re "Set printing of C\[+\]+ virtual function tables..*$prompt $"\
			{ pass "help set print vtbl" }
	-re "$prompt $"	{ fail "help set print vtbl" }
	timeout		{ fail "(timeout) help set print vtbl" }
	}


# test help set prompt
send "help set prompt\n"
expect {
	-re "Set gdb's prompt.*$prompt $"\
			{ pass "help set prompt" }
	-re "$prompt $"	{ fail "help set prompt" }
	timeout		{ fail "(timeout) help set prompt" }
	}


# test help set radix
send "help set radix\n"
expect {
	-re "Set default input and output number radices.*
Use \'set input-radix\' or \'set output-radix\' to independently set each..*
Without an argument, sets both radices back to the default value of 10..*
.*$prompt $"\
			{ pass "help set radix" }
	-re "Set default input and output number radix..*$prompt $"\
			{ fail "help set radix (obsolete radix support)" }
	-re "$prompt $"	{ fail "help set radix" }
	timeout		{ fail "(timeout) help set radix" }
	}


# test help set symbol-reloading
send "help set symbol-reloading\n"
expect {
	-re "Set dynamic symbol table reloading multiple times in one run..*$prompt $"\
			{ pass "help set symbol-reloading" }
	-re "$prompt $"	{ fail "help set symbol-reloading" }
	timeout		{ fail "(timeout) help set symbol-reloading" }
	}


# test help set variable
send "help set variable\n"
expect {
	-re ".*
Evaluate expression EXP and assign result to variable VAR, using assignment.*
syntax appropriate for the current language .VAR = EXP or VAR := EXP for.*
example..  VAR may be a debugger \"convenience\" variable .names starting.*
with \\\$., a register .a few standard names starting with \\\$., or an actual.*
variable in the program being debugged.  EXP is any valid expression.*
This may usually be abbreviated to simply \"set\"..*$prompt $"\
			{ pass "help set variable" }
	-re "$prompt $"	{ fail "help set variable" }
	timeout		{ fail "(timeout) help set variable" }
	}


# test help set verbose
send "help set verbose\n"
expect {
	-re "Set verbosity..*$prompt $"\
			{ pass "help set verbose" }
	-re "Set verbose printing of informational messages.*$prompt $"\
			{ pass "help set verbose. FIXME" }
	-re "$prompt $"	{ fail "help set verbose" }
	timeout		{ fail "(timeout) help set verbose" }
	}


#test help set width
send "help set width\n"
expect {
	-re "Set number of characters gdb thinks are in a line..*$prompt $"\
			{ pass "help set width" }
	-re "$prompt $"	{ fail "help set width" }
	timeout		{ fail "(timeout) help set width" }
	}


# test help set write
# This is only supported on targets which use exec.o.
if ![istarget "rs6000-*-*"] then {
    send "help set write\n"
    expect {
	-re "Set writing into executable and core files..*$prompt $"\
			{ pass "help set write" }
	-re "$prompt $"	{ fail "help set write" }
	timeout		{ fail "(timeout) help set write" }
	}
}

# test help set
# FIXME -- Ultrix hangs randomly on this very long output from gdb and
# continues with its output only if something is sent to gdb.
# This behaviour throws expect and gdb out of sync, so we better skip this 
# test.
# Also, if the system is slow, it may time out because the output is large.
# Just skip the test rather than bothering with increasing the timeout.
if 0 then {
if ![istarget "*-*-ultrix*"] then {
    send "help set\n"
    expect {
	-re ".*
Evaluate expression EXP and assign result to variable VAR, using assignment.*
syntax appropriate for the current language .VAR = EXP or VAR := EXP for.*
example..  VAR may be a debugger \"convenience\" variable .names starting.*
with \\\$., a register .a few standard names starting with \\\$., or an actual.*
variable in the program being debugged.  EXP is any valid expression.*
set listsize -- Set number of source lines gdb will list by default.*
Type \"help set\" followed by set subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*
$prompt $"\
			{ pass "help set" }
	-re "$prompt $"	{ fail "help set" }
	timeout		{ fail "(timeout) help set" }
	}
}
}

# test help shell
send "help shell\n"
expect {
	-re "Execute the rest of the line as a shell command.  .*
With no arguments, run an inferior shell..*$prompt $"\
			{ pass "help shell" }
	-re "$prompt $"	{ fail "help shell" }
	timeout		{ fail "(timeout) help shell" }
	}


#test help show annotate
send "help show annotate\n"
expect {
	-re "Show annotation_level.*
0 == normal;     1 == fullname \\(for use when running under emacs\\).*
2 == output annotated suitably for use by programs that control GDB..*$prompt $"\
			{ pass "help show annotate" }
	-re "$prompt $"	{ fail "help show annotate" }
	timeout		{ fail "(timeout) help show annotate" }
	}


# test help show args
send "help show args\n"
expect {
	-re "Show arguments to give program being debugged when it is started..*
Follow this command with any number of args, to be passed to the program..*$prompt $"\
			{ pass "help show args" }
	-re "$prompt $"	{ fail "help show args" }
	timeout		{ fail "(timeout) help show args" }
	}


# test help show check "c" abbreviation
send "help show c\n"
expect {
	-re "Show the status of the type/range checker.*
List of show check subcommands:.*
show check range -- Show range checking.*
show check type -- Show type checking.*
Type \"help show check\" followed by show check subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show check \"c\" abbreviation" }
	-re "$prompt $"	{ fail "help show check \"c\" abbreviation" }
	timeout		{ fail "(timeout) help show check \"c\" abbreviation" }
	}


# test help show check
send "help show check\n"
expect {
	-re "Show the status of the type/range checker.*
List of show check subcommands:.*
show check range -- Show range checking.*
show check type -- Show type checking.*
Type \"help show check\" followed by show check subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show check" }
	-re "$prompt $"	{ fail "help show check" }
	timeout		{ fail "(timeout) help show check" }
	}


# test help show check range
send "help show check range\n"
expect {
	-re "Show range checking.  .on/warn/off/auto..*$prompt $"\
			{ pass "help show check range" }
	-re "$prompt $"	{ fail "help show check range" }
	timeout		{ fail "(timeout) help show check range" }
	}


# test help show check type
send "help show check type\n"
expect {
	-re "Show type checking.  .on/warn/off/auto..*$prompt $"\
			{ pass "help show check type" }
	-re "$prompt $"	{ fail "help show check type" }
	timeout		{ fail "(timeout) help show check type" }
	}


# test help show commands
send "help show commands\n"
expect {
	-re "Show the history of commands you typed..*
You can supply a command number to start with, or a `\[+\]' to start after.*
the previous command number shown..*$prompt $"\
			{ pass "help show commands" }
	-re "$prompt $"	{ fail "help show commands" }
	timeout		{ fail "(timeout) help show commands" }
	}


# test help show complaints
send "help show complaints\n"
expect {
	-re "Show max number of complaints about incorrect symbols..*$prompt $"\
			{ pass "help show complaints" }
	-re "$prompt $"	{ fail "help show complaints" }
	timeout		{ fail "(timeout) help show complaints" }
	}


# test help show confirm
send "help show confirm\n"
expect {
	-re "Show whether to confirm potentially dangerous operations..*$prompt $"\
			{ pass "help show confirm" }
	-re "$prompt $"	{ fail "help show confirm" }
	timeout		{ fail "(timeout) help show confirm" }
	}


# test help show convenience
send "help show convenience\n"
expect {
	-re "Debugger convenience .\".foo\". variables..*
These variables are created when you assign them values;.*
thus, \"print .foo=1\" gives \".foo\" the value 1.  Values may be any type..*
A few convenience variables are given values automatically:.*
\"._\"holds the last address examined with \"x\" or \"info lines\",.*
\".__\" holds the contents of the last address examined with \"x\"..*$prompt $"\
			{ pass "help show convenience" }
	-re "$prompt $"	{ fail "help show convenience" }
	timeout		{ fail "(timeout) help show convenience" }
	}


# test help show directories
send "help show directories\n"
expect {
	-re "Current search path for finding source files..*
.cwd in the path means the current working directory..*
.cdir in the path means the compilation directory of the source file..*$prompt $"\
			{ pass "help show directories" }
	-re "$prompt $"	{ fail "help show directories" }
	timeout		{ fail "(timeout) help show directories" }
	}


# test help show editing
send "help show editing\n"
expect {
	-re "Show editing of command lines as they are typed..*
Use \"on\" to enable to enable the editing, and \"off\" to disable it..*
Without an argument, command line editing is enabled.  To edit, use.*
EMACS-like or VI-like commands like control-P or ESC..*$prompt $"\
			{ pass "help show editing" }
	-re "$prompt $"	{ fail "help show editing" }
	timeout		{ fail "(timeout) help show editing" }
	}


# test help show environment
send "help show environment\n"
expect {
	-re "The environment to give the program, or one variable's value..*
With an argument VAR, prints the value of environment variable VAR to.*
give the program being debugged.  With no arguments, prints the entire.*
environment to be given to the program..*$prompt $"\
			{ pass "help show environment" }
	-re "$prompt $"	{ fail "help show environment" }
	timeout		{ fail "(timeout) help show environment" }
	}


# test help show height
send "help show height\n"
expect {
	-re "Show number of lines gdb thinks are in a page..*$prompt $"\
			{ pass "help show height" }
	-re "$prompt $"	{ fail "help show height" }
	timeout		{ fail "(timeout) help show height" }
	}


# test help show history expansion
send "help show history expansion\n"
expect {
	-re "Show history expansion on command input..*
Without an argument, history expansion is enabled..*$prompt $"\
			{ pass "help show history expansion" }
	-re "$prompt $"	{ fail "help show history expansion" }
	timeout		{ fail "(timeout) help show history expansion" }
	}


# test help show history filename
send "help show history filename\n"
expect {
	-re "Show the filename in which to record the command history.*
 .the list of previous commands of which a record is kept...*$prompt $"\
			{ pass "help show history filename" }
	-re "$prompt $"	{ fail "help show history filename" }
	timeout		{ fail "(timeout) help show history filename" }
	}


# test help show history save
send "help show history save\n"
expect {
	-re "Show saving of the history record on exit..*
Use \"on\" to enable to enable the saving, and \"off\" to disable it..*
Without an argument, saving is enabled..*$prompt $"\
			{ pass "help show history save" }
	-re "$prompt $"	{ fail "help show history save" }
	timeout		{ fail "(timeout) help show history save" }
	}


# test help show history size
send "help show history size\n"
expect {
	-re "Show the size of the command history, .*
ie. the number of previous commands to keep a record of..*$prompt $"\
			{ pass "help show history size" }
	-re "$prompt $"	{ fail "help show history size" }
	timeout		{ fail "(timeout) help show history size" }
	}


# test help show history
send "help show history\n"
expect {
	-re "Generic command for showing command history parameters..*
List of show history subcommands:.*
show history filename -- Show the filename in which to record the command history.*
show history size -- Show the size of the command history.*
show history save -- Show saving of the history record on exit.*
show history expansion -- Show history expansion on command input.*
Type \"help show history\" followed by show history subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show history" }
	-re "$prompt $"	{ fail "help show history" }
	timeout		{ fail "(timeout) help show history" }
	}


# test help show language
send "help show language\n"
expect {
	-re "Show the current source language..*$prompt $"\
			{ pass "help show language" }
	-re "$prompt $"	{ fail "help show language" }
	timeout		{ fail "(timeout) help show language" }
	}


# test help show listsize
send "help show listsize\n"
expect {
	-re "Show number of source lines gdb will list by default..*$prompt $"\
			{ pass "help show listsize" }
	-re "$prompt $"	{ fail "help show listsize" }
	timeout		{ fail "(timeout) help show listsize" }
	}


# test help show print "p" abbreviation
send "help show p\n"
expect {
	-re "Generic command for showing print settings..*
List of show print subcommands:.*
Type \"help show print\" followed by show print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show print \"p\" abbreviation" }
	-re "$prompt $"	{ fail "help show print \"p\" abbreviation" }
	timeout		{ fail "(timeout) help show print \"p\" abbreviation" }
	}


# test help show print "pr" abbreviation
send "help show pr\n"
expect {
	-re "Generic command for showing print settings..*
List of show print subcommands:.*
Type \"help show print\" followed by show print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show print \"pr\" abbreviation" }
	-re "$prompt $"	{ fail "help show print \"pr\" abbreviation" }
	timeout		{ fail "(timeout) help show print \"pr\" abbreviation" }
	}


# test help show print
send "help show print\n"
expect {
	-re "Generic command for showing print settings..*
List of show print subcommands:.*
Type \"help show print\" followed by show print subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show print" }
	-re "$prompt $"	{ fail "help show print" }
	timeout		{ fail "(timeout) help show print" }
	}


# test help show paths
send "help show paths\n"
expect {
	-re "Current search path for finding object files..*
.cwd in the path means the current working directory..*
This path is equivalent to the .PATH shell variable.  It is a list of.*
directories, separated by colons.  These directories are searched to find.*
fully linked executable files and separately compiled object files as needed..*$prompt $"\
			{ pass "help show paths" }
	-re "$prompt $"	{ fail "help show paths" }
	timeout		{ fail "(timeout) help show paths" }
	}


# test help show print address
send "help show print address\n"
expect {
	-re "Show printing of addresses..*$prompt $"\
			{ pass "help show print address" }
	-re "$prompt $"	{ fail "help show print address" }
	timeout		{ fail "(timeout) help show print address" }
	}


# test help show print array
send "help show print array\n"
expect {
	-re "Show prettyprinting of arrays..*$prompt $"\
			{ pass "help show print array" }
	-re "$prompt $"	{ fail "help show print array" }
	timeout		{ fail "(timeout) help show print array" }
	}


# test help show print asm-demangle
send "help show print asm-demangle\n"
expect {
	-re "Show demangling of C\[+\]+ names in disassembly listings..*$prompt $"\
			{ pass "help show print asm-demangle" }
	-re "$prompt $"	{ fail "help show print asm-demangle" }
	timeout		{ fail "(timeout) help show print asm-demangle" }
	}


# test help show print demangle
send "help show print demangle\n"
expect {
	-re "Show demangling of encoded C\[+\]+ names when displaying symbols..*$prompt $"\
			{ pass "help show print demangle" }
	-re "$prompt $"	{ fail "help show print demangle" }
	timeout		{ fail "(timeout) help show print demangle" }
	}


# test help show print elements
send "help show print elements\n"
expect {
	-re "Show limit on string chars or array elements to print..*
\"set print elements 0\" causes there to be no limit..*$prompt $"\
			{ pass "help show print elements" }
	-re "$prompt $"	{ fail "help show print elements" }
	timeout		{ fail "(timeout) help show print elements" }
	}


# test help show print object
send "help show print object\n"
expect {
	-re "Show printing of object's derived type based on vtable info..*$prompt $"\
			{ pass "help show print object" }
	-re "$prompt $"	{ fail "help show print object" }
	timeout		{ fail "(timeout) help show print object" }
	}


# test help show print pretty
send "help show print pretty\n"
expect {
	-re "Show prettyprinting of structures..*$prompt $"\
			{ pass "help show print pretty" }
	-re "$prompt $"	{ fail "help show print pretty" }
	timeout		{ fail "(timeout) help show print pretty" }
	}


# test help show print sevenbit-strings
send "help show print sevenbit-strings\n"
expect {
	-re "Show printing of 8-bit characters in strings as .nnn..*$prompt $"\
			{ pass "help show print sevenbit-strings" }
	-re "$prompt $"	{ fail "help show print sevenbit-strings" }
	timeout		{ fail "(timeout) help show print sevenbit-strings" }
	}


# test help show print union
send "help show print union\n"
expect {
	-re "Show printing of unions interior to structures..*$prompt $"\
			{ pass "help show print union" }
	-re "$prompt $"	{ fail "help show print union" }
	timeout		{ fail "(timeout) help show print union" }
	}


# test help show print vtbl
send "help show print vtbl\n"
expect {
	-re "Show printing of C\[+\]+ virtual function tables..*$prompt $"\
			{ pass "help show print vtbl" }
	-re "$prompt $"	{ fail "help show print vtbl" }
	timeout		{ fail "(timeout) help show print vtbl" }
	}


# test help show prompt
send "help show prompt\n"
expect {
	-re "Show gdb's prompt.*$prompt $"\
			{ pass "help show prompt" }
	-re "$prompt $"	{ fail "help show prompt" }
	timeout		{ fail "(timeout) help show prompt" }
	}


# test help show radix
send "help show radix\n"
expect {
	-re "Show the default input and output number radices.*
Use \'show input-radix\' or \'show output-radix\' to independently show each.*
$prompt $"\
			{ pass "help show radix" }
	-re "Show default input and output number radix..*$prompt $"\
			{ fail "help show radix (obsolete radix support)" }
	-re "$prompt $"	{ fail "help show radix" }
	timeout		{ fail "(timeout) help show radix" }
	}


# test help show symbol-reloading
send "help show symbol-reloading\n"
expect {
	-re "Show dynamic symbol table reloading multiple times in one run..*$prompt $"\
			{ pass "help show symbol-reloading" }
	-re "$prompt $"	{ fail "help show symbol-reloading" }
	timeout		{ fail "(timeout) help show symbol-reloading" }
	}


# test help show user
send "help show user\n"
expect {
	-re "Show definitions of user defined commands..*
Argument is the name of the user defined command..*
With no argument, show definitions of all user defined commands..*$prompt $"\
			{ pass "help show user" }
	-re "$prompt $"	{ fail "help show user" }
	timeout		{ fail "(timeout) help show user" }
	}


# test help show values
send "help show values\n"
expect {
	-re "Elements of value history around item number IDX .or last ten...*$prompt $"\
			{ pass "help show values" }
	-re "$prompt $"	{ fail "help show values" }
	timeout		{ fail "(timeout) help show values" }
	}


# test help show verbose
send "help show verbose\n"
expect {
	-re "Show verbosity..*$prompt $"\
			{ pass "help show verbose" }
	-re "Show verbose printing of informational messages..*$prompt $"\
			{ pass "help show verbose. FIXME" }
	-re "$prompt $"	{ fail "help show verbose" }
	timeout		{ fail "(timeout) help show verbose" }
	}


# test help show version
send "help show version\n"
expect {
	-re "Show what version of GDB this is..*$prompt $"\
			{ pass "help show version" }
	-re "$prompt $"	{ fail "help show version" }
	timeout		{ fail "(timeout) help show version" }
	}


# test help show width
send "help show width\n"
expect {
	-re "Show number of characters gdb thinks are in a line..*$prompt $"\
			{ pass "help show width" }
	-re "$prompt $"	{ fail "help show width" }
	timeout		{ fail "(timeout) help show width" }
	}


# test help show write
# This is only supported on targets which use exec.o.
if ![istarget "rs6000-*-*"] then {
    send "help show write\n"
    expect {
	-re "Show writing into executable and core files..*$prompt $"\
			{ pass "help show write" }
	-re "$prompt $"	{ fail "help show write" }
	timeout		{ fail "(timeout) help show write" }
	}
}

# test help show
# If the system is slow, it may time out because the output is large.
# Just skip the test rather than bothering with increasing the timeout.
if 0 then {
send "help show\n"
expect {
	-re "Generic command for showing things about the debugger..*
List of show subcommands:.*
show listsize -- Show number of source lines gdb will list by default.*
show directories -- Current search path for finding source files.*
Type \"help show\" followed by show subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help show" }
	-re "$prompt $"	{ fail "help show" }
	timeout		{ fail "(timeout) help show" }
	}
}



# test help step
send "help step\n"
expect {
	-re "Step program until it reaches a different source line..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help step" }
	-re "$prompt $"	{ fail "help step" }
	timeout		{ fail "(timeout) help step" }
	}

# test help stepi "si" abbreviation
send "help si\n"
expect {
	-re "Step one instruction exactly..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help stepi \"si\" abbreviation" }
	-re "$prompt $"	{ fail "help stepi \"si\" abbreviation" }
	timeout		{ fail "(timeout) help stepi \"si\" abbreviation" }
	}


# test help stepi
send "help stepi\n"
expect {
	-re "Step one instruction exactly..*
Argument N means do this N times .or till program stops for another reason...*$prompt $"\
			{ pass "help stepi" }
	-re "$prompt $"	{ fail "help stepi" }
	timeout		{ fail "(timeout) help stepi" }
	}


# test help signal
send "help signal\n"
expect {
	-re "Continue program giving it signal.*$prompt $"\
			{ pass "help signal" }
	-re "$prompt $"	{ fail "help signal" }
	timeout		{ fail "(timeout) help signal" }
	}


# test help source
# vxgdb reads .vxgdbinit
send "help source\n"
expect {
	-re "Read commands from a file named FILE..*
Note that the file \".(vx)?gdbinit\" is read automatically in this way.*
when gdb is started..*$prompt $"\
			{ pass "help source" }
	-re "$prompt $"	{ fail "help source" }
	timeout		{ fail "(timeout) help source" }
	}


# test help stack
send "help stack\n"
expect {
	-re "Examining the stack..*
The stack is made up of stack frames.  Gdb assigns numbers to stack frames.*
counting from zero for the innermost .currently executing. frame..*
At any time gdb identifies one frame as the \"selected\" frame..*
Variable lookups are done with respect to the selected frame..*
When the program being debugged stops, gdb selects the innermost frame..*
The commands below can be used to select other frames by number or address..*
List of commands:.*
bt -- Print backtrace of all stack frames.*
backtrace -- Print backtrace of all stack frames.*
select-frame -- Select a stack frame without printing anything.*
frame -- Select and print a stack frame.*
down -- Select and print stack frame called by this one.*
up -- Select and print stack frame that called this one.*
return -- Make selected stack frame return to its caller.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help stack" }
	-re "$prompt $"	{ fail "help stack" }
	timeout		{ fail "(timeout) help stack" }
	}


# test help status
send "help status\n"
expect {
	-re "Status inquiries..*
List of commands:.*
show -- Generic command for showing things about the debugger.*
info -- Generic command for showing things about the program being debugged.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help status" }
	-re "$prompt $"	{ fail "help status" }
	timeout		{ fail "(timeout) help status" }
	}


# test help support
# FIXME -- Ultrix hangs randomly on this very long output from gdb and
# continues with its output only if something is sent to gdb.
# This behaviour throws expect and gdb out of sync, so we better skip this 
# test.
# Also, if the system is slow, it may time out because the output is large.
# Just skip the test rather than bothering with increasing the timeout.
if 0 then {
send "help support\n"
expect {
	-re "Support facilities..*
List of commands:.*
show confirm -- Show whether to confirm potentially dangerous operations.*
show history -- Generic command for showing command history parameters.*
down-silently -- Same as the `down' command.*
up-silently -- Same as the `up' command.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help support" }
	-re "$prompt $"	{ fail "help support" }
	timeout		{ fail "(timeout) help support" }
	}
}

# test help symbol-file
send "help symbol-file\n"
expect {
	-re "Load symbol table from executable file FILE..*
The `file' command can also load symbol tables, as well as setting the file.*
to execute..*$prompt $"\
			{ pass "help symbol-file" }
	-re "$prompt $"	{ fail "help symbol-file" }
	timeout		{ fail "(timeout) help symbol-file" }
	}


# test help target child
send "help target child\n"
expect {
	-re "Unix child process .started by the \"run\" command...*$prompt $"\
	    { pass "help target child (non-procfs version)" }
	-re "Undefined target command: \"child\".  Try \"help target\"..*$prompt $"\
	    { pass "help target child (procfs version)" }
	-re "$prompt $"	{ fail "help target child" }
	timeout		{ fail "(timeout) help target child" }
	}


# test help target procfs
send "help target procfs\n"
expect {
	-re "Unix /proc child process .started by the \"run\" command...*$prompt $"\
	    { pass "help target procfs (procfs version)" }
	-re "Undefined target command: \"procfs\".  Try \"help target\"..*$prompt $"\
	    { pass "help target procfs (non-procfs version)" }
	-re "$prompt $"	{ fail "help target procfs" }
	timeout		{ fail "(timeout) help target procfs" }
	}


# test help target core
send "help target core\n"
expect {
	-re "Use a core file as a target.  Specify the filename of the core file..*$prompt $"\
			{ pass "help target core" }
	-re "Undefined target command: \"core\".  Try \"help target\"..*$prompt $"\
			{ pass "help target core" }
	-re "$prompt $"	{ fail "help target core" }
	timeout		{ fail "(timeout) help target core" }
	}


# test help target exec
send "help target exec\n"
expect {
	-re "Use an executable file as a target..*
Specify the filename of the executable file..*$prompt $"\
			{ pass "help target exec" }
	-re "$prompt $"	{ fail "help target exec" }
	timeout		{ fail "(timeout) help target exec" }
	}


# test help target remote
if ![istarget "*-*-udi*"] then {
    send "help target remote\n"
    expect {
	-re "Use a remote computer via a serial line, using a gdb-specific protocol..*
Specify the serial device it is connected to .e.g. /dev/ttya...*$prompt $"\
			{ pass "help target remote" }
	-re "$prompt $"	{ fail "help target remote" }
	timeout		{ fail "(timeout) help target remote" }
    }
}

# test help target
# the child process target may be "target child" or "target procfs"
send "help target\n"
expect {
	-re "Connect to a target machine or process..*
The first argument is the type or protocol of the target machine..*
Remaining arguments are interpreted by the target protocol.  For more.*
information on the arguments for a particular protocol, type.*
`help target ' followed by the protocol name..*
List of target subcommands:.*
target exec -- Use an executable file as a target.*
Type \"help target\" followed by target subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help target" }
	-re "$prompt $"	{ fail "help target" }
	timeout		{ fail "(timeout) help target" }
	}


# test help tbreak
send "help tbreak\n"
expect {
	-re "Set a temporary breakpoint.*$prompt $"\
			{ pass "help tbreak" }
	-re "$prompt $"	{ fail "help tbreak" }
	timeout		{ fail "(timeout) help tbreak" }
	}


# test help tty
send "help tty\n"
expect {
	-re "Set terminal for future runs of program being debugged..*$prompt $"\
			{ pass "help tty" }
	-re "$prompt $"	{ fail "help tty" }
	timeout		{ fail "(timeout) help tty" }
	}


# test help until "u" abbreviation
send "help u\n"
expect {
	-re "Execute until the program reaches a source line greater than the current.*
or a specified line or address or function .same args as break command...*
Execution will also stop upon exit from the current stack frame..*$prompt $"\
			{ pass "help until \"u\" abbreviation" }
	-re "$prompt $"	{ fail "help until \"u\" abbreviation" }
	timeout		{ fail "(timeout) help until \"u\" abbreviation" }
	}


# test help until
send "help until\n"
expect {
	-re "Execute until the program reaches a source line greater than the current.*
or a specified line or address or function .same args as break command...*
Execution will also stop upon exit from the current stack frame..*$prompt $"\
			{ pass "help until" }
	-re "$prompt $"	{ fail "help until" }
	timeout		{ fail "(timeout) help until" }
	}


# test help undisplay
send "help undisplay\n"
expect {
	-re "Cancel some expressions to be displayed when program stops..*
Arguments are the code numbers of the expressions to stop displaying..*
No argument means cancel all automatic-display expressions..*
\"delete display\" has the same effect as this command..*
Do \"info display\" to see current list of code numbers..*$prompt $"\
			{ pass "help undisplay" }
	-re "$prompt $"	{ fail "help undisplay" }
	timeout		{ fail "(timeout) help undisplay" }
	}


# test help unset environment
send "help unset environment\n"
expect {
	-re "Cancel environment variable VAR for the program..*
This does not affect the program until the next \"run\" command..*$prompt $"\
			{ pass "help unset environment" }
	-re "$prompt $"	{ fail "help unset environment" }
	timeout		{ fail "(timeout) help unset environment" }
	}


# test help unset
send "help unset\n"
expect {
	-re "Complement to certain \"set\" commands.*
List of unset subcommands:.*
unset environment -- Cancel environment variable VAR for the program.*
Type \"help unset\" followed by unset subcommand name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help unset" }
	-re "$prompt $"	{ fail "help unset" }
	timeout		{ fail "(timeout) help unset" }
	}


# test help up
send "help up\n"
expect {
	-re "Select and print stack frame that called this one..*
An argument says how many frames up to go..*$prompt $"\
			{ pass "help up" }
	-re "$prompt $"	{ fail "help up" }
	timeout		{ fail "(timeout) help up" }
	}


# test help up-silently
send "help up-silently\n"
expect {
	-re "Same as the `up' command, but does not print anything..*
This is useful in command scripts..*$prompt $"\
			{ pass "help up-silently" }
	-re "$prompt $"	{ fail "help up-silently" }
	timeout		{ fail "(timeout) help up-silently" }
	}


# test help user-defined
send "help user-defined\n"
expect {
	-re "User-defined commands..*
The commands in this class are those defined by the user..*
Use the \"define\" command to define a command..*
List of commands:.*
Type \"help\" followed by command name for full documentation..*
Command name abbreviations are allowed if unambiguous..*$prompt $"\
			{ pass "help user-defined" }
	-re "$prompt $"	{ fail "help user-defined" }
	timeout		{ fail "(timeout) help user-defined" }
	}


# test help watch
send "help watch\n"
expect {
	-re "Set a watchpoint for an expression..*
A watchpoint stops execution of your program whenever the value of.*
an expression changes..*$prompt $"\
			{ pass "help watch" }
	-re "$prompt $"	{ fail "help watch" }
	timeout		{ fail "(timeout) help watch" }
	}


# test help whatis
send "help whatis\n"
expect {
	-re "Print data type of expression EXP..*$prompt $"\
			{ pass "help whatis" }
	-re "$prompt $"	{ fail "help whatis" }
	timeout		{ fail "(timeout) help whatis" }
	}


# test help where
send "help where\n"
expect {
	-re "Print backtrace of all stack frames, or innermost COUNT frames..*
With a negative argument, print outermost -COUNT frames..*$prompt $"\
			{ pass "help where" }
	-re "$prompt $"	{ fail "help where" }
	timeout		{ fail "(timeout) help where" }
	}


# test help x
send "help x\n"
expect {
	-re "Examine memory: x/FMT ADDRESS..*
ADDRESS is an expression for the memory address to examine..*
FMT is a repeat count followed by a format letter and a size letter..*
Defaults for format and size letters are those previously used..*
Default count is 1.  Default address is following last thing printed.*
with this command or \"print\"..*$prompt $"\
			{ pass "help x" }
	-re "$prompt $"	{ fail "help x" }
	timeout		{ fail "(timeout) help x" }
	}


# test help info bogus-gdb-command
send "help info bogus-gdb-command\n"
expect {
	-re "Undefined info command: \"bogus-gdb-command\".  Try \"help info\"..*$prompt $"\
			{ pass "help info bogus-gdb-command" }
	-re "$prompt $"	{ fail "help info bogus-gdb-command" }
	timeout		{ fail "(timeout) help info bogus-gdb-command" }
	}


# test help gotcha
send "help gotcha\n"
expect {
	-re "Undefined command: \"gotcha\".  Try \"help\"..*$prompt $"\
			{ pass "help gotcha" }
	-re "$prompt $"	{ fail "help gotcha" }
	timeout		{ fail "(timeout) help gotcha" }
	}

