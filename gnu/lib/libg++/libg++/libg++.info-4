This is Info file libg++.info, produced by Makeinfo-1.55 from the input
file /kalessin/giga/bothner/dist/devo/libg++/libg++.texi.

START-INFO-DIR-ENTRY
* Libg++: (libg++).             The g++ class library.
END-INFO-DIR-ENTRY

   This file documents the features and implementation of The GNU C++
library

   Copyright (C) 1988, 1991, 1992 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU Library General Public License" is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU Library General Public
License" and this permission notice may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: libg++.info,  Node: Data,  Next: Curses,  Prev: Random,  Up: Top

Data Collection
***************

   Libg++ currently provides two classes for *data collection* and
analysis of the collected data.

SampleStatistic
===============

   Class `SampleStatistic' provides a means of accumulating samples of
`double' values and providing common sample statistics.

   Assume declaration of `double x'.

`SampleStatistic a;'
     declares and initializes a.

`a.reset();'
     re-initializes a.

`a += x;'
     adds sample x.

`int n = a.samples();'
     returns the number of samples.

`x = a.mean;'
     returns the means of the samples.

`x = a.var()'
     returns the sample variance of the samples.

`x = a.stdDev()'
     returns the sample standard deviation of the samples.

`x = a.min()'
     returns the minimum encountered sample.

`x = a.max()'
     returns the maximum encountered sample.

`x = a.confidence(int p)'
     returns the p-percent (0 <= p < 100) confidence interval.

`x = a.confidence(double p)'
     returns the p-probability (0 <= p < 1) confidence interval.

SampleHistogram
===============

   Class `SampleHistogram' is a derived class of `SampleStatistic' that
supports collection and display of samples in bucketed intervals. It
supports the following in addition to `SampleStatisic' operations.

`SampleHistogram h(double lo, double hi, double width);'
     declares and initializes h to have buckets of size width from lo
     to hi.  If the optional argument width is not specified, 10
     buckets are created. The first bucket and also holds samples less
     than lo, and the last one holds samples greater than hi.

`int n = h.similarSamples(x)'
     returns the number of samples in the same bucket as x.

`int n = h.inBucket(int i)'
     returns the number of samples in  bucket i.

`int b = h.buckets()'
     returns the number of buckets.

`h.printBuckets(ostream s)'
     prints bucket counts on ostream s.

`double bound = h.bucketThreshold(int i)'
     returns the upper bound of bucket i.


File: libg++.info,  Node: Curses,  Next: List,  Prev: Data,  Up: Top

Curses-based classes
********************

   The `CursesWindow' class is a repackaging of standard curses library
features into a class. It relies on `curses.h'.

   The supplied `curses.h' is a fairly conservative declaration of
curses library features, and does not include features like "screen" or
X-window support. It is, for the most part, an adaptation, rather than
an improvement of C-based `curses.h' files. The only substantive
changes are the declarations of many functions as inline functions
rather than macros, which was done solely to allow overloading.

   The `CursesWindow' class encapsulates curses window functions within
a class. Only those functions that control windows are included:
Terminal control functions and macros like `cbreak' are not part of the
class.  All `CursesWindows' member functions have names identical to
the corresponding curses library functions, except that the "w" prefix
is generally dropped. Descriptions of these functions may be found in
your local curses library documentation.

   A `CursesWindow' may be declared via

`CursesWindow w(WINDOW* win)'
     attaches w to the existing WINDOW* win. This is constructor is
     normally used only in the following special case.

`CursesWindow w(stdscr)'
     attaches w to the default curses library standard screen window.

`CursesWindow w(int lines, int cols, int begin_y, int begin_x)'
     attaches to an allocated curses window with the indicated size and
     screen position.

`CursesWindow sub(CursesWindow& w,int l,int c,int by,int bx,char ar='a')'
     attaches to a subwindow of w created via the curses `subwin'
     command.  If ar is sent as `r', the origin (by, bx) is relative to
     the parent window, else it is absolute.

   The class maintains a static counter that is used in order to
automatically call the curses library `initscr' and `endscr' functions
at the proper times. These need not, and should not be called
"manually".

   `CursesWindow's maintain a tree of their subwindows. Upon
destruction of a `CursesWindow', all of their subwindows are also
invalidated if they had not previously been destroyed.

   It is possible to traverse trees of subwindows via the following
member functions

`CursesWindow* w.parent()'
     returns a pointer to the parent of the subwindow, or 0 if there is
     none.

`CursesWindow* w.child()'
     returns the first child subwindow of the window, or 0 if there is
     none.

`CursesWindow* w.sibling()'
     returns the next sibling of the subwindow, or 0 if there is none.

   For example, to call some function `visit' for all subwindows of a
window, you could write


     void traverse(CursesWindow& w)
     {
       visit(w);
       if (w.child() != 0) traverse(*w.child);
       if (w.sibling() != 0) traverse(*w.sibling);
     }


File: libg++.info,  Node: List,  Next: LinkList,  Prev: Curses,  Up: Top

List classes
************

   The files `g++-include/List.hP' and `g++-include/List.ccP' provide
pseudo-generic Lisp-type List classes.  These lists are homogeneous
lists, more similar to lists in statically typed functional languages
like ML than Lisp, but support operations very similar to those found
in Lisp.  Any particular kind of list class may be generated via the
`genclass' shell command. However, the implementation assumes that the
base class supports an equality operator `=='.  All equality tests use
the `==' operator, and are thus equivalent to the use of `equal', not
`eq' in Lisp.

   All list nodes are created dynamically, and managed via reference
counts.  `List' variables are actually pointers to these list nodes.
Lists may also be traversed via Pixes, as described in the section
describing Pixes. *Note Pix::

   Supported operations are mirrored closely after those in Lisp.
Generally, operations with functional forms are constructive,
functional operations, while member forms (often with the same name)
are sometimes procedural, possibly destructive operations.

   As with Lisp, destructive operations are supported. Programmers are
allowed to change head and tail fields in any fashion, creating
circular structures and the like. However, again as with Lisp, some
operations implicitly assume that they are operating on pure lists, and
may enter infinite loops when presented with improper lists. Also, the
reference-counting storage management facility may fail to reclaim
unused circularly-linked nodes.

   Several Lisp-like higher order functions are supported (e.g., `map').
Typedef declarations for the required functional forms are provided int
the `.h' file.

   For purposes of illustration, assume the specification of class
`intList'.  Common Lisp versions of supported operations are shown in
brackets for comparison purposes.

Constructors and assignment
===========================

`intList a;           [ (setq a nil) ]'
     Declares a to be a nil intList.

`intList b(2);        [ (setq b (cons 2 nil)) ]'
     Declares b to be an intList with a head value of 2, and a nil tail.

`intList c(3, b);     [ (setq c (cons 3 b)) ]'
     Declares c to be an intList with a head value of 3, and b as its
     tail.

`b = a;               [ (setq b a) ]'
     Sets b to be the same list as a.

   Assume the declarations of intLists a, b, and c in the following.
*Note Pix::.

List status
===========

`a.null(); OR !a;      [ (null a) ]'
     returns true if a is null.

`a.valid();            [ (listp a) ]'
     returns true if a is non-null. Inside a conditional test, the
     `void*' coercion may also be used as in `if (a) ...'.

`intList();            [ nil ]'
     intList() may be used to null terminate a list, as in `intList
     f(int x) {if (x == 0) return intList(); ... } '.

`a.length();           [ (length a) ]'
     returns the length of a.

`a.list_length();      [ (list-length a) ]'
     returns the length of a, or -1 if a is circular.

heads and tails
===============

`a.get(); OR a.head()  [ (car a) ]'
     returns a reference to the head field.

`a[2];                 [ (elt a 2) ]'
     returns a reference to the second (counting from zero) head field.

`a.tail();             [ (cdr a) ]'
     returns the intList that is the tail of a.

`a.last();             [ (last a) ]'
     returns the intList that is the last node of a.

`a.nth(2);             [ (nth a 2) ]'
     returns the intList that is the nth node of a.

`a.set_tail(b);        [ (rplacd a b) ]'
     sets a's tail to b.

`a.push(2);            [ (push 2 a) ]'
     equivalent to a = intList(2, a);

`int x = a.pop()       [ (setq x (car a)) (pop a) ]'
     returns the head of a, also setting a to its tail.

Constructive operations
=======================

`b = copy(a);          [ (setq b (copy-seq a)) ]'
     sets b to a copy of a.

`b = reverse(a);       [ (setq b (reverse a)) ]'
     Sets b to a reversed copy of a.

`c = concat(a, b);     [ (setq c (concat a b)) ]'
     Sets c to a concatenated copy of a and b.

`c = append(a, b);     [ (setq c (append a b)) ]'
     Sets c to a concatenated copy of a and b. All nodes of a are
     copied, with the last node pointing to b.

`b = map(f, a);        [ (setq b (mapcar f a)) ]'
     Sets b to a new list created by applying function f to each node
     of a.

`c = combine(f, a, b);'
     Sets c to a new list created by applying function f to successive
     pairs of a and b. The resulting list has length the shorter of a
     and b.

`b = remove(x, a);     [ (setq b (remove x a)) ]'
     Sets b to a copy of a, omitting all occurrences of x.

`b = remove(f, a);     [ (setq b (remove-if f a)) ]'
     Sets b to a copy of a, omitting values causing function f to
     return true.

`b = select(f, a);     [ (setq b (remove-if-not f a)) ]'
     Sets b to a copy of a, omitting values causing function f to
     return false.

`c = merge(a, b, f);   [ (setq c (merge a b f)) ]'
     Sets c to a list containing the ordered elements (using the
     comparison function f) of the sorted lists a and b.

Destructive operations
======================

`a.append(b);          [ (rplacd (last a) b) ]'
     appends b to the end of a. No new nodes are constructed.

`a.prepend(b);         [ (setq a (append b a)) ]'
     prepends b to the beginning of a.

`a.del(x);             [ (delete x a) ]'
     deletes all nodes with value x from a.

`a.del(f);             [ (delete-if f a) ]'
     deletes all nodes causing function f to return true.

`a.select(f);          [ (delete-if-not f a) ]'
     deletes all nodes causing function f to return false.

`a.reverse();          [ (nreverse a) ]'
     reverses a in-place.

`a.sort(f);            [ (sort a f) ]'
     sorts a in-place using ordering (comparison) function f.

`a.apply(f);           [ (mapc f a) ]'
     Applies void function f (int x) to each element of a.

`a.subst(int old, int repl); [ (nsubst repl old a) ]'
     substitutes repl for each occurrence of old in a. Note the
     different argument order than the Lisp version.

Other operations
================

`a.find(int x);       [ (find x a) ]'
     returns the intList at the first occurrence of x.

`a.find(b);           [ (find b a) ]'
     returns the intList at the first occurrence of sublist b.

`a.contains(int x);    [ (member x a) ]'
     returns true if a contains x.

`a.contains(b);        [ (member b a) ]'
     returns true if a contains sublist b.

`a.position(int x);    [ (position x a) ]'
     returns the zero-based index of x in a, or -1 if x does not occur.

`int x = a.reduce(f, int base); [ (reduce f a :initial-value base) ]'
     Accumulates the result of applying int function f(int, int) to
     successive elements of a, starting with base.


File: libg++.info,  Node: LinkList,  Next: Vector,  Prev: List,  Up: Top

Linked Lists
************

   SLLists provide pseudo-generic singly linked lists.  DLLists provide
doubly linked lists.  The lists are designed for the simple maintenance
of elements in a linked structure, and do not provide the more extensive
operations (or node-sharing) of class `List'. They behave similarly to
the `slist' and similar classes described by Stroustrup.

   All list nodes are created dynamically. Assignment is performed via
copying.

   Class `DLList' supports all `SLList' operations, plus additional
operations described below.

   For purposes of illustration, assume the specification of class
`intSLList'. In addition to the operations listed here, SLLists support
traversal via Pixes. *Note Pix::

`intSLList a;'
     Declares a to be an empty list.

`intSLList b = a;'
     Sets b to an element-by-element copy of a.

`a.empty()'
     returns true if a contains no elements

`a.length();'
     returns the number of elements in a.

`a.prepend(x);'
     places x at the front of the list.

`a.append(x);'
     places x at the end of the list.

`a.join(b)'
     places all nodes from b to the end of a, simultaneously destroying
     b.

`x = a.front()'
     returns a reference to the item stored at the head of the list, or
     triggers an error if the list is empty.

`a.rear()'
     returns a reference to the rear of the list, or triggers an error
     if the list is empty.

`x = a.remove_front()'
     deletes and returns the item stored at the head of the list.

`a.del_front()'
     deletes the first element, without returning it.

`a.clear()'
     deletes all items from the list.

`a.ins_after(Pix i, item);'
     inserts item after position i. If i is null, insertion is at the
     front.

`a.del_after(Pix i);'
     deletes the element following i. If i is 0, the first item is
     deleted.

Doubly linked lists
===================

   Class `DLList' supports the following additional operations, as well
as backward traversal via Pixes.

`x = a.remove_rear();'
     deletes and returns the item stored at the rear of the list.

`a.del_rear();'
     deletes the last element, without returning it.

`a.ins_before(Pix i, x)'
     inserts x before the i.

`a.del(Pix& iint dir = 1)'
     deletes the item at the current position, then advances forward if
     dir is positive, else backward.


File: libg++.info,  Node: Vector,  Next: Plex,  Prev: LinkList,  Up: Top

Vector classes
**************

   The files `g++-include/Vec.ccP' and `g++-include/AVec.ccP' provide
pseudo-generic standard array-based vector operations.  The
corresponding header files are `g++-include/Vec.hP' and
`g++-include/AVec.hP'.  Class `Vec' provides operations suitable for
any base class that includes an equality operator. Subclass `AVec'
provides additional arithmetic operations suitable for base classes
that include the full complement of arithmetic operators.

   `Vecs' are constructed and assigned by copying. Thus, they should
normally be passed by reference in applications programs.

   Several mapping functions are provided that allow programmers to
specify operations on vectors as a whole.

   For illustrative purposes assume that classes `intVec' and `intAVec'
have been generated via `genclass'.

Constructors and assignment
===========================

`intVec a;'
     declares a to be an empty vector. Its size may be changed via
     resize.

`intVec a(10);'
     declares a to be an uninitialized vector of ten elements (numbered
     0-9).

`intVec b(6, 0);'
     declares b to be a vector of six elements, all initialized to
     zero. Any value can be used as the initial fill argument.

`a = b;'
     Copies b to a. a is resized to be the same as b.

`a = b.at(2, 4)'
     constructs a from the 4 elements of b starting at b[2].

   Assume declarations of `intVec a, b, c' and `int i, x' in the
following.

Status and access
=================

`a.capacity();'
     returns the number of elements that can be held in a.

`a.resize(20);'
     sets a's length to 20. All elements are unchanged, except that if
     the new size is smaller than the original, than trailing elements
     are deleted, and if greater, trailing elements are uninitialized.

`a[i];'
     returns a reference to the i'th element of a, or produces an error
     if i is out of range.

`a.elem(i)'
     returns a reference to the i'th element of a. Unlike the `[]'
     operator, i is not checked to ensure that it is within range.

`a == b;'
     returns true if a and b contain the same elements in the same
     order.

`a != b;'
     is the converse of a == b.

Constructive operations
=======================

`c = concat(a, b);'
     sets c to the new vector constructed from all of the elements of a
     followed by all of b.

`c = map(f, a);'
     sets c to the new vector constructed by applying int function
     f(int) to each element of a.

`c = merge(a, b, f);'
     sets c to the new vector constructed by merging the elements of
     ordered vectors a and b using ordering (comparison) function f.

`c = combine(f, a, b);'
     sets c to the new vector constructed by applying int function
     f(int, int) to successive pairs of a and b. The result has length
     the shorter of a and b.

`c = reverse(a)'
     sets c to a, with elements in reverse order.

Destructive operations
======================

`a.reverse();'
     reverses a in-place.

`a.sort(f)'
     sorts a in-place using comparison function f. The sorting method
     is a variation of the quicksort functions supplied with GNU emacs.

`a.fill(0, 4, 2)'
     fills the 2 elements starting at a[4] with zero.

Other operations
================

`a.apply(f)'
     applies function f to each element in a.

`x = a.reduce(f, base)'
     accumulates the results of applying function f to successive
     elements of a starting with base.

`a.index(int targ);'
     returns the index of the leftmost occurrence of the target, or -1,
     if it does not occur.

`a.error(char* msg)'
     invokes the error handler. The default version prints the error
     message, then aborts.

AVec operations.
================

   AVecs provide additional arithmetic operations.  All vector-by-vector
operators generate an error if the vectors are not the same length. The
following operations are provided, for `AVecs a, b' and base element
(scalar) `s'.

`a = b;'
     Copies b to a. a and b must be the same size.

`a = s;'
     fills all elements of a with the value s. a is not resized.

`a + s; a - s; a * s; a / s'
     adds, subtracts, multiplies, or divides each element of a with the
     scalar.

`a += s; a -= s; a *= s; a /= s;'
     adds, subtracts, multiplies, or divides the scalar into a.

`a + b; a - b; product(a, b), quotient(a, b)'
     adds, subtracts, multiplies, or divides corresponding elements of
     a and b.

`a += b; a -= b; a.product(b); a.quotient(b);'
     adds, subtracts, multiplies, or divides corresponding elements of
     b into a.

`s = a * b;'
     returns the inner (dot) product of a and b.

`x = a.sum();'
     returns the sum of elements of a.

`x = a.sumsq();'
     returns the sum of squared elements of a.

`x = a.min();'
     returns the minimum element of a.

`x = a.max();'
     returns the maximum element of a.

`i = a.min_index();'
     returns the index of the minimum element of a.

`i = a.max_index();'
     returns the index of the maximum element of a.

     Note that it is possible to apply vector versions other arithmetic
     operators via the mapping functions. For example, to set vector b
     to the  cosines of doubleVec a, use `b = map(cos, a);'.  This is
     often more efficient than performing the operations in an
     element-by-element fashion.


File: libg++.info,  Node: Plex,  Next: Stack,  Prev: Vector,  Up: Top

Plex classes
************

   A "Plex" is a kind of array with the following properties:

   * Plexes may have arbitrary upper and lower index bounds. For example
     a Plex may be declared to run from indices -10 .. 10.

   * Plexes may be dynamically expanded at both the lower and upper
     bounds of the array in steps of one element.

   * Only elements that have been specifically initialized or added may
     be accessed.

   * Elements may be accessed via indices. Indices are always checked
     for validity at run time.  Plexes may be traversed via simple
     variations of standard array indexing loops.

   * Plex elements may be accessed and traversed via Pixes.

   * Plex-to-Plex assignment and related operations on entire Plexes
     are supported.

   * Plex classes contain methods to help programmers check the validity
     of indexing and pointer operations.

   * Plexes form "natural" base classes for many restricted-access data
     structures relying on logically contiguous indices, such as
     array-based stacks and queues.

   * Plexes are implemented as pseudo-generic classes, and must be
     generated via the `genclass' utility.

   Four subclasses of Plexes are supported: A `FPlex' is a Plex that
may only grow or shrink within declared bounds; an `XPlex' may
dynamically grow or shrink without bounds; an `RPlex' is the same as an
`XPlex' but better supports indexing with poor locality of reference; a
`MPlex' may grow or shrink, and additionally allows the logical
deletion and restoration of elements. Because these classes are virtual
subclasses of the "abstract" class `Plex', it is possible to write user
code such as `void f(Plex& a) ...' that operates on any kind of Plex.
However, as with nearly any virtual class, specifying the particular
Plex class being used results in more efficient code.

   Plexes are implemented as a linked list of `IChunks'.  Each chunk
contains a part of the array. Chunk sizes may be specified within Plex
constructors.  Default versions also exist, that use a `#define'd'
default.  Plexes grow by filling unused space in existing chunks, if
possible, else, except for FPlexes, by adding another chunk.  Whenever
Plexes grow by a new chunk, the default element constructors (i.e.,
those which take no arguments) for all chunk elements are called at
once. When Plexes shrink, destructors for the elements are not called
until an entire chunk is freed. For this reason, Plexes (like C++
arrays) should only be used for elements with default constructors and
destructors that have no side effects.

   Plexes may be indexed and used like arrays, although traversal
syntax is slightly different. Even though Plexes maintain elements in
lists of chunks, they are implemented so that iteration and other
constructs that maintain locality of reference require very little
overhead over that for simple array traversal Pix-based traversal is
also supported. For example, for a plex, p, of ints, the following
traversal methods could be used.

     for (int i = p.low(); i < p.fence(); p.next(i)) use(p[i]);
     for (int i = p.high(); i > p.ecnef(); p.prev(i)) use(p[i]);
     for (Pix t = p.first(); t != 0; p.next(t)) use(p(i));
     for (Pix t = p.last(); t != 0; p.prev(t)) use(p(i));

   Except for MPlexes, simply using `++i' and `--i' works just as well
as `p.next(i)' and `p.prev(i)' when traversing by index.  Index-based
traversal is generally a bit faster than Pix-based traversal.

   `XPlexes' and `MPlexes' are less than optimal for applications in
which widely scattered elements are indexed, as might occur when using
Plexes as hash tables or "manually" allocated linked lists.  In such
applications, `RPlexes' are often preferable. `RPlexes' use a secondary
chunk index table that requires slightly greater, but entirely uniform
overhead per index operation.

   Even though they may grow in either direction, Plexes are normally
constructed so that their "natural" growth direction is upwards, in
that default chunk construction leaves free space, if present, at the
end of the plex. However, if the chunksize arguments to constructors
are negative, they leave space at the beginning.

   All versions of Plexes support the following basic capabilities.
(letting `Plex' stand for the type name constructed via the genclass
utility (e.g., `intPlex', `doublePlex')).  Assume declarations of `Plex
p, q', `int i, j', base element `x', and Pix `pix'.

`Plex p;'
     Declares p to be an initially zero-sized Plex with low index of
     zero, and the default chunk size. For FPlexes, chunk sizes
     represent maximum sizes.

`Plex p(int size);'
     Declares p to be an initially zero-sized Plex with low index of
     zero, and the indicated chunk size. If size is negative, then the
     Plex is created with free space at the beginning of the Plex,
     allowing more efficient add_low() operations. Otherwise, it leaves
     space at the end.

`Plex p(int low, int size);'
     Declares p to be an initially zero-sized Plex with low index of
     low, and the indicated chunk size.

`Plex p(int low, int high, Base initval, int size = 0);'
     Declares p to be a Plex with indices from low to high, initially
     filled with initval, and the indicated chunk size if specified,
     else the default or (high - low + 1), whichever is greater.

`Plex q(p);'
     Declares q to be a copy of p.

`p = q;'
     Copies Plex q into p, deleting its previous contents.

`p.length()'
     Returns the number of elements in the Plex.

`p.empty()'
     Returns true if Plex p contains no elements.

`p.full()'
     Returns true if Plex p cannot be expanded. This always returns
     false for XPlexes and MPlexes.

`p[i]'
     Returns a reference to the i'th element of p. An exception (error)
     occurs if i is not a valid index.

`p.valid(i)'
     Returns true if i is a valid index into Plex p.

`p.low(); p.high();'
     Return the minimum (maximum) valid index of the Plex, or the high
     (low) fence if the plex is empty.

`p.ecnef(); p.fence();'
     Return the index one position past the minimum (maximum) valid
     index.

`p.next(i); i = p.prev(i);'
     Set i to the next (previous) index. This index may not be within
     bounds.

`p(pix)'
     returns a reference to the item at Pix pix.

`pix = p.first(); pix = p.last();'
     Return the minimum (maximum) valid Pix of the Plex, or 0 if the
     plex is empty.

`p.next(pix); p.prev(pix);'
     set pix to the next (previous) Pix, or 0 if there is none.

`p.owns(pix)'
     Returns true if the Plex contains the element associated with pix.

`p.Pix_to_index(pix)'
     If pix is a valid Pix to an element of the Plex, returns its
     corresponding index, else raises an exception.

`ptr = p.index_to_Pix(i)'
     if i is a valid index, returns a the corresponding Pix.

`p.low_element(); p.high_element();'
     Return a reference to the element at the minimum (maximum) valid
     index.  An exception occurs if the Plex is empty.

`p.can_add_low();  p.can_add_high();'
     Returns true if the plex can be extended one element downward
     (upward).  These always return true for XPlex and MPlex.

`j = p.add_low(x); j = p.add_high(x);'
     Extend the Plex by one element downward (upward). The new minimum
     (maximum) index is returned.

`j = p.del_low(); j = p.del_high()'
     Shrink the Plex by one element on the low (high) end. The new
     minimum (maximum) element is returned. An exception occurs if the
     Plex is empty.

`p.append(q);'
     Append all of Plex q to the high side of p.

`p.prepend(q);'
     Prepend all of q to the low side of p.

`p.clear()'
     Delete all elements, resetting p to a zero-sized Plex.

`p.reset_low(i);'
     Resets p to be indexed starting at low() = i. For example.  if p
     were initially declared via `Plex p(0, 10, 0)', and then
     re-indexed via `p.reset_low(5)', it could then be indexed from
     indices 5 .. 14.

`p.fill(x)'
     sets all p[i] to x.

`p.fill(x, lo, hi)'
     sets all of p[i] from lo to hi, inclusive, to x.

`p.reverse()'
     reverses p in-place.

`p.chunk_size()'
     returns the chunk size used for the plex.

`p.error(const char * msg)'
     calls the resettable error handler.

   MPlexes are plexes with bitmaps that allow items to be logically
deleted and restored. They behave like other plexes, but also support
the following additional and modified capabilities:

`p.del_index(i); p.del_Pix(pix)'
     logically deletes p[i] (p(pix)). After deletion, attempts to
     access p[i] generate a error. Indexing via low(), high(), prev(),
     and next() skip the element. Deleting an element never changes the
     logical bounds of the plex.

`p.undel_index(i); p.undel_Pix(pix)'
     logically undeletes p[i] (p(pix)).

`p.del_low(); p.del_high()'
     Delete the lowest (highest) undeleted element, resetting the
     logical bounds of the plex to the next lowest (highest) undeleted
     index. Thus, MPlex del_low() and del_high() may shrink the bounds
     of the plex by more than one index.

`p.adjust_bounds()'
     Resets the low and high bounds of the Plex to the indexes of the
     lowest and highest actual undeleted elements.

`int i = p.add(x)'
     Adds x in an unused index, if possible, else performs add_high.

`p.count()'
     returns the number of valid (undeleted) elements.

`p.available()'
     returns the number of available (deleted) indices.

`int i = p.unused_index()'
     returns the index of some deleted element, if one exists, else
     triggers an error. An unused element may be reused via undel.

`pix = p.unused_Pix()'
     returns the pix of some deleted element, if one exists, else 0.
     An unused element may be reused via undel.


File: libg++.info,  Node: Stack,  Next: Queue,  Prev: Plex,  Up: Top

Stacks
******

   Stacks are declared as an "abstract" class. They are currently
implemented in any of three ways.

`VStack'
     implement fixed sized stacks via arrays.

`XPStack'
     implement dynamically-sized stacks via XPlexes.

`SLStack'
     implement dynamically-size stacks via linked lists.

   All possess the same capabilities. They differ only in constructors.
VStack constructors require a fixed maximum capacity argument.  XPStack
constructors optionally take a chunk size argument.  SLStack
constructors take no argument.

   Assume the declaration of a base element `x'.

`Stack s;  or Stack s(int capacity)'
     declares a Stack.

`s.empty()'
     returns true if stack s is empty.

`s.full()'
     returns true if stack s is full. XPStacks and SLStacks never
     become full.

`s.length()'
     returns the current number of elements in the stack.

`s.push(x)'
     pushes x on stack s.

`x = s.pop()'
     pops and returns the top of stack

`s.top()'
     returns a reference to the top of stack.

`s.del_top()'
     pops, but does not return the top of stack. When large items are
     held on the stack it is often a good idea to use `top()' to
     inspect and use the top of stack, followed by a `del_top()'

`s.clear()'
     removes all elements from the stack.


File: libg++.info,  Node: Queue,  Next: Deque,  Prev: Stack,  Up: Top

Queues
******

   Queues are declared as an "abstract" class. They are currently
implemented in any of three ways.

`VQueue'
     implement fixed sized Queues via arrays.

`XPQueue'
     implement dynamically-sized Queues via XPlexes.

`SLQueue'
     implement dynamically-size Queues via linked lists.

   All possess the same capabilities; they differ only in constructors.
`VQueue' constructors require a fixed maximum capacity argument.
`XPQueue' constructors optionally take a chunk size argument.
`SLQueue' constructors take no argument.

   Assume the declaration of a base element `x'.

`Queue q; or Queue q(int capacity);'
     declares a queue.

`q.empty()'
     returns true if queue q is empty.

`q.full()'
     returns true if queue q is full. XPQueues and SLQueues are never
     full.

`q.length()'
     returns the current number of elements in the queue.

`q.enq(x)'
     enqueues x on queue q.

`x = q.deq()'
     dequeues and returns the front of queue

`q.front()'
     returns a reference to the front of queue.

`q.del_front()'
     dequeues, but does not return the front of queue

`q.clear()'
     removes all elements from the queue.


File: libg++.info,  Node: Deque,  Next: PQ,  Prev: Queue,  Up: Top

Double ended Queues
*******************

   Deques are declared as an "abstract" class. They are currently
implemented in two ways.

`XPDeque'
     implement dynamically-sized Deques via XPlexes.

`DLDeque'
     implement dynamically-size Deques via linked lists.

   All possess the same capabilities. They differ only in constructors.
XPDeque constructors optionally take a chunk size argument.  DLDeque
constructors take no argument.

   Double-ended queues support both stack-like and queue-like
capabilities:

   Assume the declaration of a base element `x'.

`Deque d; or Deque d(int initial_capacity)'
     declares a deque.

`d.empty()'
     returns true if deque d is empty.

`d.full()'
     returns true if deque d is full.  Always returns false in current
     implementations.

`d.length()'
     returns the current number of elements in the deque.

`d.enq(x)'
     inserts x at the rear of deque d.

`d.push(x)'
     inserts x at the front of deque d.

`x = d.deq()'
     dequeues and returns the front of deque

`d.front()'
     returns a reference to the front of deque.

`d.rear()'
     returns a reference to the rear of the deque.

`d.del_front()'
     deletes, but does not return the front of deque

`d.del_rear()'
     deletes, but does not return the rear of the deque.

`d.clear()'
     removes all elements from the deque.


File: libg++.info,  Node: PQ,  Next: Set,  Prev: Deque,  Up: Top

Priority Queue class prototypes.
********************************

   Priority queues maintain collections of objects arranged for fast
access to the least element.

   Several prototype implementations of priority queues are supported.

`XPPQs'
     implement 2-ary heaps via XPlexes.

`SplayPQs'
     implement  PQs via Sleator and Tarjan's (JACM 1985) splay trees.
     The algorithms use a version of "simple top-down splaying"
     (described on page 669 of the article).  The simple-splay
     mechanism for priority queue functions is loosely based on the one
     used by D. Jones in the C splay tree functions available from
     volume 14 of the uunet.uu.net archives.

`PHPQs'
     implement pairing heaps (as described by Fredman and Sedgewick in
     `Algorithmica', Vol 1, p111-129).  Storage for heap elements is
     managed via an internal freelist technique. The constructor allows
     an initial capacity estimate for freelist space.  The storage is
     automatically expanded if necessary to hold new items. The
     deletion technique is a fast "lazy deletion" strategy that marks
     items as deleted, without reclaiming space until the items come to
     the top of the heap.

   All PQ classes support the following operations, for some PQ class
`Heap', instance `h', `Pix ind', and base class variable `x'.

`h.empty()'
     returns true if there are no elements in the PQ.

`h.length()'
     returns the number of elements in h.

`ind = h.enq(x)'
     Places x in the PQ, and returns its index.

`x = h.deq()'
     Dequeues the minimum element of the PQ into x, or generates an
     error if the PQ is empty.

`h.front()'
     returns a reference to the minimum element.

`h.del_front()'
     deletes the minimum element.

`h.clear();'
     deletes all elements from h;

`h.contains(x)'
     returns true if x is in h.

`h(ind)'
     returns a reference to the item indexed by ind.

`ind = h.first()'
     returns the Pix of first item in the PQ or 0 if empty.  This need
     not be the Pix of the least element.

`h.next(ind)'
     advances ind to the Pix of next element, or 0 if there are no more.

`ind = h.seek(x)'
     Sets ind to the Pix of x, or 0 if x is not in h.

`h.del(ind)'
     deletes the item with Pix ind.


File: libg++.info,  Node: Set,  Next: Bag,  Prev: PQ,  Up: Top

Set class prototypes
********************

   Set classes maintain unbounded collections of items containing no
duplicate elements.

   These are currently implemented in several ways, differing in
representation strategy, algorithmic efficiency, and appropriateness for
various tasks. (Listed next to each are average (followed by worst-case,
if different) time complexities for [a] adding, [f] finding (via seek,
contains), [d] deleting, elements, and [c] comparing (via ==, <=) and
[m] merging (via |=, -=, &=) sets).

`XPSets'
     implement unordered sets via XPlexes.  ([a O(n)], [f O(n)], [d
     O(n)], [c O(n^2)] [m O(n^2)]).

`OXPSets'
     implement ordered sets via XPlexes.  ([a O(n)], [f O(log n)], [d
     O(n)], [c O(n)] [m O(n)]).

`SLSets'
     implement unordered sets via linked lists ([a O(n)], [f O(n)], [d
     O(n)], [c O(n^2)] [m O(n^2)]).

`OSLSets'
     implement ordered sets via linked lists ([a O(n)], [f O(n)], [d
     O(n)], [c O(n)] [m O(n)]).

`AVLSets'
     implement ordered sets via threaded AVL trees ([a O(log n)], [f
     O(log n)], [d O(log n)], [c O(n)] [m O(n)]).

`BSTSets'
     implement ordered sets via binary search trees. The trees may be
     manually rebalanced via the O(n) `balance()' member function.  ([a
     O(log n)/O(n)], [f O(log n)/O(n)], [d O(log n)/O(n)], [c O(n)] [m
     O(n)]).

`SplaySets'
     implement ordered sets via Sleator and Tarjan's (JACM 1985) splay
     trees. The algorithms use a version of "simple top-down splaying"
     (described on page 669 of the article).  (Amortized: [a O(log n)],
     [f O(log n)], [d O(log n)], [c O(n)] [m O(n log n)]).

`VHSets'
     implement unordered sets via hash tables.  The tables are
     automatically resized when their capacity is exhausted.  ([a
     O(1)/O(n)], [f O(1)/O(n)], [d O(1)/O(n)], [c O(n)/O(n^2)] [m
     O(n)/O(n^2)]).

`VOHSets'
     implement unordered sets via ordered hash tables The tables are
     automatically resized when their capacity is exhausted.  ([a
     O(1)/O(n)], [f O(1)/O(n)], [d O(1)/O(n)], [c O(n)/O(n^2)] [m
     O(n)/O(n^2)]).

`CHSets'
     implement unordered sets via chained hash tables.  ([a O(1)/O(n)],
     [f O(1)/O(n)], [d O(1)/O(n)], [c O(n)/O(n^2)] [m O(n)/O(n^2)]).

   The different implementations differ in whether their constructors
require an argument specifying their initial capacity. Initial
capacities are required for plex and hash table based Sets.  If none is
given `DEFAULT_INITIAL_CAPACITY' (from `<T>defs.h') is used.

   Sets support the following operations, for some class `Set',
instances `a' and `b', `Pix ind', and base element `x'. Since all
implementations are virtual derived classes of the `<T>Set' class, it
is possible to mix and match operations across different
implementations, although, as usual, operations are generally faster
when the particular classes are specified in functions operating on
Sets.

   Pix-based operations are more fully described in the section on
Pixes. *Note Pix::

`Set a; or Set a(int initial_size);'
     Declares a to be an empty Set. The second version is allowed in
     set classes that require initial capacity or sizing specifications.

`a.empty()'
     returns true if a is empty.

`a.length()'
     returns the number of elements in a.

`Pix ind = a.add(x)'
     inserts x into a, returning its index.

`a.del(x)'
     deletes x from a.

`a.clear()'
     deletes all elements from a;

`a.contains(x)'
     returns true if x is in a.

`a(ind)'
     returns a reference to the item indexed by ind.

`ind = a.first()'
     returns the Pix of first item in the set or 0 if the Set is empty.
     For ordered Sets, this is the Pix of the least element.

`a.next(ind)'
     advances ind to the Pix of next element, or 0 if there are no more.

`ind = a.seek(x)'
     Sets ind to the Pix of x, or 0 if x is not in a.

`a == b'
     returns true if a and b contain all the same elements.

`a != b'
     returns true if a and b do not contain all the same elements.

`a <= b'
     returns true if a is a subset of b.

`a |= b'
     Adds all elements of b to a.

`a -= b'
     Deletes all elements of b from a.

`a &= b'
     Deletes all elements of a not occurring in b.


File: libg++.info,  Node: Bag,  Next: Map,  Prev: Set,  Up: Top

Bag class prototypes
********************

   Bag classes maintain unbounded collections of items potentially
containing  duplicate elements.

   These are currently implemented in several ways, differing in
representation strategy, algorithmic efficiency, and appropriateness for
various tasks. (Listed next to each are average (followed by worst-case,
if different) time complexities for [a] adding, [f] finding (via seek,
contains), [d] deleting elements).

`XPBags'
     implement unordered Bags via XPlexes.  ([a O(1)], [f O(n)], [d
     O(n)]).

`OXPBags'
     implement ordered Bags via XPlexes.  ([a O(n)], [f O(log n)], [d
     O(n)]).

`SLBags'
     implement unordered Bags via linked lists ([a O(1)], [f O(n)], [d
     O(n)]).

`OSLBags'
     implement ordered Bags via linked lists ([a O(n)], [f O(n)], [d
     O(n)]).

`SplayBags'
     implement ordered Bags via Sleator and Tarjan's (JACM 1985) splay
     trees. The algorithms use a version of "simple top-down splaying"
     (described on page 669 of the article).  (Amortized: [a O(log n)],
     [f O(log n)], [d O(log n)]).

`VHBags'
     implement unordered Bags via hash tables.  The tables are
     automatically resized when their capacity is exhausted.  ([a
     O(1)/O(n)], [f O(1)/O(n)], [d O(1)/O(n)]).

`CHBags'
     implement unordered Bags via chained hash tables.  ([a O(1)/O(n)],
     [f O(1)/O(n)], [d O(1)/O(n)]).

   The implementations differ in whether their constructors require an
argument to specify their initial capacity. Initial capacities are
required for plex and hash table based Bags.  If none is given
`DEFAULT_INITIAL_CAPACITY' (from `<T>defs.h') is used.

   Bags support the following operations, for some class `Bag',
instances `a' and `b', `Pix ind', and base element `x'. Since all
implementations are virtual derived classes of the `<T>Bag' class, it
is possible to mix and match operations across different
implementations, although, as usual, operations are generally faster
when the particular classes are specified in functions operating on
Bags.

   Pix-based operations are more fully described in the section on
Pixes. *Note Pix::

`Bag a; or Bag a(int initial_size)'
     Declares a to be an empty Bag. The second version is allowed in
     Bag classes that require initial capacity or sizing specifications.

`a.empty()'
     returns true if a is empty.

`a.length()'
     returns the number of elements in a.

`ind = a.add(x)'
     inserts x into a, returning its index.

`a.del(x)'
     deletes one occurrence of x from a.

`a.remove(x)'
     deletes all occurrences of x from a.

`a.clear()'
     deletes all elements from a;

`a.contains(x)'
     returns true if x is in a.

`a.nof(x)'
     returns the number of occurrences of x in a.

`a(ind)'
     returns a reference to the item indexed by ind.

`int = a.first()'
     returns the Pix of first item in the Bag or 0 if the Bag is empty.
     For ordered Bags, this is the Pix of the least element.

`a.next(ind)'
     advances ind to the Pix of next element, or 0 if there are no more.

`ind = a.seek(x, Pix from = 0)'
     Sets ind to the Pix of the next occurrence x, or 0 if there are
     none.  If from is 0, the first occurrence is returned, else the
     following from.


File: libg++.info,  Node: Map,  Next: GetOpt,  Prev: Bag,  Up: Top

Map Class Prototypes
********************

   Maps support associative array operations (insertion, deletion, and
membership of records based on an associated key). They require the
specification of two types, the key type and the contents type.

   These are currently implemented in several ways, differing in
representation strategy, algorithmic efficiency, and appropriateness for
various tasks. (Listed next to each are average (followed by worst-case,
if different) time complexities for [a] accessing (via op [],
contains), [d] deleting elements).

`AVLMaps'
     implement ordered Maps via threaded AVL trees ([a O(log n)], [d
     O(log n)]).

`RAVLMaps'
     Similar, but also maintain ranking information, used via
     `ranktoPix(int r)', that returns the `Pix' of the item at rank r,
     and `rank(key)' that returns the rank of the corresponding item.
     ([a O(log n)], [d O(log n)]).

`SplayMaps'
     implement ordered Maps via Sleator and Tarjan's (JACM 1985) splay
     trees. The algorithms use a version of "simple top-down splaying"
     (described on page 669 of the article).  (Amortized: [a O(log n)],
     [d O(log n)]).

`VHMaps'
     implement unordered Maps via hash tables.  The tables are
     automatically resized when their capacity is exhausted.  ([a
     O(1)/O(n)], [d O(1)/O(n)]).

`CHMaps'
     implement unordered Maps via chained hash tables.  ([a O(1)/O(n)],
     [d O(1)/O(n)]).

   The different implementations differ in whether their constructors
require an argument specifying their initial capacity. Initial
capacities are required for hash table based Maps.  If none is given
`DEFAULT_INITIAL_CAPACITY' (from `<T>defs.h') is used.

   All Map classes share the following operations (for some Map class,
`Map' instance `d', `Pix ind' and key variable `k', and contents
variable `x').

   Pix-based operations are more fully described in the section on
Pixes. *Note Pix::

`Map d(x);  Map d(x, int initial_capacity)'
     Declare d to be an empty Map. The required argument, x, specifies
     the default contents, i.e., the contents of an otherwise
     uninitialized location. The second version, specifying initial
     capacity is allowed for Maps with an initial capacity argument.

`d.empty()'
     returns true if d contains no items.

`d.length()'
     returns the number of items in d.

`d[k]'
     returns a reference to the contents of item with key k. If no such
     item exists, it is installed with the default contents.  Thus d[k]
     = x installs x, and x = d[k] retrieves it.

`d.contains(k)'
     returns true if an item with key field k exists in d.

`d.del(k)'
     deletes the item with key k.

`d.clear()'
     deletes all items from the table.

`x = d.dflt()'
     returns the default contents.

`k = d.key(ind)'
     returns a reference to the key at Pix ind.

`x = d.contents(ind)'
     returns a reference to the contents at Pix ind.

`ind = d.first()'
     returns the Pix of the first element in d, or 0 if d is empty.

`d.next(ind)'
     advances ind to the next element, or 0 if there are no more.

`ind = d.seek(k)'
     returns the Pix of element with key k, or 0 if k is not in d.


File: libg++.info,  Node: GetOpt,  Next: Projects,  Prev: Map,  Up: Top

C++ version of the GNU getopt function
**************************************

   The GetOpt class provides an efficient and structured mechanism for
processing command-line options from an application program.  The sample
program fragment below illustrates a typical use of the GetOpt class
for some hypothetical application program:

     #include <stdio.h>
     #include <GetOpt.h>
     //...
     int debug_flag, compile_flag, size_in_bytes;
     
     int
     main (int argc, char **argv)
     {
       // Invokes ctor `GetOpt (int argc, char **argv,
       //                       char *optstring);'
       GetOpt getopt (argc, argv, "dcs:");
       int option_char;
     
       // Invokes member function `int operator ()(void);'
       while ((option_char = getopt ()) != EOF)
         switch (option_char)
           {
              case 'd': debug_flag = 1; break;
              case 'c': compile_flag = 1; break;
              case 's': size_in_bytes = atoi (getopt.optarg); break;
              case '?': fprintf (stderr,
                                 "usage: %s [dcs<size>]\n", argv[0]);
           }
     }

   Unlike the C library version, the libg++ GetOpt class uses its
constructor to initialize class data members containing the argument
count, argument vector, and the option string.  This simplifies the
interface for each subsequent call to member function `int operator
()(void)'.

   The C version, on the other hand, uses hidden static variables to
retain the option string and argument list values between calls to
`getopt'.  This complicates the `getopt' interface since the argument
count, argument vector, and option string must be passed as parameters
for each invocation.  For the C version, the loop in the previous
example becomes:

       while ((option_char = getopt (argc, argv, "dcs:")) != EOF)
         // ...

   which requires extra overhead to pass the parameters for every call.

   Along with the GetOpt constructor and `int operator ()(void)', the
other relevant elements of class GetOpt are:

`char *optarg'
     Used for communication from `operator ()(void)' to the caller.
     When `operator ()(void)' finds an option that takes an argument,
     the argument value is stored here.

`int optind'
     Index in `argv' of the next element to be scanned.  This is used
     for communication to and from the caller and for communication
     between successive calls to `operator ()(void)'.

     When `operator ()(void)' returns EOF, this is the index of the
     first of the non-option elements that the caller should itself
     scan.

     Otherwise, `optind' communicates from one call to the next how much
     of `argv' has been scanned so far.

   The libg++ version of GetOpt acts like standard UNIX `getopt' for
the calling routine, but it behaves differently for the user, since it
allows the user to intersperse the options with the other arguments.

   As GetOpt works, it permutes the elements of `argv' so that, when it
is done, all the options precede everything else.  Thus all application
programs are extended to handle flexible argument order.

   Setting the environment variable _POSIX_OPTION_ORDER disables
permutation.  Then the behavior is completely standard.

