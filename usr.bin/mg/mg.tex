%\batchmode %be nice to fellow VAXers
\hoffset=0in \voffset=0in %correct dvi2ln3 bug
\documentstyle[11pt,titlepage,dvidoc]{report}
%\pagestyle{headings} %not sure on this one yet
%\parindent=0in
\textwidth=5.5in
%\oddsidemargin=0.25in

% definitions for DEFINE environment
\newlength{\lblwide}
\newcommand{\resetmarg}{\settowidth{\leftmargin}{\makebox[\lblwide]{}\makebox[\labelsep]{}}}
\newcommand{\resetlbl}{\setlength{\labelwidth}{\lblwide}} 
\newenvironment{define}[1]{\begin{list}{}{\settowidth{\lblwide}{\bf #1}\resetmarg \resetlbl}}{\end{list}}

% definitions for fn environment

\newcommand{\fname}[3]{\hspace{1em}\\{\tt #1}\index{#1} {\it #2}\hfill{\tt #3}}
\newcommand{\fmore}[3]{\\{\tt #1}\index{#1} {\it #2}\hfill{\tt #3}}
\newcommand{\fbody}{\\[0.5em]}

% definitions for making the index
\newcommand{\indexentry}[2]{\item {\tt #1} \dotfill\  #2}


\setcounter{secnumdepth}{5} %personal preference
\setcounter{tocdepth}{5} %personal preference
\author{Sandra J. Loosemore}
\title{The MG Reference Manual \\ Release MG2A}
\date{\vspace{1.5in}
Copyright \copyright 1987, Sandra J. Loosemore \\[0.5em]
\parbox{5 in}{This document, or sections of this document, may be freely
redistributed provided that the copyright notice and the following disclaimer
remain intact:  The author bears no responsibilities for errors in
this document or the software it describes; and shall not be held liable
for any indirect, incidental, or consequential damages.}}

\makeindex %usually not

\begin{document}
\maketitle

\tableofcontents

\chapter{Introduction}

MG is a small, fast, and portable Emacs-style text editor intended to
be used by people who can't run a real Emacs for one reason or another
--- as their main editor on smaller machines with limited memory or
file space, or as a ``quick-start'' editor on larger systems, useful
for composing short mail messages and the like. 

We've made MG compatible with GNU Emacs because that is the ``big'',
full-featured editor that many of us use regularly and are most
familiar with.  GNU Emacs is the creation of Richard M. Stallman, who
was also the author of the original Emacs editor.  However, MG is not
associated in any way with the GNU project, and the MG authors
individually may or may not agree with the opinions expressed by
Richard Stallman and the GNU project. 

MG is largely public domain.  You can use, modify, and redistribute MG
as you like.  A few modules, however, are copyrighted; specifically,
the regular expression code, the VMS termcap routines, and the Amiga
support code.  Look at the source code for the exact copyright
restrictions. 

There are several other editors in existence which call themselves
MicroEmacs.  The original public domain version was written by Dave
Conroy and circulated as version 1.6.  Derived from this, there is
another PD version by Dave Conroy numbered v30; a significantly larger
PD version by Daniel Lawrence which is now up to version 3.9; at least
one proprietary implementation; an implementation for the Atari ST
with an integrated command shell, by Prabhaker Mateti; and probably
others that we don't know about.

MG is derived from the v30 MicroEmacs, with key bindings, command
names, and general functionality made more compatible with GNU Emacs.
Like v30, MG is fairly small and quite robust.  We have generally
resisted the temptation to overfeaturize.  Some features which are
large and complex are flagged for conditional compilation.

Many people have contributed their time to developing, improving, and
porting MG.  Mike Meyer, Mic Kaczmarczik, and Bob Larson deserve 
particular mention for their efforts.  

Questions, suggestions, and offers of help should be addressed to:

\begin{verbatim}
        mg-developers@ucbvax.berkeley.edu   (ARPA)
        ucbvax!mg-developers                (UUCP)
\end{verbatim}

\section{Implementations of MG}

MG runs on many different kinds of hardware under many different 
operating systems.  Currently, these include:

\begin{itemize}

\item 4.2 and 4.3 BSD Unix (including Ultrix-32)
\item System V Unix
\item VAX/VMS
\item Primos
\item OS9/68k
\item Amiga
\item Atari ST
\item MS-DOS

\end{itemize}

This document describes release MG2A.  When we talk of different
versions of MG in this manual, the term {\em version\/} is used to
refer to the different support MG provides for the various machines
and operating systems it runs under, not to different releases of MG
itself.  For example, we might speak of how the VMS version of MG
differs from the Unix version.

As mentioned above, some MG commands may not be implemented in all
versions; these are noted in the documentation.  Some versions of MG
also support features (such as mouse handling) that are not described
here.

\section{A Note on Character Sets}

MG uses the 128-character ASCII character set, and provides support for
8-bit characters.  Whether the particular version of MG that you are running
knows about extended character sets depends on whether your terminal and
the host operating system know about them.  Moreover, since there is no
standard 8-bit character set, the same character codes will probably
give different glyphs on different systems.  Most versions of MG use
the DEC multinational character set.

\section{Notation and Conventions}

In this manual, commands and other things that must be typed in 
literally are indicated in a typewriter font, like {\tt next-line}.
Placeholders such as command argument names use an italic font.

The terms {\em command\/} and {\em function\/} are synonymous.  We often
speak of a command being bound to a particular {\em key\/}, although you 
may actually have to type more than one character to form a single key.
Most commands are bound to keys with {\em control\/} and {\em meta\/} 
modifiers.

To type a control character, use the control key on your
keyboard like a shift key:  hold down the control key while typing the
character.  In this manual, we will indicate control characters like
\verb"C-x" --- here, typing the character ``x'' while holding down
the control key.

Some keyboards also have a meta key that works like the control
key.  (It may be labelled something else;  on the Atari ST, for example,
the key marked  ``Alternate'' is the meta key.)  If your keyboard doesn't
have a meta key, don't panic.  You can also use the escape key as a meta
prefix; first type the escape, and {\em then\/} the character.  Meta
characters will be indicated as \verb"M-x".

Besides the meta prefix, two other characters are used as prefixes:
\verb"C-x" and \verb"C-h".  A few keys have special notation:  {\tt SPC} is
the space character, {\tt DEL} is the delete or rubout character, {\tt RET}
is carriage return, and {\tt ESC} is the escape character.  {\tt NUL} is 
the null character (ASCII 0), which is usually equivalent to either 
\verb"C-SPC" or \verb"C-@".

Uppercase and lowercase characters are generally equivalent in command
keystrokes.

When you run MG from a shell, command line arguments are interpreted as the
names of files you want to {\em visit\/}, or edit.  Each file is 
read into a {\em buffer\/} in memory.  No changes are actually made to 
the file until you ask it to be written out to disk.

Within MG, the large top part of the screen serves as a {\em window\/} into
the buffer being edited.  Below this is the {\em mode line\/}, which 
displays the name of the buffer.  Finally, at the very bottom of the screen,
there is a one-line {\em minibuffer\/} which is used for displaying
messages and answering questions.

MG keeps track of two pointers into each window, the {\em point\/} and the
{\em mark\/}.  The {\em cursor\/} appears at the point in the current
window, and we often speak of moving the cursor rather than of moving the
point.  The text between the point and the mark is referred to as the {\em
region\/}.

Some commands deal with {\em words\/} and {\em paragraphs\/}.
Generally, whitespace and punctuation separate words.  Lines that are
empty or that contain only spaces or tabs separate paragraphs without
being part of a paragraph.  A non-empty line that starts with a space
or tab also begins a new paragraph. 

A number of commands are defined as {\em toggles\/}.  If no prefix argument
is supplied, these commands toggle an action.  The action is turned on if a 
negative or zero argument is supplied, and turned on if a positive argument
is supplied.

\section{Getting Started}

This document is intended primarily as a reference manual.  If you
have never used any Emacs-like text editor before, it is strongly
suggested that you run the on-line tutorial supplied with the MG
distribution, instead of reading this manual.

Do not be put off by the large number of commands described in this
manual!  It is possible to get by with only a handful of basic commands.
Here are the ones that are probably used most frequently:

\begin{define}{\hspace{1in}}
\item[{\tt C-p}\hfill] Move the cursor to the previous line
\item[{\tt C-n}\hfill] Move the cursor to the next line
\item[{\tt C-b}\hfill] Move the cursor backwards
\item[{\tt C-f}\hfill] Move the cursor forwards
\item[{\tt C-v}\hfill] Scroll forwards one screenful
\item[{\tt M-v}\hfill] Scroll backwards one screenful
\item[{\tt M-<}\hfill] Go to the beginning of the buffer
\item[{\tt M->}\hfill] Go to the end of the buffer
\item[{\tt C-a}\hfill] Go to the beginning of the line
\item[{\tt C-e}\hfill] Go to the end of the line
\item[{\tt DEL}\hfill] Delete the previous character
\item[{\tt C-k}\hfill] Kill (delete) to the end of line
\item[{\tt C-y}\hfill] Reinsert killed text.
\item[{\tt C-x C-c}\hfill] Exit MG
\item[{\tt C-x C-s}\hfill] Save the current buffer
\end{define}

\chapter{Using Commands}

\section{Command Arguments}

Some commands require arguments.  For example, if you want to read a
file into a buffer, you must type in the name of the file.  In the
descriptions of commands in this manual, if arguments are required,
they are listed following the command name.

MG prompts for command arguments in the minibuffer.  Within the minibuffer,
the following characters can be used for editing:

\begin{define}{\hspace{1in}}
\item[{\tt DEL, C-h}\hfill] Erase the last character. 
\item[{\tt C-x, C-u}\hfill] Erase the entire input line. 
\item[{\tt C-w}\hfill] Erase to the beginning of the previous word. 
\item[{\tt C-q, $\backslash$}\hfill] Quote the next character typed. 
\item[{\tt RET}\hfill] Signifies that you have completed typing in 
the argument. 
\item[{\tt C-g}\hfill] Abort the command in progress.
\end{define}

\section{Prefix Arguments}

All commands accept an optional numeric prefix argument.  This is
often interpreted as a repetition count.  For example, the function
{\tt next-line}, if given a prefix argument, will move the cursor
forward that many lines; without an argument, it will move the cursor
forward one line.  A few commands behave differently if given a prefix
argument than they do without one, and others ignore the prefix
argument entirely. 

\fname{digit-argument}{}{M-0, M-1, M-2, M-3, M-4, M-5, M-6, M-7, M-8, M-9}
\fmore{negative-argument}{}{M--} 
\fbody One way to specify a command argument is to use the escape key
as a meta prefix, and then type one or more digits.  A dash may be
used for a negative argument.

\fname{universal-argument}{}{C-u}
\fbody Another way to specify a command prefix is to type {\tt C-u}.
Typing one {\tt C-u} is equivalent to a prefix argument of 4, typing
two gives a value of 16, and so on.  In addition, you can type digits
following {\tt C-u} to form a numeric prefix argument.

\section{Aborting}

\fname{keyboard-quit}{}{C-g}
\fbody Typing {\tt C-g} cancels any command.  It is particularly useful
for cancelling a command when MG is prompting for input in the minibuffer.

\section{Extended Commands}

\fname{execute-extended-command}{command}{M-x}
\fbody Commands that are not bound to keys can be executed through 
{\tt execute extended-command}.  If a prefix argument is supplied, it
is passed to the command being executed.


\chapter{Moving the Cursor}

The commands described in this chapter move the cursor (sometimes
called the point or dot) within the current window.  Commands which
set the mark are included here as well.

\fname{backward-char}{}{C-b}
\fbody Moves the cursor backward (left) one character.  If the cursor
is at the left margin, it will be moved to the end of the previous line.

\fname{backward-paragraph}{}{M-[}
\fbody Moves the cursor backwards to the beginning of the current
paragraph, or to the beginning of the previous paragraph if the cursor
is already at the beginning of a paragraph.

\fname{backward-word}{}{M-b}
\fbody Moves the cursor backwards to the beginning of the current word,
or to the beginning of the previous word if the cursor is already at
the beginning of a word.

\fname{beginning-of-buffer}{}{M-<}
\fbody Moves the cursor backwards to the beginning of the buffer.

\fname{beginning-of-line}{}{C-a}
\fbody Moves the cursor backwards to the beginning of the current
line.  This command has no effect if the cursor is already at the beginning
of the line.

\fname{end-of-buffer}{}{M->}
\fbody Moves the cursor forwards to the end of the buffer.

\fname{end-of-line}{}{C-e}
\fbody Moves the cursor forwards to the end of the current line.  This
command has no effect if the cursor is already at the end of the line.

\fname{exchange-point-and-mark}{}{C-x C-x}
\fbody Set the mark at the current cursor position, and move the cursor
to the old location of the mark.

\fname{forward-char}{}{C-f}
\fbody Moves the cursor forwards one character.  If the cursor is at the
end of a line, it will be moved to the first character on the next line.

\fname{forward-paragraph}{}{M-]}
\fbody Moves the cursor forwards to the next paragraph delimiter.

\fname{forward-word}{}{M-f}
\fbody Moves the cursor forwards to the end of the current word, or to
the end of the next word if the cursor is already at the end of a word.

\fname{goto-line}{line-number}{}
\fbody Moves the cursor to the beginning of line {\em line-number\/} in
the buffer.

\fname{next-line}{}{C-n}
\fbody Moves the cursor down one line.  The cursor remains in the same
column unless it would be past the end of the line, in which case it is
moved to the end of the line.  At the end of the buffer, {\tt C-n} will
create new lines.

\fname{previous-line}{}{C-p}
\fbody Moves the cursor up one line.    The cursor remains in the same
column unless it would be past the end of the line, in which case it is
moved to the end of the line.

\fname{recenter}{}{C-l}
\fbody Redraws the entire screen, scrolling the current window if necessary
so that the cursor is near the center.  With a positive prefix argument 
{\em n\/}, the window is scrolled so that the cursor is {\em n\/} lines
from the top.  A negative prefix argument puts the cursor that many lines
from the bottom of the window.

\fname{redraw-display}{}{}
\fbody Redraws the entire screen, but never scrolls.

\fname{scroll-down}{}{M-v}
\fbody Scrolls the display down (moving backward through the
buffer).  Without 
an argument, it scrolls slightly less than one windowful.  A prefix argument
scrolls that many lines.

\fname{scroll-one-line-down}{}{}
\fmore{scroll-one-line-up}{}{}
\fbody These functions are similar to {\tt scroll-down} and {\tt scroll-up}
(respectively), but when invoked without an argument, cause the display 
to scroll by one line only.  These functions are enabled by defining the
compile-time option GOSMACS.

\fname{scroll-other-window}{}{M-C-v}
\fbody Scrolls the ``other'' window forward as for {\tt scroll-up}.

\fname{scroll-up}{}{C-v}
\fbody Scrolls the display up (moving forward through the buffer).  Without an
an argument, it scrolls slightly less than one windowful.  A prefix argument
scrolls that many lines.

\fname{set-mark-command}{}{NUL}
\fbody Set the mark at the current cursor position.

\fname{what-cursor-position}{}{C-x =}
\fbody Prints some information in the minibuffer about where the cursor is.


\chapter{Text Insertion Commands}

The usual way to insert text into a buffer is simply to type the
characters.  The default binding for all of the printing characters
({\tt self-insert-command}) causes them to be inserted literally at
the cursor position. 

\fname{insert}{string}{}
\fbody Insert {\em string\/} into the current buffer at the cursor position.

\fname{newline}{}{RET}
\fbody Insert a line break into the current buffer at the cursor position,
moving the cursor forward to the beginning of the new line.

\fname{newline-and-indent}{}{C-j}
\fbody Insert a line break into the current buffer at the cursor position,
then add extra whitespace so that the cursor is aligned in the same
column as the first non-whitespace character in the previous line.

\fname{open-line}{}{C-o}
\fbody Inserts a line break into the current buffer at the current position,
but does not move the cursor forward.

\fname{quoted-insert}{}{C-q} 
\fbody This command acts as a prefix to
cancel the normal interpretation of the next keystroke.  If {\tt C-q}
is followed by one to three octal digits, it is interpreted as the
code of the character to insert.  Otherwise a single key is read and
the character typed is inserted into the buffer instead of interpreted
as a command.  This is used for inserting literal control characters
into a buffer. 

\fname{self-insert-command}{}{}
\fbody This is the default binding for keys representing printable
characters.  The character is inserted into the buffer at the cursor
position, and the cursor moved forward.

\chapter{Killing, Deleting, and Moving Text}

When text is deleted, it is erased completely.  Killing text, on the
other hand, moves it into a temporary storage area called the kill
buffer.  The saved text in the kill buffer is erased when another
block of text is killed.  Until then, however, you can retrieve text
from the kill buffer.  This can be used to move or copy blocks of
text, as well as to restore accidentally killed text.

\fname{backward-kill-word}{}{M-DEL}
\fbody Kill the text backwards from the cursor position to the beginning
of the current word.  Typing {\tt M-DEL} several times in succession 
prepends each killed word to the kill buffer.

\fname{copy-region-as-kill}{}{M-w}
\fbody Copies the text in the region into the kill buffer, without removing
it from the current buffer.

\fname{delete-backward-char}{}{DEL}
\fbody Deletes the character to the left of the cursor.

\fname{delete-blank-lines}{}{C-x C-o}
\fbody Deletes all blank lines after the current line, and if the current
line is blank, deletes it and all blank lines preceeding it as well.

\fname{delete-char}{}{C-d}
\fbody Deletes the character underneath the cursor.

\fname{delete-horizontal-space}{}{M-$\backslash$}
\fbody Deletes all spaces and tabs on either side of the cursor.

\fname{just-one-space}{}{M-SPC}
\fbody This is like {\tt delete-horizontal-space}, except it leaves a single
space at the cursor position.

\fname{kill-line}{}{C-k}
\fbody If no prefix argument is specified, this function kills text up
to the next newline; or if the cursor is at the end of a line, the newline
is killed.  A prefix argument specifies how many lines to kill.  Typing
{\tt C-k} several times in succession appends each line to the kill buffer.

\fname{kill-paragraph}{}{}
\fbody This command kills the entire paragraph containing the cursor.
If the cursor is positioned between paragraphs, the next paragraph is killed.

\fname{kill-region}{}{C-w}
\fbody The region (all text between point and mark) is killed.

\fname{kill-word}{}{M-d}
\fbody Text is killed forward from the cursor position to the next
end of word.  If the cursor is at the end of the word, then the next
word is killed.  Typing {\tt M-d} several times appends the killed
text to the kill buffer.

\fname{yank}{}{C-y}
\fbody Text is copied from the kill buffer into the current buffer at
the cursor position.  The cursor is moved to the end of the inserted
text.

\chapter{Searching and Replacing}

\section{Searching}

The ordinary search command in MG differs from that in many other editors
in that it is incremental:  it begins searching as soon as you begin
typing the search string, instead of waiting for you to type the entire
string.

All of the search commands described in this section are case-insensitive.


\fname{isearch-backward}{pattern}{C-r}
\fmore{isearch-forward}{pattern}{C-s}
\fbody These commands perform an incremental search backward and 
forward (respectively) for {\em pattern\/}.  MG will move the cursor 
to the place in the buffer that matches as much of the pattern as you 
have typed so far, as each character is entered.


Within the incremental search, the following characters are interpreted
specially:

\begin{define}{\hspace{1in}}

\item[{\tt DEL}\hfill] Erase the last character in the search string. 

\item[{\tt ESC}\hfill] Stop searching; exit from incremental search
mode, leaving the cursor where the search brought it. 

\item[{\tt C-g}\hfill] If a match has been found, exits from
incremental search but leaves the cursor in its original position.  If
the search has failed, this will just erase the characters which have
not been found from the end of the search pattern.  In this case, you
must type \verb"C-g" again to abort the search. 

\item[{\tt C-s}\hfill] Search forward for the next occurrence of the
same pattern. 

\item[{\tt C-r}\hfill] Search backward for the previous occurrence of
the same pattern. 

\item[{\tt C-q}\hfill] ``Quotes'' the next character typed, forcing it
to be interpreted as a literal character in the search pattern.
\end{define}

In addition, normal commands such as \verb"C-a" that do not have special
meanings within incremental search cause the search to be terminated, and
then are executed in the ordinary way.

\fname{search-again}{}{}
\fmore{search-backward}{pattern}{M-r}
\fmore{search-forward}{pattern}{M-s}
\fbody These commands perform ordinary, non-incremental searches.
{\tt Search-again} uses the same pattern and direction as the previous
search.

\section{Replacing}

\fname{query-replace}{pattern replacement}{M-\%}
\fbody The primary replace command in MG is an interactive query replace.
MG searches forward for occurrences of {\em pattern\/}, and asks you what
to do about each one.  The choices are:

\begin{define}{\hspace{1in}}

\item[{\tt SPC}\hfill] Replace this match with {\em replacement\/},
and go on to the next. 

\item[{\tt DEL}\hfill] Skip to the next match without replacing this one. 

\item[{\tt .}\hfill] Replace this match, and then quit. 

\item[{\tt !}\hfill] Replace all remaining occurrences without asking again. 

\item[{\tt ESC}\hfill] Quit.
\end{define}

By default, {\tt query-replace} adjusts the case of lower-case letters
in the replacement string to match that of the
particular occurrence of the pattern; for example, replacing ``Foo''
with ``bar'' results in ``Bar''.  Upper case letters in the replacement
string are always left uppercase.   In addition, supplying a prefix argument
will also tell {\tt query-replace} to leave the case of the replacement
string as-is.

Note that {\tt query-replace} always performs a case-insensitive search.



\section{Regular Expressions}

Regular expressions provide a means for specifying complex search
patterns, instead of just a literal string.  The commands in this
section are available only if MG is compiled with the REGEX option
defined. 

Regular expression syntax uses the following rules.  Most characters
in a regular expression are considered to be {\em ordinary\/} characters,
and will match themselves and nothing else.  The exceptions are the
special characters listed below.

\begin{define}{\hspace{1in}}

\item[{\tt .}\hfill] Matches any single character except a newline.  

\item[{\tt *}\hfill] A suffix operator that matches zero or more
repetitions of the (smallest) preceding regular expression. 

\item[{\tt +}\hfill] A suffix operator that matches one or more
repetitions of the (smallest) preceding regular expression. 

\item[{\tt ?}\hfill] A suffix operator that matches either zero or one
occurence of the (smallest) preceding regular expression. 

\item[{\tt [\ldots]}\hfill] Matches any one character listed in the
character set between the square brackets.  See examples below. 

\item[{\tt \^{ }}\hfill] Matches at the beginning of a line. 

\item[{\tt \$}\hfill] Matches at the end of a line. 

\item[{\tt $\backslash$}\hfill] Except for the situations listed
below, acts as a prefix operator which causes the character following
to be treated as an ordinary character. 

\item[{\tt $\backslash$|}\hfill] An infix binary {\em or\/} operator.
It applies to the two largest surrounding expressions. 

\item[{\tt $\backslash$(\ldots$\backslash$)}\hfill] A grouping construct,
usually used to specify a larger expression for postfix operators such
as \verb"*" or to limit the scope of operands to \verb"\|". 

\item[{\tt $\backslash${\em digit\/}}\hfill] Matches the same text
matched by the {\em digit\/}th \verb"\(...\)" construct.  These are
numbered from 1 to 9 in the order that the open-parentheses appear. 

\item[{\tt $\backslash$`}\hfill] Matches at the beginning of the buffer. 

\item[{\tt $\backslash$'}\hfill] Matches at the end of the buffer. 

\item[{\tt $\backslash$b}\hfill] Matches at the beginning or end of a word. 

\item[{\tt $\backslash$B}\hfill] Matches anyplace {\em except\/} at
the beginning or end of a word. 

\item[{\tt $\backslash$<}\hfill] Matches at the beginning of a word. 

\item[{\tt $\backslash$>}\hfill] Matches at the end of a word. 

\item[{\tt $\backslash$w}\hfill] Matches any word-constituent character. 

\item[{\tt $\backslash$W}\hfill] Matches any character which is {\em
not\/} a word-constituent. 

\end{define}

Some examples may help clarify the rules.

\begin{define}{\hspace{1in}}

\item[{\tt foo}\hfill] Matches the literal string {\tt foo}. 

\item[{\tt ;.*}\hfill] Matches all strings which begin with a
semicolon and continue to the end of a line. 

\item[{\tt c[ad]+r}\hfill] Matches strings of the form {\tt car}, {\tt
cdr}, {\tt caar}, {\tt cadr}, and so on. 

\item[{\tt [a-z]}\hfill] Matches any lowercase letter. 

\item[{\tt [\^{ }a-z]}\hfill] Matches any character {\em except\/}
lowercase letters. 

\item[{\tt [0-9+---]}\hfill] Matches a digit or sign. 

\item[{\tt $\backslash$(foo$\backslash$|bar$\backslash$)}\hfill]
Matches either the string {\tt foo} or the string {\tt bar}. 

\end{define}

\fname{count-matches}{pattern}{}
\fmore{count-non-matches}{pattern}{}
\fbody These commands count the number of lines which do or do not
(respectively) match the specified pattern.

\fname{delete-matching-lines}{pattern}{}
\fmore{delete-non-matching-lines}{pattern}{}
\fbody These commands delete all lines which do or do not (respectively)
match the specified pattern.


\fname{query-replace-regexp}{pattern replacement}{}
\fbody This is the regular expression version of {\tt query-replace}.

The {\em replacement\/} string may be a constant, or it can refer to
all or part of the string matched by the {\em pattern\/}.  \verb"\&" in
the replacement string expands into the entire text being replaced,
while \verb"\"{\em n\/} (where {\em n\/} is a number) replaces the 
{\em n\/}th parenthesized expression in {\em pattern\/}.

\fname{re-search-again}{}{}
\fmore{re-search-backward}{pattern}{}
\fmore{re-search-forward}{pattern}{}
\fbody These are the regular expression equivalents of the ordinary
non-incremental search commands.

\fname{set-case-fold-search}{}{}
\fbody This command toggles an internal variable that controls whether
the regular expression search and replace commands pay attention to
case.  By default, regular expression searches are case-insensitive.
Ordinary searches are always case-insensitive and are not affected by
the setting of this variable.


\chapter{Windows}

MG initially has only one text window displayed.  However, you can have
as many windows as will fit on the screen.  Each window has its own mode
line and must display at least two lines of text.  (Note that a MG's
``windows'' are distinct from the ``windows'' handled by screen managers
such as the X Window System.)

Multiple windows may be used to display different buffers.  You can also
have the same buffer displayed in more than one window, which is useful
if you want to see one part of a file at the same time as you are editing
another part.

Although many windows can be displayed at once, only one window is active 
at any given time.  This is the window where the cursor appears.

Some commands refer to the ``other'' window.  This is the window directly
below the current window, or the top window if you are in the bottom window.

\fname{delete-other-windows}{}{C-x 1}
\fbody Makes the current window the only window.

\fname{delete-window}{}{C-x 0}
\fbody Deletes the current window, making the ``other'' window the
current window.  This command doesn't do anything useful if there is only
one window being displayed.

\fname{enlarge-window}{}{C-\^{ }}
\fbody Makes the current window larger.  Without a prefix argument, the
window grows one line; otherwise, the prefix argument specifies how many
lines to grow.

\fname{other-window}{}{C-x o}
\fbody Makes the ``other'' window the current window.

\fname{previous-window}{}{}
\fbody This is like {\tt other-window}, except that it cycles through
the windows in reverse order.  This command is available only if MG was
compiled with the GOSMACS option defined.

\fname{shrink-window}{}{}
\fbody Makes the current window smaller.  Without a prefix argument, the
window loses one line; otherwise, the prefix argument specifies how many
lines go away.

\fname{split-window-vertically}{}{C-x 2}
\fbody Split the current window into two windows, both using the same
buffer.


\chapter{Files and Buffers}

Most buffers are used to contain a file being edited.  It is
also possible to have buffers that are not associated with any file;
MG uses these for purposes such as displaying help text, for example.
However, since most commands for dealing with files also deal with
buffers, we have grouped all of these commands together into one chapter.

\section{Buffer Manipulation}

\fname{insert-buffer}{buffer-name}{}
\fbody Inserts the contents of the named buffer into the current buffer
at the cursor location.  The cursor moves to the end of the inserted
text.

\fname{kill-buffer}{buffer-name}{C-x k}
\fbody The named buffer and its contents are deleted.  If the buffer has
been marked as modified, MG will ask you if you really want to delete it.
Note that, contrary to its name, this command {\em does not\/} save the
buffer contents in the kill buffer.

If a buffer is being displayed in a window when it is deleted, MG will 
find some other buffer to display in the same window.

\fname{list-buffers}{}{C-x C-b}
\fbody This command writes information about the buffers currently in
use to a buffer named {\tt *Buffer List*}.  This buffer is then displayed
in the ``other'' window; if there is only one window, this command will
split the screen into two windows.

\fname{not-modified}{}{M-\~{ }}
\fbody This command makes MG think that the current buffer has not been
modified, even if it really has been changed.  This affects the behavior
of the {\tt kill-buffer} and the buffer-saving commands described below.

MG indicates modified buffers with two stars at the left end of the mode
line.

\fname{switch-to-buffer}{buffer-name}{C-x b}
\fbody The current window is mapped onto the named buffer.  If there
isn't already a buffer with that name around, MG will create one.

\fname{switch-to-buffer-other-window}{buffer-name}{C-x 4 b}
\fbody This command works like {\tt switch-to-buffer}, except that the
``other'' window is used.  If there is only one window, this command
splits the screen into two windows and maps the named buffer onto one
of them.

\section{Reading and Writing Files}

\fname{find-file}{file-name}{C-x f}
\fmore{find-file-other-window}{file-name}{C-x 4 C-f}
\fbody These commands are analagous to {\tt switch-to-buffer} and {\tt
switch-to-buffer-other-window}, respectively.  The difference is that
these commands look for a buffer associated with the named file.  If no
matching buffer is found, MG will create a new buffer with a name
derived from the filename, and attempt to read the file into the buffer.
If the named file cannot be opened, the buffer remains empty.

\fname{insert-file}{file-name}{C-x i}
\fbody This command reads in the contents of the named file into the
current buffer at the cursor position.  The cursor remains in the same
place.

\fname{save-buffer}{}{C-x C-s}
\fbody If the current buffer has been modified, it is saved.  Buffers
that are not associated with files cannot be written out with this
command.

\fname{save-buffers-kill-emacs}{}{C-x C-c}
\fbody This command is used to leave MG and return control to the shell
or other program that was used to start MG.  If there are modified buffers,
MG will ask you if you want to save them before exiting.

\fname{save-some-buffers}{}{C-x s}
\fbody MG will ask you if you want to save modified buffers that are
associated with files.

\fname{write-file}{file-name}{C-x C-w}
\fbody The current buffer is written out using the file name supplied.
This is useful for saving buffers that are not associated with files, or
for writing out a file with a different name than what was used to read
it in.

\section{Backup Files}

MG provides a way to save a copy of the original version of files which 
have been modified and then written out again.  The backup copy reflects
the state of the file as it existed the first time it was read into MG.
The name used for the backup file varies, depending on the operating
system.

This feature is disabled if MG is compiled with NO\_BACKUP defined.

\fname{make-backup-files}{}{} 
\fbody This command is a toggle which
controls the state of an internal variable that determines whether MG
creates backup files. 

\section{Changing the Directory}

The commands in this section are disabled by defining NO\_DIR.

\fname{cd}{directory-name}{}
\fbody This command changes MG's notion of the ``current'' directory
or pathname.  This is used to supply defaults for functions that read 
or write files.

The syntax for {\em directory-name\/} is obviously specific to the
particular operating system MG is running on.

\fname{pwd}{}{}
\fbody Display what MG thinks is the current directory.

\chapter{Modes}

Modes are used to locally alter the bindings of keys on a 
buffer-by-buffer basis.  MG is normally in fundamental mode, and these
are the bindings that are listed with the command descriptions in 
this manual.  Modes define additional keymaps that are searched for
bindings before the fundamental mode bindings are examined; see the
section on key binding below for more details on how this works.

\fname{set-default-mode}{mode-name}{}
\fbody Normally, when MG visits a file, it puts the associated buffer
into fundamental mode.  Using the {\tt set-default-mode} command, you
can specify that MG should default to use some other mode on all subsequent
buffers that are created.  This command is a toggle.  With no prefix
argument, if the named mode is not already on the list of
default modes, then it will be added to the list; otherwise, it is removed
from the list.

\section{No Tab Mode}

In notab mode, tabs are expanded into spaces instead of inserted
literally into the buffer.  Literal tab characters are displayed as
\verb"^I" (much like other control characters).  These commands are
available if MG is compiled with the symbol NOTAB defined.  (This mode
is mainly for use on systems such as PRIMOS that do not treat tab as a
series of spaces.)

\fname{no-tab-mode}{}{}
\fbody This command is a toggle to control whether notab mode is in effect.

\fname{space-to-tabstop}{}{}
\fbody Insert enough spaces to move the cursor to the next tab stop.  In
notab mode, this function is bound to {\tt C-i}.


\section{Overwrite Mode}

Normally, when characters are inserted into the buffer, they are spliced
into the existing text.  In overwrite mode, inserting a character causes
the character already at the cursor position to be replaced.  This is
useful for editing pictures, tables, and the like.

\fname{overwrite-mode}{}{}
\fbody This command is a toggle which controls whether overwrite mode is
in effect.

\section{Auto Fill}

Fill mode causes newlines to be added automatically at word
breaks when text is added at the end of a line, extending past the
right margin.  Auto fill is useful for editing text and documentation
files.

\fname{auto-fill-mode}{}{}
\fbody This command is a toggle which controls whether fill mode is
in effect.

\fname{insert-with-wrap}{}{}
\fbody This command works like {\tt self-insert}, except that it checks
to see if the cursor has passed the right margin.  If so, it fills
the line by inserting a line break between words.  This command is bound to 
{\tt SPC} in fill mode.

\fname{fill-paragraph}{}{M-q}
\fbody Fill the paragraph containing the cursor.

\fname{set-fill-column}{}{C-x f}
\fbody Without a prefix argument, this command sets the right margin
at the current cursor column.  If a prefix argument is supplied, it is used
instead as the line width.

\section{Auto Indent}

Indent mode binds {\tt RET} to {\tt newline-and-indent}, so
that each new line is indented to the same level as the preceeding
line.  This mode is useful for editing code. 

\fname{auto-indent-mode}{}{}
\fbody This command is a toggle which controls whether auto-indent mode
is in effect.

\section{Blink}

Blink mode makes it easier to match parentheses, brackets, and other
paired delimiters.  When the closing delimiter is typed, the cursor
moves momentarily to the matching opening delimiter (if it is on the
screen), or displays the line containing the matching delimiter on the
echo line.  This is useful for editing Lisp or C code, or for
preparing input files for text processors such as LaTeX that use
paired delimiters. 

\fname{blink-matching-paren}{}{}
\fbody This command is a toggle which controls whether blink mode is
in effect.

\fname{blink-matching-paren-hack}{}{}
\fbody This function behaves like {\tt self-insert}, except that it
finds the matching delimiter as described above.  In blink mode, this
function is bound to \verb")", which flashes the matching \verb"(".  This
function also knows about the pairs \verb"{}", \verb"[]", and \verb"<>".
All other characters match with themselves.

\section{Dired Mode}

``Dired'' is an abbreviation for ``directory editor'', and it provides a way
to browse through the contents of a directory from with MG.  Dired puts
a directory listing into a buffer; you can use normal editing commands to
move around the buffer, and a special group of commands to manipulate
the files.  For example, there are commands to delete and rename files,
and to read a file into an MG buffer.

Since dired mode rebinds many keys, a table may be helpful:

\begin{verbatim}
    C-d      dired-flag-file-deleted
    SPC      next-line
    c        dired-copy-file
    d        dired-flag-file-deleted
    e        dired-find-file
    f        dired-find-file
    n        next-line
    o        dired-find-file-other-window
    p        previous-line
    r        dired-renamefile
    u        dired-unflag
    x        dired-do-deletions
    DEL      dired-backup-unflag
\end{verbatim}

The commands in this section are disabled by defining NO\_DIRED.

\fname{dired}{directory-name}{C-x d}
\fbody Creates a dired buffer for the given directory name, and displays
it in the current window.  The files
in the directory are listed, usually along with information about the
file such as its size and timestamp.  The exact format of the information
is system-specific.

\fname{dired-backup-unflag}{}{}
\fbody This function removes the deletion flag from the file listed on
the previous line of the dired buffer.

\fname{dired-copy-file}{new-name}{}
\fbody Copy the file listed on the current line of the dired buffer.

\fname{dired-do-deletions}{}{}
\fbody Deletes the files that have been flagged for deletion.

\fname{dired-find-file}{}{}
\fmore{dired-find-file-other-window}{}{}
\fbody These function works like {\tt find-file} and 
{\tt find-file-other-window}, except that the filename is taken 
from the current line in the dired buffer.

\fname{dired-flag-file-deleted}{}{}
\fbody Flag the file listed on the current line for deletion.  This is
indicated in the buffer by putting a ``D'' at the left margin.  No
files are not actually deleted until the function {\tt dired-do-deletions}
is executed.

\fname{dired-other-window}{directory-name}{}
\fbody This function works just like {\tt dired}, except that it puts the
dired buffer in the ``other'' window.

\fname{dired-rename-file}{new-name}{}
\fbody Renames the file listed on the current line of the dired buffer.  
Note that the dired buffer is not updated to reflect the change.

\fname{dired-unflag}{}{}
\fbody Remove the deletion flag for the file on the current line.

\chapter{Miscellaneous}

\section{Help}

Most of the commands in this section write useful information to the
{\tt *help*} buffer, which is then displayed in the ``other'' window.

These commands can be disabled at compile-time by defining NO\_HELP.

\fname{apropos}{topic}{C-h a}
\fbody This command lists all functions whose names contain a string
matching {\em topic\/} in the {\tt *help*} buffer.

\fname{describe-bindings}{}{C-h b}
\fbody Information about the key bindings in effect in the current buffer
is listed in the {\tt *help*} buffer.

\fname{describe-key-briefly}{key}{C-h c}
\fbody Information about the binding of {\em key\/} is printed in the
minibuffer.

\fname{help-help}{option}{C-h C-h}
\fbody This command lists all of the help options available and
prompts for which one to run.  Currently, these include only {\tt a}
to run {\tt apropos}, {\tt b} to run {\tt describe-bindings}, and {\tt c}
to run {\tt describe-key-briefly}.


\section{Keyboard Macros}

A keyboard macro is a saved set of commands from the keyboard that can be
reexecuted later on.  There can only be one keyboard macro defined at
any one time.

The commands in this section are available unless they have been disabled
by defining NO\_MACRO.

\fname{call-last-kbd-macro}{}{C-x e}
\fbody Execute the saved keyboard macro.  A prefix argument can be used
to specify a repetition count.

\fname{end-kbd-macro}{}{C-x )}
\fmore{start-kbd-macro}{}{C-x (}
\fbody These functions are used to define a keyboard macro.  All keys
entered after {\tt start-kbd-macro} is executed, up to a {\tt end-kbd-macro},
are remembered as they are executed.  You can then reexecute the same
sequence of operations using {\tt call-last-kbd-macro}.


\section{Changing Case}

MG provides a number of functions for changing the case of text.

\fname{capitalize-word}{}{M-c}
\fmore{downcase-region}{}{C-x C-l}
\fmore{downcase-word}{}{M-l}
\fmore{upcase-region}{}{C-x C-u}
\fmore{upcase-word}{}{M-u}
\fbody All of these commands do the obvious.


\section{Odds and Ends}

This section describes miscellaneous commands that don't fit into any
particular category.

\fname{emacs-version}{}{}
\fbody Prints information about the version of MG you are running in
the minibuffer.

\fname{meta-key-mode}{}{}
\fbody If the particular version of MG you are running supports a meta key,
this function can be used to determine whether MG actually pays attention
to it or not.  If no prefix argument is supplied, the internal variable
that controls the use of the meta key is toggled; a positive value enables
the meta key, while a negative value disables it.

\fname{prefix-region}{}{}
\fmore{set-prefix-string}{string}{}
\fbody {\tt Prefix-region} is used to prefix each line of the region
with a string.  This is useful for indenting quoted text, making block
comments, and the like.  The function {\tt set-prefix-string} can be
used to set the string used as the prefix.

\fname{suspend-emacs}{}{C-z} 
\fbody This command temporarily suspends
MG so that you can run other programs, and later resume editing.  The
exact behavior depends on which operating system you are running MG
under.  Typically, MG will either spawn a new shell as a subprocess, or
return you to the parent process.

\fname{transpose-chars}{}{C-t}
\fbody This command transposes the previous two characters.


\chapter{Customization}

MG provides a limited support for customization.  However, unlike ``real'' 
Emacs, there is no extension language for interpretively defining new 
functions.

\section{Key Bindings}

MG allows keys to be rebound locally or globally.  To understand the
difference between the two, some discussion on how modes are implemented
is necessary.

An internal data structure called a keymap is used to look up the
function that is bound to a particular key.  The keymap for
fundamental mode contains all of the default bindings which are listed
with the command descriptions in this manual.  Modes define additional
keymaps that are searched for a binding before the fundamental mode
keymap is examined.  Keymaps have the same name as the mode they are
associated with.

MG does not provide commands for defining new modes, but you can alter
the keymaps for existing modes.

\fname{define-key}{keymap-name key command}{}
\fbody This command can be used to modify the keymap for the named mode.

\fname{global-set-key}{key command}{}
\fmore{global-unset-key}{key}{}
\fbody These commands modify the keymap for fundamental mode.  Bindings
established by {\tt global-set-key} will be inherited by all other modes, 
as long as they do not establish local rebindings of the same key.

\fname{local-set-key}{key command}{}
\fmore{local-unset-key}{key}{}
\fbody These commands modify the keymap currently in effect.


\section{Startup Files}

Although MG does not include a general-purpose extension language, it
does provide a way to read and evaluate commands using a somewhat
different syntax than that used for executing extended commands.  This
is typically used in a startup file to modify key bindings.

A startup file consists of one or more expressions.  Each expression must
appear on a separate line in the file; there may not be more than one
expression per line, nor may expressions span across line breaks.
Whitespace (spaces and tabs) separate the tokens in an expression.  For
historical reasons, parentheses are also considered to be whitespace in
this context.  A semicolon acts as a comment character, causing the rest
of the line to be discarded.

An expression consists of a function name, an optional prefix argument
(given as an integer constant), and arguments to be passed to the
function.  If an argument includes literal whitespace or nonprintable
characters (for example, as in a keystroke argument to one of the key
binding functions described in the previous section), it must be
supplied as a string constant enclosed in double quotes. 

Within string constants, the following backslash escapes are available
to specify nonprintable characters:

\begin{define}{\hspace{1in}}

\item[{\tt $\backslash$t, $\backslash$T}\hfill] Tab 
\item[{\tt $\backslash$n, $\backslash$N}\hfill] Newline 
\item[{\tt $\backslash$r, $\backslash$R}\hfill] Carriage return 
\item[{\tt $\backslash$e, $\backslash$E}\hfill] Escape (Meta prefix) 
\item[{\tt $\backslash$\^{ }}\hfill] Control prefix 

\item[{\tt $\backslash${\em n\/}}\hfill] Specifies a character by its
ASCII code, where {\em n\/} may consist of from one to three octal
digits

\item[{\tt $\backslash$f{\em n\/}, $\backslash$F{\em n\/}}\hfill]
Specifies the keycode for the {\em n\/}th function key.  {\em N\/} may
consist of one or two decimal digits. 

\end{define}

The following commands which deal with evaluation of expressions are
disabled by defining the compile-time option NO\_STARTUP.  

The Rutgers Sun version will attempt to read two different startup
files, a general startup file and a terminal-specific startup file.
The terminal-specific startup file is intended primarily to define the
keypad.  The general startup file is .mg in your home directory.  If
there is no such file, /usr/local/lib/mg/mg will be used.  The
terminal-specific startup file is .mg-TYPE, where TYPE represents the
name of the terminal type.  E.g if your terminal type is set to vt100,
MG will read a file .mg-vt100.  If there is no such file, it will try
/usr/local/lib/mg/mg-vt100.  Files should exist in /usr/local/lib/mg
for the terminal types commonly in use at Rutgers.

For other versions, see the implementation notes for your particular
version of MG for information on how it handles startup files.


\fname{eval-current-buffer}{}{}
\fbody Evaluate the expressions in the current buffer.

\fname{eval-expression}{expression}{}
\fbody Evaluate the expression supplied.

\fname{load}{file-name}{}
\fbody Read in the specified file and evaluate its contents.

\twocolumn[\Huge{\vspace{2em}{\bf Fundamental Mode Key Bindings}\vspace{1.5em}}]
\addcontentsline{toc}{chapter}{Fundamental Mode Key Bindings}
\begin{verbatim}
NUL       set-mark-command
C-a       beginning-of-line
C-b       backward-char
C-d       delete-char
C-e       end-of-line
C-f       forward-char
C-g       keyboard-quit
C-h       help
TAB       self-insert-command
C-j       newline-and-indent
C-k       kill-line
C-l       recenter
RET       newline
C-n       next-line
C-o       open-line
C-p       previous-line
C-q       quoted-insert
C-r       isearch-backward
C-s       isearch-forward
C-t       transpose-chars
C-u       universal-argument
C-v       scroll-up
C-w       kill-region
C-x       c-x prefix
C-y       yank
C-z       suspend-emacs
ESC       meta prefix
SPC .. ~  self-insert-command
DEL       delete-backward-char

C-h C-g   keyboard-quit
C-h C-h   help-help
C-h a     apropos
C-h b     describe-bindings
C-h c     describe-key-briefly

C-x C-b   list-buffers
C-x C-c   save-buffers-kill-emacs
C-x C-f   find-file
C-x C-g   keyboard-quit
C-x C-l   downcase-region
C-x C-o   delete-blank-lines
C-x C-s   save-buffer
C-x C-u   upcase-region
C-x C-w   write-file
C-x C-x   exchange-point-and-mark
C-x (     start-kbd-macro
C-x )     end-kbd-macro
C-x 0     delete-window
C-x 1     delete-other-windows
C-x 2     split-window-vertically
C-x 4     c-x 4 prefix
C-x =     what-cursor-position
C-x ^     enlarge-window
C-x b     switch-to-buffer
C-x d     dired
C-x e     call-last-kbd-macro
C-x f     set-fill-column
C-x i     insert-file
C-x k     kill-buffer
C-x o     other-window
C-x s     save-some-buffers
C-x 4 C-f find-file-other-window
C-x 4 C-g keyboard-quit
C-x 4 b   switch-to-buffer-other-window
C-x 4 f   find-file-other-window

M-C-g     keyboard-quit
M-C-v     scroll-other-window
M-SPC     just-one-space
M-%       query-replace
M--       negative-argument
M-0       digit-argument
M-1       digit-argument
M-2       digit-argument
M-3       digit-argument
M-4       digit-argument
M-5       digit-argument
M-6       digit-argument
M-7       digit-argument
M-8       digit-argument
M-9       digit-argument
M-<       beginning-of-buffer
M->       end-of-buffer
M-[       backward-paragraph
M-\       delete-horizontal-space
M-]       forward-paragraph
M-b       backward-word
M-c       capitalize-word
M-d       kill-word
M-f       forward-word
M-l       downcase-word
M-q       fill-paragraph
M-r       search-backward
M-s       search-forward
M-u       upcase-word
M-v       scroll-down
M-w       copy-region-as-kill
M-x       execute-extended-command
M-~       not-modified
M-DEL     backward-kill-word

\end{verbatim}

\begin{theindex}
\addcontentsline{toc}{chapter}{Index}
\input{mgidx.tex}
\end{theindex}

\end{document}
