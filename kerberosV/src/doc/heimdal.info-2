This is heimdal.info, produced by makeinfo version 4.0 from
heimdal.texi.

INFO-DIR-SECTION Heimdal
START-INFO-DIR-ENTRY
* Heimdal: (heimdal).           The Kerberos 5 distribution from KTH
END-INFO-DIR-ENTRY


File: heimdal.info,  Node: Digital SIA,  Next: IRIX,  Prev: Authentication modules,  Up: Authentication modules

Digital SIA
-----------

How to install the SIA module depends on which OS version you're
running. Tru64 5.0 have a new command, `siacfg', which makes this
process quite simple. If you have this program, you should just be able
to run:
     siacfg -a KRB5 /usr/athena/lib/libsia_krb5.so

On older versions, or if you want to do it by hand, you have to do the
following (not tested by us on Tru64 5.0):

   * Make sure `libsia_krb5.so' is available in `/usr/athena/lib'. If
     `/usr/athena' is not on local disk, you might want to put it in
     `/usr/shlib' or someplace else. If you do, you'll have to edit
     `krb5_matrix.conf' to reflect the new location (you will also have
     to do this if you installed in some other directory than
     `/usr/athena'). If you built with shared libraries, you will have
     to copy the shared `libkrb.so', `libdes.so', `libkadm.so', and
     `libkafs.so' to a place where the loader can find them (such as
     `/usr/shlib').

   * Copy (your possibly edited) `krb5_matrix.conf' to `/etc/sia'.

   * Apply `security.patch' to `/sbin/init.d/security'.

   * Turn on KRB5 security by issuing `rcmgr set SECURITY KRB5' and
     `rcmgr set KRB5_MATRIX_CONF krb5_matrix.conf'.

   * Digital thinks you should reboot your machine, but that really
     shouldn't be necessary.  It's usually sufficient just to run
     `/sbin/init.d/security start' (and restart any applications that
     use SIA, like `xdm'.)

Users with local passwords (like `root') should be able to login safely.

When using Digital's xdm the `KRB5CCNAME' environment variable isn't
passed along as it should (since xdm zaps the environment). Instead you
have to set `KRB5CCNAME' to the correct value in
`/usr/lib/X11/xdm/Xsession'. Add a line similar to
     KRB5CCNAME=FILE:/tmp/krb5cc`id -u`_`ps -o ppid= -p $$`; export KRB5CCNAME
If you use CDE, `dtlogin' allows you to specify which additional
environment variables it should export. To add `KRB5CCNAME' to this
list, edit `/usr/dt/config/Xconfig', and look for the definition of
`exportList'. You want to add something like:
     Dtlogin.exportList:     KRB5CCNAME

Notes to users with Enhanced security
.....................................

Digital's `ENHANCED' (C2) security, and Kerberos solves two different
problems. C2 deals with local security, adds better control of who can
do what, auditing, and similar things. Kerberos deals with network
security.

To make C2 security work with Kerberos you will have to do the
following.

   * Replace all occurencies of `krb5_matrix.conf' with
     `krb5+c2_matrix.conf' in the directions above.

   * You must enable "vouching" in the `default' database.  This will
     make the OSFC2 module trust other SIA modules, so you can login
     without giving your C2 password. To do this use `edauth' to edit
     the default entry `/usr/tcb/bin/edauth -dd default', and add a
     `d_accept_alternate_vouching' capability, if not already present.

   * For each user that does _not_ have a local C2 password, you should
     set the password expiration field to zero. You can do this for each
     user, or in the `default' table. To do this use `edauth' to set
     (or change) the `u_exp' capability to `u_exp#0'.

   * You also need to be aware that the shipped `login', `rcp', and
     `rshd', doesn't do any particular C2 magic (such as checking to
     various forms of disabled accounts), so if you rely on those
     features, you shouldn't use those programs. If you configure with
     `--enable-osfc2', these programs will, however, set the login UID.
     Still: use at your own risk.

At present `su' does not accept the vouching flag, so it will not work
as expected.

Also, kerberised ftp will not work with C2 passwords. You can solve this
by using both Digital's ftpd and our on different ports.

*Remember*, if you do these changes you will get a system that most
certainly does _not_ fulfill the requirements of a C2 system. If C2 is
what you want, for instance if someone else is forcing you to use it,
you're out of luck.  If you use enhanced security because you want a
system that is more secure than it would otherwise be, you probably got
an even more secure system. Passwords will not be sent in the clear,
for instance.


File: heimdal.info,  Node: IRIX,  Prev: Digital SIA,  Up: Authentication modules

IRIX
----

The IRIX support is a module that is compatible with Transarc's
`afskauthlib.so'.  It should work with all programs that use this
library. This should include `login' and `xdm'.

The interface is not very documented but it seems that you have to copy
`libkafs.so', `libkrb.so', and `libdes.so' to `/usr/lib', or build your
`afskauthlib.so' statically.

The `afskauthlib.so' itself is able to reside in `/usr/vice/etc',
`/usr/afsws/lib', or the current directory (wherever that is).

IRIX 6.4 and newer seems to have all programs (including `xdm' and
`login') in the N32 object format, whereas in older versions they were
O32. For it to work, the `afskauthlib.so' library has to be in the same
object format as the program that tries to load it. This might require
that you have to configure and build for O32 in addition to the default
N32.

Appart from this it should "just work", there are no configuration
files.

Note that recent Irix 6.5 versions (at least 6.5.22) have PAM,
including a `pam_krb5.so' module.  Not all relevant programs use PAM,
though, e.g. `ssh'. In particular, for console graphical login you need
to turn off `visuallogin' and turn on `xdm' with `chkconfig'.


File: heimdal.info,  Node: AFS,  Prev: Authentication modules,  Up: Applications

AFS
===

AFS is a distributed filesystem that uses Kerberos for authentication.

For more information about AFS see OpenAFS <http://www.openafs.org/>
and Arla <http://www.stacken.kth.se/projekt/arla/>.

How to get a KeyFile
--------------------

`ktutil -k AFSKEYFILE:KeyFile get afs@MY.REALM'

or you can extract it with kadmin

     kadmin> ext -k AFSKEYFILE:/usr/afs/etc/KeyFile afs@My.CELL.NAME

You have to make sure you have a `des-cbc-md5' encryption type since
that is the enctype that will be converted.

How to convert a srvtab to a KeyFile
------------------------------------

You need a `/usr/vice/etc/ThisCell' containing the cellname of you
AFS-cell.

`ktutil copy krb4:/root/afs-srvtab AFSKEYFILE:/usr/afs/etc/KeyFile'.

If keyfile already exists, this will add the new key in afs-srvtab to
KeyFile.

Using 2b tokens with AFS
========================

What is 2b ?
------------

2b is the name of the proposal that was implemented to give basic
Kerberos 5 support to AFS in rxkad. Its not real Kerberos 5 support
since it still uses fcrypt for data encryption and not Kerberos
encryption types.

Its only possible (in all cases) to do this for DES encryption types
because only then the token (the AFS equivalent of a ticket) will be be
smaller than the maximum size that can fit in the token cache in
OpenAFS/Transarc client. Its so tight fit that some extra wrapping on
the ASN1/DER encoding is removed from the Kerberos ticket.

2b uses a Kerberos 5 EncTicketPart instead of a Kerberos 4 ditto for
the part of the ticket that is encrypted with the service's key. The
client doesn't know what's inside the encrypted data so to the client
it doesn't matter.

To  differentiate between Kerberos 4 tickets and Kerberos 5 tickets 2b
uses a special kvno, 213 for 2b tokens and 255 for Kerberos 5 tokens.

Its a requirement that all AFS servers that support 2b also support
native Kerberos 5 in rxkad.

Configuring a Heimdal kdc to use 2b tokens
------------------------------------------

Support for 2b tokens in the kdc are turned on for specific principals
by adding them to the string list option `[kdc]use_2b' in the kdc's
`krb5.conf' file.

     [kdc]
     	use_2b = {
     		afs@SU.SE = yes
     		afs/it.su.se@SU.SE = yes
     	}

Configuring AFS clients for 2b support
--------------------------------------

There is no need to configure AFS clients for 2b support. The only
software that needs to be installed/upgrade is a Kerberos 5 enabled
`afslog'.


File: heimdal.info,  Node: Things in search for a better place,  Next: Kerberos 4 issues,  Prev: Applications,  Up: Top

Things in search for a better place
***********************************

Making things work on Ciscos
============================

Modern versions of Cisco IOS has some support for authenticating via
Kerberos 5. This can be used both by having the router get a ticket when
you login (boring), and by using Kerberos authenticated telnet to access
your router (less boring). The following has been tested on IOS
11.2(12), things might be different with other versions. Old versions
are known to have bugs.

To make this work, you will first have to configure your router to use
Kerberos (this is explained in the documentation). A sample
configuration looks like the following:

     aaa new-model
     aaa authentication login default krb5-telnet krb5 enable
     aaa authorization exec krb5-instance
     kerberos local-realm FOO.SE
     kerberos srvtab entry host/router.foo.se 0 891725446 4 1 8 012345678901234567
     kerberos server FOO.SE 10.0.0.1
     kerberos instance map admin 15

This tells you (among other things) that when logging in, the router
should try to authenticate with kerberised telnet, and if that fails try
to verify a plain text password via a Kerberos ticket exchange (as
opposed to a local database, RADIUS or something similar), and if that
fails try the local enable password. If you're not careful when you
specify the `login default' authentication mechanism, you might not be
able to login at all. The `instance map' and `authorization exec' lines
says that people with `admin' instances should be given `enabled' shells
when logging in.

The numbers after the principal on the `srvtab' line are principal type,
time stamp (in seconds since 1970), key version number (4), keytype (1
== des), key length (always 8 with des), and then the key.

To make the Heimdal KDC produce tickets that the Cisco can decode you
might have to turn on the `encode_as_rep_as_tgs_rep' flag in the KDC.
You will also have to specify that the router can't handle anything but
`des-cbc-crc'. This can be done with the `del_enctype' command of
`kadmin'.

This all fine and so, but unless you have an IOS version with encryption
(available only in the U.S) it doesn't really solve any problems. Sure
you don't have to send your password over the wire, but since the telnet
connection isn't protected it's still possible for someone to steal your
session. This won't be fixed until someone adds integrity to the telnet
protocol.

A working solution would be to hook up a machine with a real operating
system to the console of the Cisco and then use it as a backwards
terminal server.


File: heimdal.info,  Node: Kerberos 4 issues,  Next: Windows 2000 compatability,  Prev: Things in search for a better place,  Up: Top

Kerberos 4 issues
*****************

If compiled with version 4 support, the KDC can serve requests from a
Kerberos 4 client. There are a few things you must do for this to work.

The KDC will also have kaserver emulation and be able to handle
AFS-clients that use `klog'.

* Menu:

* Principal conversion issues::
* Converting a version 4 database::
* kaserver::


File: heimdal.info,  Node: Principal conversion issues,  Next: Converting a version 4 database,  Prev: Kerberos 4 issues,  Up: Kerberos 4 issues

Principal conversion issues
===========================

First, Kerberos 4 and Kerberos 5 principals are different. A version 4
principal consists of a name, an instance, and a realm. A version 5
principal has one or more components, and a realm (the terms "name" and
"instance" are still used, for the first and second component,
respectively).    Also, in some cases the name of a version 4 principal
differs from the first component of the corresponding version 5
principal. One notable example is the "host" type principals, where the
version 4 name is `rcmd' (for "remote command"), and the version 5 name
is `host'. For the class of principals that has a hostname as instance,
there is an other major difference, Kerberos 4 uses only the first
component of the hostname, whereas Kerberos 5 uses the fully qualified
hostname.

Because of this it can be hard or impossible to correctly convert a
version 4 principal to a version 5 principal (1). The biggest problem is
to know if the conversion resulted in a valid principal. To give an
example, suppose you want to convert the principal `rcmd.foo'.

The `rcmd' name suggests that the instance is a hostname (even if there
are exceptions to this rule). To correctly convert the instance `foo'
to a hostname, you have to know which host it is referring to. You can
to this by either guessing (from the realm) which domain name to
append, or you have to have a list of possible hostnames. In the
simplest cases you can cover most principals with the first rule. If you
have several domains sharing a single realm this will not usually work.
If the exceptions are few you can probably come by with a lookup table
for the exceptions.

In a complex scenario you will need some kind of host lookup mechanism.
Using DNS for this is tempting, but DNS is error prone, slow and unsafe
(2).

Fortunately, the KDC has a trump on hand: it can easily tell if a
principal exists in the database. The KDC will use
`krb5_425_conv_principal_ext' to convert principals when handling to
version 4 requests.

---------- Footnotes ----------

(1) the other way is not always trivial either, but usually easier

(2) at least until secure DNS is commonly available


File: heimdal.info,  Node: Converting a version 4 database,  Next: kaserver,  Prev: Principal conversion issues,  Up: Kerberos 4 issues

Converting a version 4 database
===============================

If you want to convert an existing version 4 database, the principal
conversion issue arises too.

If you decide to convert your database once and for all, you will only
have to do this conversion once. It is also possible to run a version 5
KDC as a slave to a version 4 KDC. In this case this conversion will
happen every time the database is propagated.  When doing this
conversion, there are a few things to look out for. If you have stale
entries in the database, these entries will not be converted. This might
be because these principals are not used anymore, or it might be just
because the principal couldn't be converted.

You might also see problems with a many-to-one mapping of principals.
For instance, if you are using DNS lookups and you have two principals
`rcmd.foo' and `rcmd.bar', where `foo' is a CNAME for `bar', the
resulting principals will be the same. Since the conversion function
can't tell which is correct, these conflicts will have to be resolved
manually.

Conversion example
------------------

Given the following set of hosts and services:

     foo.se          rcmd
     mail.foo.se     rcmd, pop
     ftp.bar.se      rcmd, ftp

you have a database that consists of the following principals:

`rcmd.foo', `rcmd.mail', `pop.mail', `rcmd.ftp', and `ftp.ftp'.

lets say you also got these extra principals: `rcmd.gone',
`rcmd.old-mail', where `gone.foo.se' was a machine that has now passed
away, and `old-mail.foo.se' was an old mail machine that is now a CNAME
for `mail.foo.se'.

When you convert this database you want the following conversions to be
done:
     rcmd.foo         host/foo.se
     rcmd.mail        host/mail.foo.se
     pop.mail         pop/mail.foo.se
     rcmd.ftp         host/ftp.bar.se
     ftp.ftp          ftp/ftp.bar.se
     rcmd.gone        removed
     rcmd.old-mail    removed

A `krb5.conf' that does this looks like:

     [realms]
             FOO.SE = {
                     v4_name_convert = {
                             host = {
                                     ftp = ftp
                                     pop = pop
                                     rcmd = host
                             }
                     }
                     v4_instance_convert = {
                             foo = foo.se
                             ftp = ftp.bar.se
                     }
                     default_domain = foo.se
             }

The `v4_name_convert' section says which names should be considered
having an instance consisting of a hostname, and it also says how the
names should be converted (for instance `rcmd' should be converted to
`host'). The `v4_instance_convert' section says how a hostname should
be qualified (this is just a hosts-file in disguise). Host-instances
that aren't covered by `v4_instance_convert' are qualified by appending
the contents of the `default_domain'.

Actually, this example doesn't work. Or rather, it works to well. Since
it has no way of knowing which hostnames are valid and which are not, it
will happily convert `rcmd.gone' to `host/gone.foo.se'. This isn't a
big problem, but if you have run your kerberos realm for a few years,
chances are big that you have quite a few `junk' principals.

If you don't want this you can remove the `default_domain' statement,
but then you will have to add entries for _all_ your hosts in the
`v4_instance_convert' section.

Instead of doing this you can use DNS to convert instances. This is not
a solution without problems, but it is probably easier than adding lots
of static host entries.

To enable DNS lookup you should turn on `v4_instance_resolve' in the
`[libdefaults]' section.

Converting a database
---------------------

The database conversion is done with `hprop'. You can run this command
to propagate the database to the machine called `slave-server' (which
should be running a `hpropd').

     hprop --source=krb4-db --master-key=/.m slave-server

This command can also be to use for converting the v4 database on the
server:

     hprop -n --source=krb4-db -d /var/kerberos/principal --master-key=/.m | hpropd -n

Version 4 Kadmin
================

`kadmind' can act as a version 4 kadmind, and you can do most
operations, but with some restrictions (since the version 4 kadmin
protocol is, lets say, very ad hoc.) One example is that it only passes
des keys when creating principals and changing passwords (modern kpasswd
clients do send the password, so it's possible to to password quality
checks). Because of this you can only create principals with des keys,
and you can't set any flags or do any other fancy stuff.

To get this to work, you have to add another entry to inetd (since
version 4 uses port 751, not 749).

_And then there are a many more things you can do; more on this in a
later version of this manual. Until then, UTSL._


File: heimdal.info,  Node: kaserver,  Prev: Converting a version 4 database,  Up: Kerberos 4 issues

kaserver
========

kaserver emulation
------------------

The Heimdal kdc can emulate a kaserver. The kaserver is a Kerberos 4
server with pre-authentication using Rx as the on-wire protocol. The kdc
contains a minimalistic Rx implementation.

There are three parts of the kaserver; KAA (Authentication), KAT (Ticket
Granting), and KAM (Maintenance). The KAA interface and KAT interface
both passes over DES encrypted data-blobs (just like the
Kerberos-protocol) and thus do not need any other protection.  The KAM
interface uses `rxkad' (Kerberos authentication layer for Rx) for
security and data protection, and is used for example for changing
passwords.  This part is not implemented in the kdc.

Another difference between the ka-protocol and the Kerberos 4 protocol
is that the pass-phrase is salted with the cellname in the `string to
key' function in the ka-protocol, while in the Kerberos 4 protocol there
is no salting of the password at all. To make sure AFS-compatible keys
are added to each principals when they are created or their password are
changed, `afs3-salt' should be added to `[kadmin]default_keys'.

Transarc AFS Windows client
---------------------------

The Transarc Windows client uses Kerberos 4 to obtain tokens, and thus
does not need a kaserver. The Windows client assumes that the Kerberos
server is on the same machine as the AFS-database server. If you do not
like to do that you can add a small program that runs on the database
servers that forward all kerberos requests to the real kerberos server.
A program that does this is `krb-forward'
(<ftp://ftp.stacken.kth.se/pub/projekts/krb-forward>).


File: heimdal.info,  Node: Windows 2000 compatability,  Next: Programming with Kerberos,  Prev: Kerberos 4 issues,  Up: Top

Windows 2000 compatability
**************************

Windows 2000 (formerly known as Windows NT 5) from Microsoft implements
Kerberos 5.  Their implementation, however, has some quirks,
peculiarities, and bugs.  This chapter is a short summary of the things
that we have found out while trying to test Heimdal against Windows
2000.  Another big problem with the Kerberos implementation in Windows
2000 is that the available documentation is more focused on getting
things to work rather than how they work, and not that useful in
figuring out how things really work.

This information should apply to Heimdal 0.7 and Windows 2000
Professional.  It's of course subject to change all the time and mostly
consists of our not so inspired guesses.  Hopefully it's still somewhat
useful.

* Menu:

* Configuring Windows 2000 to use a Heimdal KDC::
* Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC::
* Create account mappings::
* Encryption types::
* Authorization data::
* Quirks of Windows 2000 KDC::
* Useful links when reading about the Windows 2000::


File: heimdal.info,  Node: Configuring Windows 2000 to use a Heimdal KDC,  Next: Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC,  Prev: Windows 2000 compatability,  Up: Windows 2000 compatability

Configuring Windows 2000 to use a Heimdal KDC
=============================================

You need the command line program called `ksetup.exe' which is available
in the file `SUPPORT/TOOLS/SUPPORT.CAB' on the Windows 2000 Professional
CD-ROM. This program is used to configure the Kerberos settings on a
Workstation.

`Ksetup' store the domain information under the registry key:
`HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\LSA\Kerberos\Domains'.

Use the `kadmin' program in Heimdal to create a host principal in the
Kerberos realm.

     unix% kadmin
     kadmin> ank --password=password host/datan.example.com

The name `datan.example.com' should be replaced with DNS name of the
workstation.

You must configure the workstation as a member of a workgroup, as
opposed to a member in an NT domain, and specify the KDC server of the
realm as follows:
     C:> ksetup /setdomain EXAMPLE.COM
     C:> ksetup /addkdc EXAMPLE.COM kdc.example.com

Set the machine password, i.e. create the local keytab:
     C:> ksetup /setmachpassword password

The password used in `ksetup /setmachpassword' must be the same as the
password used in the `kadmin ank' command.

The workstation must now be rebooted.

A mapping between local NT users and Kerberos principals must be
specified.  You have two choices. First:

     C:> ksetup /mapuser user@MY.REALM nt_user

This will map a user to a specific principal; this allows you to have
other usernames in the realm than in your NT user database. (Don't ask
me why on earth you would want that....)

You can also say:
     C:> ksetup /mapuser * *
The Windows machine will now map any user to the corresponding
principal, for example `nisse' to the principal `nisse@MY.REALM'.
(This is most likely what you want.)


File: heimdal.info,  Node: Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC,  Next: Create account mappings,  Prev: Configuring Windows 2000 to use a Heimdal KDC,  Up: Windows 2000 compatability

Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC
===============================================================

See also the Step-by-Step guide from Microsoft, referenced below.

Install Windows 2000, and create a new controller (Active Directory
Server) for the domain.

By default the trust will be non-transitive. This means that only users
directly from the trusted domain may authenticate. This can be changed
to transitive by using the `netdom.exe' tool. `netdom.exe' can also be
used to add the trust between two realms.

You need to tell Windows 2000 on what hosts to find the KDCs for the
non-Windows realm with `ksetup', see *Note Configuring Windows 2000 to
use a Heimdal KDC::.

This needs to be done on all computers that want enable cross-realm
login with `Mapped Names'.  Then you need to add the inter-realm keys
on the Windows KDC. Start the Domain Tree Management tool (found in
Programs, Administrative tools, Active Directory Domains and Trusts).

Right click on Properties of your domain, select the Trust tab.  Press
Add on the appropriate trust windows and enter domain name and
password. When prompted if this is a non-Windows Kerberos realm, press
OK.

Do not forget to add trusts in both directions (if that's what you
want).

If you want to use `netdom.exe' instead of the Domain Tree Management
tool, you do it like this:

     netdom trust NT.REALM.EXAMPLE.COM /Domain:EXAMPLE.COM /add /realm /passwordt:TrustPassword

You also need to add the inter-realm keys to the Heimdal KDC. There are
some tweaks that you need to do to `krb5.conf' beforehand.

     [libdefaults]
             default_etypes = des-cbc-crc
             default_etypes_des = des-cbc-crc

since otherwise checksum types that are not understood by Windows 2000
will be generated (*note Quirks of Windows 2000 KDC::).

Another issue is salting.  Since Windows 2000 does not seem to
understand Kerberos 4 salted hashes you might need to turn off anything
similar to the following if you have it, at least while adding the
principals that are going to share keys with Windows 2000.

     [kadmin]
             default_keys = v5 v4

So remove v4 from default keys.

What you probably want to use is this:

     [kadmin]
             default_keys = des-cbc-crc:pw-salt arcfour-hmac-md5:pw-salt

Note that before Windows 2003, arcfour-hmac-md5 wasn't supported beteen
Windows realms and Non Windows realms.

Once that is also done, you can add the required inter-realm keys:

     kadmin add krbtgt/NT.REALM.EXAMPLE.COM@EXAMPLE.COM
     kadmin add krbtgt/REALM.EXAMPLE.COM@NT.EXAMPLE.COM

Use the same passwords for both keys.

Do not forget to reboot before trying the new realm-trust (after
running `ksetup'). It looks like it might work, but packets are never
sent to the non-Windows KDC.


File: heimdal.info,  Node: Create account mappings,  Next: Encryption types,  Prev: Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC,  Up: Windows 2000 compatability

Create account mappings
=======================

Start the `Active Directory Users and Computers' tool. Select the View
menu, that is in the left corner just below the real menu (or press
Alt-V), and select Advanced Features. Right click on the user that you
are going to do a name mapping for and choose Name mapping.

Click on the Kerberos Names tab and add a new principal from the
non-Windows domain.

This adds `authorizationNames' entry to the users LDAP entry to the
Active Directory LDAP catalog. When you create users by script you can
add this entry instead.


File: heimdal.info,  Node: Encryption types,  Next: Authorization data,  Prev: Create account mappings,  Up: Windows 2000 compatability

Encryption types
================

Windows 2000 supports both the standard DES encryptions (`des-cbc-crc'
and `des-cbc-md5') and its own proprietary encryption that is based on
MD4 and RC4 that is documented in and is supposed to be described in
`draft-brezak-win2k-krb-rc4-hmac-03.txt'.  New users will get both MD4
and DES keys.  Users that are converted from a NT4 database, will only
have MD4 passwords and will need a password change to get a DES key.


File: heimdal.info,  Node: Authorization data,  Next: Quirks of Windows 2000 KDC,  Prev: Encryption types,  Up: Windows 2000 compatability

Authorization data
==================

The Windows 2000 KDC also adds extra authorization data in tickets.  It
is at this point unclear what triggers it to do this.  The format of
this data is only available under a "secret" license from Microsoft,
which prohibits you implementing it.

A simple way of getting hold of the data to be able to understand it
better is described here.

  1. Find the client example on using the SSPI in the SDK documentation.

  2. Change "AuthSamp" in the source code to lowercase.

  3. Build the program.

  4. Add the "authsamp" principal with a known password to the
     database.  Make sure it has a DES key.

  5. Run `ktutil add' to add the key for that principal to a keytab.

  6. Run `appl/test/nt_gss_server -p 2000 -s authsamp --dump-auth=FILE'
     where FILE is an appropriate file.

  7. It should authenticate and dump for you the authorization data in
     the file.

  8. The tool `lib/asn1/asn1_print' is somewhat useful for analyzing
     the data.


File: heimdal.info,  Node: Quirks of Windows 2000 KDC,  Next: Useful links when reading about the Windows 2000,  Prev: Authorization data,  Up: Windows 2000 compatability

Quirks of Windows 2000 KDC
==========================

There are some issues with salts and Windows 2000.  Using an empty
salt--which is the only one that Kerberos 4 supported, and is therefore
known as a Kerberos 4 compatible salt--does not work, as far as we can
tell from out experiments and users' reports.  Therefore, you have to
make sure you keep around keys with all the different types of salts
that are required.  Microsoft have fixed this issue post Windows 2003.

Microsoft seems also to have forgotten to implement the checksum
algorithms `rsa-md4-des' and `rsa-md5-des'. This can make Name mapping
(*note Create account mappings::) fail if a `des-cbc-md5' key is used.
To make the KDC return only `des-cbc-crc' you must delete the
`des-cbc-md5' key from the kdc using the `kadmin del_enctype' command.

     kadmin del_enctype lha des-cbc-md5

You should also add the following entries to the `krb5.conf' file:

     [libdefaults]
     	default_etypes = des-cbc-crc
     	default_etypes_des = des-cbc-crc

These configuration options will make sure that no checksums of the
unsupported types are generated.


File: heimdal.info,  Node: Useful links when reading about the Windows 2000,  Prev: Quirks of Windows 2000 KDC,  Up: Windows 2000 compatability

Useful links when reading about the Windows 2000
================================================

See also our paper presented at the 2001 usenix Annual Technical
Conference, available in the proceedings or at
`http://www.usenix.org/publications/library/proceedings/usenix01/freenix01/westerlund.html'.

There are lots of texts about Kerberos on Microsoft's web site, here is
a short list of the interesting documents that we have managed to find.

   * Step-by-Step Guide to Kerberos 5 (krb5 1.0) Interoperability:
     `http://www.microsoft.com/windows2000/library/planning/security/kerbsteps.asp'.
     Kerberos GSS-API (in Windows-eze SSPI), Windows as a client in a
     non-Windows KDC realm, adding unix clients to a Windows 2000 KDC,
     and adding cross-realm trust (*note Inter-Realm keys (trust)
     between Windows 2000 and a Heimdal KDC::).

   * Windows 2000 Kerberos Authentication:
     `http://www.microsoft.com/TechNet/win2000/win2ksrv/technote/kerberos.asp'.
     White paper that describes how Kerberos is used in Windows 2000.

   * Overview of Kerberos:
     `http://support.microsoft.com/support/kb/articles/Q248/7/58.ASP'.
     Links to useful other links.

   * Event logging for Kerberos:
     `http://support.microsoft.com/support/kb/articles/Q262/1/77.ASP'.
     Basicly it say that you can add a registry key
     `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters\LogLevel'
     with value DWORD equal to 1, and then you'll get logging in the
     Event Logger.


Other useful programs include these:

   * pwdump2
     `http://www.bindview.com/Support/RAZOR/Utilities/Windows/pwdump2_readme.cfm'


File: heimdal.info,  Node: Programming with Kerberos,  Next: Migration,  Prev: Windows 2000 compatability,  Up: Top

Programming with Kerberos
*************************

First you need to know how the Kerberos model works, go read the
introduction text (*note What is Kerberos?::).

* Menu:

* Kerberos 5 API Overview::
* Walkthru a sample Kerberos 5 client::
* Validating a password in a server application::
* API diffrences to MIT Kerberos::


File: heimdal.info,  Node: Kerberos 5 API Overview,  Next: Walkthru a sample Kerberos 5 client,  Prev: Programming with Kerberos,  Up: Programming with Kerberos

Kerberos 5 API Overview
=======================

Most functions are documenteded in manual pages.  This overview only
tries to point to where to look for a specific function.

Kerberos context
----------------

A kerberos context (`krb5_context') holds all per thread state. All
global variables that are context specific are stored in this struture,
including default encryption types, credential-cache (ticket file), and
default realms.

See the manual pages for `krb5_context(3)' and `krb5_init_context(3)'.

Kerberos authenication context
------------------------------

Kerberos authentication context (`krb5_auth_context') holds all context
related to an authenticated connection, in a similar way to the
kerberos context that holds the context for the thread or process.

The `krb5_auth_context' is used by various functions that are directly
related to authentication between the server/client. Example of data
that this structure contains are various flags, addresses of client and
server, port numbers, keyblocks (and subkeys), sequence numbers, replay
cache, and checksum types.

See the manual page for `krb5_auth_context(3)'.

Keytab management
-----------------

A keytab is a storage for locally stored keys. Heimdal includes keytab
support for Kerberos 5 keytabs, Kerberos 4 srvtab, AFS-KeyFile's, and
for storing keys in memory.

See also manual page for `krb5_keytab(3)'

Kerberos principal
------------------

See also manual page for `krb5_principal(3)'

Kerberos crypto
---------------

See also manual page for `krb5_crypto_init(3)', `krb5_keyblock(3)',
`krb5_create_checksum(3)', and `krb5_encrypt(3)'.


File: heimdal.info,  Node: Walkthru a sample Kerberos 5 client,  Next: Validating a password in a server application,  Prev: Kerberos 5 API Overview,  Up: Programming with Kerberos

Walkthru a sample Kerberos 5 client
===================================

This example contains parts of a sample TCP Kerberos 5 clients, if you
want a real working client, please look in `appl/test' directory in the
Heimdal distribution.

All Kerberos error-codes that are returned from kerberos functions in
this program are passed to `krb5_err', that will print a descriptive
text of the error code and exit. Graphical programs can convert
error-code to a humal readable error-string with the
`krb5_get_err_text(3)' function.

Note that you should not use any Kerberos function before
`krb5_init_context()' have completed successfully. That is the reson
`err()' is used when `krb5_init_context()' fails.

First the client needs to call `krb5_init_context' to initialise the
Kerberos 5 library. This is only needed once per thread in the program.
If the function returns a non-zero value it indicates that either the
Kerberos implemtation is failing or its disabled on this host.

     #include <krb5.h>
     
     int
     main(int argc, char **argv)
     {
             krb5_context context;
     
             if (krb5_context(&context))
                     errx (1, "krb5_context");

Now the client wants to connect to the host at the other end. The
preferred way of doing this is using `getaddrinfo(3)' (for operating
system that have this function implemented), since getaddrinfo is
neutral to the address type and can use any protocol that is available.

             struct addrinfo *ai, *a;
             struct addrinfo hints;
             int error;
     
             memset (&hints, 0, sizeof(hints));
             hints.ai_socktype = SOCK_STREAM;
             hints.ai_protocol = IPPROTO_TCP;
     
             error = getaddrinfo (hostname, "pop3", &hints, &ai);
             if (error)
                     errx (1, "%s: %s", hostname, gai_strerror(error));
     
             for (a = ai; a != NULL; a = a->ai_next) {
                     int s;
     
                     s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
                     if (s < 0)
                             continue;
                     if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
                             warn ("connect(%s)", hostname);
                                 close (s);
                                 continue;
                     }
                     freeaddrinfo (ai);
                     ai = NULL;
             }
             if (ai) {
                         freeaddrinfo (ai);
                         errx ("failed to contact %s", hostname);
             }

Before authenticating, an authentication context needs to be created.
This context keeps all information for one (to be) authenticated
connection (see `krb5_auth_context(3)').

             status = krb5_auth_con_init (context, &auth_context);
             if (status)
                     krb5_err (context, 1, status, "krb5_auth_con_init");

For setting the address in the authentication there is a help function
`krb5_auth_con_setaddrs_from_fd' that does everthing that is needed
when given a connected file descriptor to the socket.

             status = krb5_auth_con_setaddrs_from_fd (context,
                                                      auth_context,
                                                      &sock);
             if (status)
                     krb5_err (context, 1, status,
                               "krb5_auth_con_setaddrs_from_fd");

The next step is to build a server principal for the service we want to
connect to. (See also `krb5_sname_to_principal(3)'.)

             status = krb5_sname_to_principal (context,
                                               hostname,
                                               service,
                                               KRB5_NT_SRV_HST,
                                               &server);
             if (status)
                     krb5_err (context, 1, status, "krb5_sname_to_principal");

The client principal is not passed to `krb5_sendauth(3)' function, this
causes the `krb5_sendauth' function to try to figure it out itself.

The server program is using the function `krb5_recvauth(3)' to receive
the Kerberos 5 authenticator.

In this case, mutual authenication will be tried. That means that the
server will authenticate to the client. Using mutual authenication is
good since it enables the user to verify that they are talking to the
right server (a server that knows the key).

If you are using a non-blocking socket you will need to do all work of
`krb5_sendauth' yourself. Basically you need to send over the
authenticator from `krb5_mk_req(3)' and, in case of mutual
authentication, verifying the result from the server with
`krb5_rd_rep(3)'.

             status = krb5_sendauth (context,
                                     &auth_context,
                                     &sock,
                                     VERSION,
                                     NULL,
                                     server,
                                     AP_OPTS_MUTUAL_REQUIRED,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
             if (status)
                     krb5_err (context, 1, status, "krb5_sendauth");

Once authentication has been performed, it is time to send some data.
First we create a krb5_data structure, then we sign it with
`krb5_mk_safe(3)' using the `auth_context' that contains the
session-key that was exchanged in the
`krb5_sendauth(3)'/`krb5_recvauth(3)' authentication sequence.

             data.data   = "hej";
             data.length = 3;
     
             krb5_data_zero (&packet);
     
             status = krb5_mk_safe (context,
                                    auth_context,
                                    &data,
                                    &packet,
                                    NULL);
             if (status)
                     krb5_err (context, 1, status, "krb5_mk_safe");

And send it over the network.

             len = packet.length;
             net_len = htonl(len);
     
             if (krb5_net_write (context, &sock, &net_len, 4) != 4)
                     err (1, "krb5_net_write");
             if (krb5_net_write (context, &sock, packet.data, len) != len)
                     err (1, "krb5_net_write");

To send encrypted (and signed) data `krb5_mk_priv(3)' should be used
instead. `krb5_mk_priv(3)' works the same way as `krb5_mk_safe(3)',
with the exception that it encrypts the data in addition to signing it.

             data.data   = "hemligt";
             data.length = 7;
     
             krb5_data_free (&packet);
     
             status = krb5_mk_priv (context,
                                    auth_context,
                                    &data,
                                    &packet,
                                    NULL);
             if (status)
                     krb5_err (context, 1, status, "krb5_mk_priv");

And send it over the network.

             len = packet.length;
             net_len = htonl(len);
     
             if (krb5_net_write (context, &sock, &net_len, 4) != 4)
                     err (1, "krb5_net_write");
             if (krb5_net_write (context, &sock, packet.data, len) != len)
                     err (1, "krb5_net_write");

The server is using `krb5_rd_safe(3)' and `krb5_rd_priv(3)' to verify
the signature and decrypt the packet.


File: heimdal.info,  Node: Validating a password in a server application,  Next: API diffrences to MIT Kerberos,  Prev: Walkthru a sample Kerberos 5 client,  Up: Programming with Kerberos

Validating a password in an application
=======================================

See the manual page for `krb5_verify_user(3)'.


File: heimdal.info,  Node: API diffrences to MIT Kerberos,  Prev: Validating a password in a server application,  Up: Programming with Kerberos

API diffrences to MIT Kerberos
==============================

This section is somewhat disorganised, but so far there is no overall
structure to the differences, though some of the have their root in
that Heimdal uses an ASN.1 compiler and MIT doesn't.

Principal and realms
--------------------

Heimdal stores the realm as a `krb5_realm', that is a `char *'.  MIT
Kerberos uses a `krb5_data' to store a realm.

In Heimdal `krb5_principal' doesn't contain the component `name_type';
it's instead stored in component `name.name_type'. To get and set the
nametype in Heimdal, use `krb5_principal_get_type(3)' and
`krb5_principal_set_type(3)'.

For more information about principal and realms, see
`krb5_principal(3)'.

Error messages
--------------

To get the error string, Heimdal uses `krb5_get_error_string(3)' or, if
`NULL' is returned, `krb5_get_err_text(3)'. This is to return custom
error messages (like "Can't find host/datan.example.com@EXAMPLE.COM in
/etc/krb5.conf." instead of a "Key table entry not found" that
`error_message(3)' returns.

Heimdal uses a threadsafe(r) version of the com_err interface; the
global `com_err' table isn't initialised.  Then `error_message(3)'
returns quite a boring error string (just the error code itself).


File: heimdal.info,  Node: Migration,  Next: Acknowledgments,  Prev: Programming with Kerberos,  Up: Top

Migration
*********

General issues
==============

When migrating from a Kerberos 4 KDC.

Order in what to do things:
===========================

   * Convert the database, check all principals that hprop complains
     about.

     `hprop -n --source=<NNN>| hpropd -n'

     Replace <NNN> with whatever source you have, like krb4-db or
     krb4-dump.

   * Run a Kerberos 5 slave for a while.

   * Figure out if it does everything you want it to.

     Make sure that all things that you use works for you.

   * Let a small number of controlled users use Kerberos 5 tools.

     Find a sample population of your users and check what programs
     they use, you can also check the kdc-log to check what ticket are
     checked out.

   * Burn the bridge and change the master.

   * Let all users use the Kerberos 5 tools by default.

   * Turn off services that do not need Kerberos 4 authentication.

     Things that might be hard to get away is old programs with support
     for Kerberos 4. Example applications are old Eudora installations
     using KPOP, and Zephyr. Eudora can use the Kerberos 4 kerberos in
     the Heimdal kdc.



File: heimdal.info,  Node: Acknowledgments,  Prev: Migration,  Up: Top

Acknowledgments
***************

Eric Young wrote "libdes". Heimdal used to use libdes, without it
kth-krb would never have existed.

All functions in libdes have been re-implemented or used available
public domain code. The core AES function where written by Vincent
Rijmen, Antoon Bosselaers and Paulo Barreto.  The core DES SBOX
transformation was written by Richard Outerbridge.

The University of California at Berkeley initially wrote `telnet', and
`telnetd'.  The authentication and encryption code of `telnet' and
`telnetd' was added by David Borman (then of Cray Research, Inc).  The
encryption code was removed when this was exported and then added back
by Juha Eskelinen, <esc@magic.fi>.

The `popper' was also a Berkeley program initially.

Some of the functions in `libroken' also come from Berkeley by way of
NetBSD/FreeBSD.

`editline' was written by Simmule Turner and Rich Salz. Heimdal
contains a modifed copy.

The `getifaddrs' implementation for Linux was written by Hideaki
YOSHIFUJI for the Usagi project.

Bugfixes, documentation, encouragement, and code has been contributed
by:
Derrick J Brashear
     <shadow@dementia.org>

Ken Hornstein
     <kenh@cmf.nrl.navy.mil>

Johan Ihrén
     <johani@pdc.kth.se>

Love Hörnquist Åstrand
     <lha@kth.se>

Magnus Ahltorp
     <map@stacken.kth.se>

Mark Eichin
     <eichin@cygnus.com>

Marc Horowitz
     <marc@cygnus.com>

Luke Howard
     <lukeh@PADL.COM>

Brandon S. Allbery KF8NH
     <allbery@kf8nh.apk.net>

Jun-ichiro itojun Hagino
     <itojun@kame.net>

Daniel Kouril
     <kouril@informatics.muni.cz>

Åke Sandgren
     <ake@cs.umu.se>

Michal Vocu
     <michal@karlin.mff.cuni.cz>

Miroslav Ruda
     <ruda@ics.muni.cz>

Brian A May
     <bmay@snoopy.apana.org.au>

Chaskiel M Grundman
     <cg2v@andrew.cmu.edu>

Richard Nyberg
     <rnyberg@it.su.se>

Frank van der Linden
     <fvdl@netbsd.org>

Cizzi Storm
     <cizzi@it.su.se>

Petr Holub
     <Holub.Petr@atlas.cz>

Mario Strasser
     <mario.strasser@zhwin.ch>

David Love
     <fx@gnu.org>

and we hope that those not mentioned here will forgive us.
All bugs were introduced by ourselves.


