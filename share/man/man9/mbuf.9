.\"     $OpenBSD: mbuf.9,v 1.83 2015/02/10 04:08:00 lteo Exp $
.\"
.\" Copyright (c) 2001 Jean-Jacques Bernard-Gundol <jjbg@openbsd.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: February 10 2015 $
.Dt MBUF 9
.Os
.Sh NAME
.Nm mbuf
.\" .Nm ml_init ,
.\" .Nm ml_enqueue ,
.\" .Nm ml_dequeue ,
.\" .Nm ml_dechain ,
.\" .Nm ml_len ,
.\" .Nm ml_empty ,
.\" .Nm MBUF_LIST_INITIALIZER ,
.\" .Nm MBUF_LIST_FOREACH ,
.\" .Nm mq_init ,
.\" .Nm mq_enqueue ,
.\" .Nm mq_dequeue ,
.\" .Nm mq_enlist ,
.\" .Nm mq_delist ,
.\" .Nm mq_dechain ,
.\" .Nm mq_len ,
.\" .Nm mq_empty ,
.\" .Nm mq_drops ,
.\" .Nm mq_set_maxlen ,
.\" .Nm MBUF_QUEUE_INITIALIZER
.Nd kernel memory management for networking protocols
.Sh SYNOPSIS
.In sys/mbuf.h
.Ft struct mbuf *
.Fn m_copym2 "struct mbuf *m" "int off" "int len" "int wait"
.Ft struct mbuf *
.Fn m_copym "struct mbuf *m" "int off" "int len" "int wait"
.Ft struct mbuf *
.Fn m_free "struct mbuf *m"
.Fn MFREE "struct mbuf *m" "struct mbuf *n"
.Ft struct mbuf *
.Fn m_get "int how" "int type"
.Fn MGET "struct mbuf *m" "int how" "int type"
.Ft struct mbuf *
.Fn m_getclr "int how" "int type"
.Ft struct mbuf *
.Fn m_gethdr "int how" "int type"
.Fn MGETHDR "struct mbuf *m" "int how" "int type"
.Ft struct mbuf *
.Fn m_prepend "struct mbuf *m" "int len" "int how"
.Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
.Ft struct mbuf *
.Fn m_pulldown "struct mbuf *m" "int off" "int len" "int *offp"
.Ft struct mbuf *
.Fn m_pullup "struct mbuf *n" "int len"
.Ft struct mbuf *
.Fn m_split "struct mbuf *m0" "int len0" "int wait"
.Ft struct mbuf *
.Fn m_inject "struct mbuf *m0" "int len0" "int siz" "int wait"
.Ft struct mbuf *
.Fn m_getptr "struct mbuf *m" "int loc" "int *off"
.Ft void
.Fn m_adj "struct mbuf *mp" "int req_len"
.Ft int
.Fn m_copyback "struct mbuf *m0" "int off" "int len" "const void *cp" "int wait"
.Ft int
.Fn m_defrag "struct mbuf *m" "int wait"
.Ft void
.Fn m_freem "struct mbuf *m"
.Ft void
.Fn m_reclaim "void"
.Ft void
.Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
.Ft void
.Fn m_cat "struct mbuf *m" "struct mbuf *n"
.Ft struct mbuf *
.Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp"
.Ft int
.Fn m_apply "struct mbuf *m" "int off" "int len" \
"int (*func)(caddr_t, caddr_t, unsigned int)" "caddr_t fstate"
.Fn MCLGET "struct mbuf *m" "int how"
.Ft struct mbuf *
.Fn MCLGETI "struct mbuf *m" "int how" "struct ifnet *ifp" "int len"
.Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int flags" \
"void (*free)(caddr_t, u_int, void *)" "void *arg"
.Fn M_ALIGN "struct mbuf *m" "int len"
.Fn MH_ALIGN "struct mbuf *m" "int len"
.Fn M_READONLY "struct mbuf *m"
.Fn M_LEADINGSPACE "struct mbuf *m"
.Fn M_TRAILINGSPACE "struct mbuf *m"
.Ft int
.Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from" "int how"
.Ft void
.Fn "ml_init" "struct mbuf_list *ml"
.Ft void
.Fn "ml_enqueue" "struct mbuf_list *ml" "struct mbuf *m"
.Ft struct mbuf *
.Fn "ml_dequeue" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fn "ml_dechain" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fo ml_filter
.Fa "struct mbuf_list *ml"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
.Ft unsigned int
.Fn "ml_len" "struct mbuf_list *ml"
.Ft int
.Fn "ml_empty" "struct mbuf_list *ml"
.Ft struct mbuf_list
.Fn "MBUF_LIST_INITIALIZER"
.Fn "MBUF_LIST_FOREACH" "struct mbuf_list *ml" "VARNAME"
.Fn "mq_init" "struct mbuf_queue *mq" "unsigned int maxlen" "int ipl"
.Ft int
.Fn "mq_enqueue" "struct mbuf_queue *mq" "struct mbuf *m"
.Ft struct mbuf *
.Fn "mq_dequeue" "struct mbuf_queue *mq"
.Ft int
.Fn "mq_enlist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
.Ft void
.Fn "mq_delist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fn "mq_dechain" "struct mbuf_queue *mq"
.Ft struct mbuf *
.Fo mq_filter
.Fa "struct mbuf_queue *mq"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
.Ft unsigned int
.Fn "mq_len" "struct mbuf_queue *mq"
.Ft int
.Fn "mq_empty" "struct mbuf_queue *mq"
.Ft unsigned int
.Fn "mq_drops" "struct mbuf_queue *mq"
.Ft void
.Fn "mq_set_maxlen" "struct mbuf_queue *mq" "unsigned int"
.Ft struct mbuf_queue
.Fn "MBUF_QUEUE_INITIALIZER" "unsigned int maxlen" "int ipl"
.Bd -literal
#define MSIZE           256

#define MLEN            (MSIZE - sizeof(struct m_hdr))
#define MHLEN           (MLEN - sizeof(struct pkthdr))

#define MAXMCLBYTES     (64 * 1024)
#define MINCLSIZE       (MHLEN + MLEN + 1)
#define M_MAXCOMPRESS   (MHLEN / 2)

#define MCLSHIFT        11

#define MCLBYTES        (1 << MCLSHIFT)
#define MCLOFSET        (MCLBYTES - 1)

#define mtod(m,t)       ((t)((m)-\*(Gtm_data))

struct m_hdr {
        struct  mbuf *mh_next;
        struct  mbuf *mh_nextpkt;
        caddr_t mh_data;
        u_int   mh_len;
        short   mh_type;
        u_short mh_flags;
};

struct pkthdr {
	struct  ifnet *rcvif;
	SLIST_HEAD(packet_tags, m_tag) tags;
	int     len;
	u_int16_t tagsset;
	u_int16_t pad;
	u_int16_t csum_flags;
	u_int16_t ether_vtag;
	u_int	 ph_rtableid;
	void	*ph_cookie;
	struct	pkthdr_pf pf;
};

struct pkthdr_pf {
	struct pf_state_key *statekey;
	struct inpcb *inp;
	u_int32_t qid;
	u_int16_t tag;
	u_int8_t  flags;
	u_int8_t  routed;
	u_int8_t  prio;
	u_int8_t  pad[3];
};

struct mbuf_ext {
	caddr_t ext_buf;
	void    (*ext_free)(caddr_t, u_int, void *);
	void    *ext_arg;
	u_int   ext_size;
	struct mbuf *ext_nextref;
	struct mbuf *ext_prevref;
};

struct mbuf {
        struct  m_hdr m_hdr;
        union {
                struct {
                        struct  pkthdr MH_pkthdr;
                        union {
                                struct  mbuf_ext MH_ext;
                                char    MH_databuf[MHLEN];
                        } MH_dat;
                } MH;
                char    M_databuf[MLEN];
        } M_dat;
};

#define m_next          m_hdr.mh_next
#define m_len           m_hdr.mh_len
#define m_data          m_hdr.mh_data
#define m_type          m_hdr.mh_type
#define m_flags         m_hdr.mh_flags
#define m_nextpkt       m_hdr.mh_nextpkt
#define m_pkthdr        M_dat.MH.MH_pkthdr
#define m_ext           M_dat.MH.MH_dat.MH_ext
#define m_pktdat        M_dat.MH.MH_dat.MH_databuf
#define m_dat           M_dat.M_databuf
.Ed
.Sh DESCRIPTION
The
.Nm
functions provide a way to manage the memory buffers used by the kernel's
networking subsystem.
Several functions and macros are used to allocate and deallocate mbufs,
but also to get, inject, remove, copy, modify, prepend or append data
inside these mbufs.
The size of an
.Nm
is defined by MSIZE.
.Pp
An
.Nm
structure is defined as an
.Fa m_hdr
structure followed by a
union.
The header contains the following elements:
.Bl -tag -width foobarmoocow
.It Fa mh_next
A pointer to the next mbuf in the mbuf chain.
.It Fa mh_nextpkt
A pointer to the next mbuf chain (i.e., packet) in the queue.
.It Fa mh_data
Indicates the address of the beginning of data in the mbuf.
.It Fa mh_len
Indicates the amount of data in the mbuf.
.It Fa mh_type
Indicates the type of data contained in the mbuf (see below).
.It Fa mh_flags
Flags (see below).
.El
.Pp
The
.Fa mh_type
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv MT_FREE
the mbuf should be on the free list.
.It Dv MT_DATA
the data in the mbuf was dynamically allocated.
.It Dv MT_HEADER
the data contains a packet header.
.It Dv MT_SONAME
the data is a socket name.
.It Dv MT_SOOPTS
the data are socket options.
.It Dv MT_FTABLE
the data is a fragment reassembly header.
.It Dv MT_CONTROL
the mbuf contains extra-data protocol message.
.It Dv MT_OOBDATA
the data consists of out-of-band data.
.El
.Pp
The
.Fa mh_flags
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv M_EXT
mbuf has associated external storage.
.It Dv M_PKTHDR
the mbuf is the first that forms a packet.
.It Dv M_EOR
end of record.
.It Dv M_EXTWR
external storage is writable.
.It Dv M_PROTO1
protocol-specific.
.It Dv M_VLANTAG
.Fa m_pkthdr.ether_vtag
variable is valid.
.It Dv M_LOOP
for mbuf statistics.
.It Dv M_FILDROP
dropped by
.Xr bpf 4
filter.
.It Dv M_BCAST
packet send/received as link-level broadcast.
.It Dv M_MCAST
packet send/received as link-level multicast.
.It Dv M_CONF
packet was encrypted (ESP-transport).
.It Dv M_AUTH
packet was authenticated (AH or ESP).
.It Dv M_TUNNEL
header was IP-in-IP encapsulated by tunnel mode IPsec.
.It Dv M_ZEROIZE
Zero the data part of the mbufs in the mbuf chain pointed to by
.Nm m_free .
.It Dv M_COMP
header was decompressed.
.It Dv M_LINK0
link layer specific flag.
.El
.Pp
An external cluster is used when the data to hold in the mbuf is
large.
The size of an external cluster is between MCLBYTES and MAXMCLBYTES.
A cluster should be used when the size of the data reach MINCLSIZE
(the minimum size to be held by an external cluster).
.Pp
The combination of the M_EXT and M_PKTHDR flags give four types of
mbuf.
When none of these constants are in use, the mbuf is a "normal"
one, where the data part of the mbuf has the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_dat
buffer holding the data (size MLEN).
.El
.Pp
When only M_PKTHDR is set, the data contained in the mbuf is a packet header.
The data itself is contained in the mbuf (just like the previous case),
but part of the mbuf is used to store a packet header.
The data part has then the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_pkthdr
packet header, containing the length of the data, a pointer to the
interface on which the data was received, checksum information
and list of
.Xr mbuf_tags 9 .
.It Fa m_pktdat
buffer holding the data (size MHLEN).
.El
.Pp
The
.Fa m_pkthdr.csum_flags
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv M_IPV4_CSUM_OUT
IPv4 checksum needed.
.It Dv M_TCP_CSUM_OUT
TCP checksum needed.
.It Dv M_UDP_CSUM_OUT
UDP checksum needed.
.It Dv M_ICMP_CSUM_OUT
ICMP/ICMPv6 checksum needed.
.It Dv M_IPV4_CSUM_IN_OK
IPv4 checksum verified.
.It Dv M_IPV4_CSUM_IN_BAD
IPv4 checksum bad.
.It Dv M_TCP_CSUM_IN_OK
TCP checksum verified.
.It Dv M_TCP_CSUM_IN_BAD
TCP checksum bad.
.It Dv M_UDP_CSUM_IN_OK
UDP checksum verified.
.It Dv M_UDP_CSUM_IN_BAD
UDP checksum bad.
.It Dv M_ICMP_CSUM_IN_OK
ICMP/ICMPv6 checksum verified.
.It Dv M_ICMP_CSUM_IN_BAD
ICMP/ICMPv6 checksum bad.
.El
.Pp
When only M_EXT flag is set, an external storage buffer is being used to
hold the data, which is no longer stored in the mbuf.
The data part of the mbuf has now the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_pkthdr
a packet header, just like the previous case, but it is empty.
No information is stored here.
.It Fa m_ext
a structure containing information about the external storage
buffer.
The information consists of the address of the external buffer,
a pointer to the function used to free the buffer, a pointer to the
arguments of the function, the size of the buffer, the type of the
buffer, and pointers to the previous and next mbufs using this
cluster.
.El
.Pp
When both the M_EXT and M_PKTHDR flags are set, an external storage buffer
is being used to store the data and this data contains a packet header.
The structure used is the same as the previous one except that the
.Fa m_pkthdr
element is not empty, it contains the same information as when
M_PKTHDR is used alone.
.Bl -tag -width Ds
.It Fn m_copym "struct mbuf *m" "int off" "int len" "int wait"
Copy an mbuf chain starting at
.Fa off
bytes from the beginning
and continuing for
.Fa len
bytes.
If
.Fa off
is zero and
.Fa m
has the M_PKTHDR flag set,
the header is copied.
If
.Fa len
is M_COPYALL
the whole mbuf is copied.
The
.Fa wait
parameter can be M_WAIT or
M_DONTWAIT.
It does not copy clusters, it just increases their reference count.
.It Fn m_copym2 "struct mbuf *m" "int off" "int len" "int wait"
The same as
.Fn m_copym
except that it copies cluster mbufs, whereas
.Fn m_copym
just increases the reference count of the clusters.
.It Fn m_free "struct mbuf *m"
Free the mbuf pointed to by
.Fa m .
A pointer to the successor of the mbuf,
if it exists, is returned by the function.
.It Fn MFREE "struct mbuf *m" "struct mbuf *n"
Free the mbuf pointed to by
.Fa m
and use
.Fa n
to point to the next mbuf in
the chain if it exists.
See
.Fn m_free .
.It Fn m_get "int how" "int type"
Return a pointer to an mbuf of the type specified.
If the
.Fa how
argument is
.Fa M_WAITOK ,
the function may call
.Xr tsleep 9
to await resources.
If
.Fa how
is
.Fa M_DONTWAIT
and resources are not available,
.Fn m_get
returns NULL.
.It Fn MGET "struct mbuf *m" "int how" "int type"
Return a pointer to an mbuf in
.Fa m
of the type specified.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_getclr "int how" "int type"
Return a pointer to an mbuf of the type specified, and clear the data
area of the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_gethdr "int how" "int type"
Return a pointer to an mbuf of the type specified after initializing
it to contain a packet header.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MGETHDR "struct mbuf *m" "int how" "int type"
Return a pointer to an mbuf of the type specified after initializing
it to contain a packet header.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_prepend "struct mbuf *m" "int len" "int how"
Allocate a new mbuf and prepend it to the mbuf chain pointed to by
.Fa m .
If
.Fa m
points to an mbuf with a packet header, it is moved to the new
mbuf that has been prepended.
The return value is a pointer on the new mbuf chain.
If this function fails to allocate a new mbuf,
.Fa m
is freed.
See
.Fn m_get
for a description of
.Fa how .
.Pp
.Fn m_prepend
should never be called directly.
Use
.Fn M_PREPEND
instead.
.It Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
Prepend space of size
.Fa plen
to the mbuf pointed to by
.Fa m .
If a new mbuf must be allocated,
.Fa how
specifies whether to wait or not.
If this function fails to allocate a new mbuf,
.Fa m
is freed.
.It Fn m_pulldown "struct mbuf *m" "int off" "int len" "int *offp"
Ensure that the data in the mbuf chain starting at
.Fa off
and ending at
.Fa off+len
will be put in a continuous memory region.
If memory must be allocated, then it will fail if the
.Fa len
argument is greater than MAXMCLBYTES.
The pointer returned points to an mbuf in the chain and the new offset
for data in this mbuf is
.Fa *offp .
If this function fails,
.Fa m
is freed.
.It Fn m_pullup "struct mbuf *n" "int len"
Ensure that the data in the mbuf chain starting at the beginning of
the chain and ending at
.Fa len
will be put in continuous memory region.
If memory must be allocated, then it will fail if the
.Fa len
argument is greater than MAXMCLBYTES.
If this function fails,
.Fa n
is freed.
.It Fn m_split "struct mbuf *m0" "int len0" "int wait"
Split an mbuf chain in two pieces, returning a pointer to
the tail (which is made of the previous mbuf chain except the first
.Fa len0
bytes).
.It Fn m_inject "struct mbuf *m0" "int len0" "int siz" "int wait"
Inject a new mbuf chain of length
.Fa siz
into the mbuf chain pointed to by
.Fa m0
at position
.Fa len0 .
If there is enough space for an object of size
.Fa siz
in the appropriate location, no memory will be allocated.
On failure, the function returns NULL (the mbuf is left untouched) and
on success, a pointer to the first injected mbuf is returned.
.It Fn m_getptr "struct mbuf *m" "int loc" "int *off"
Returns a pointer to the mbuf containing the data located at
.Fa loc
bytes of the beginning.
The offset in the new mbuf is pointed to by
.Fa off .
.It Fn m_adj "struct mbuf *mp" "int req_len"
Trims
.Fa req_len
bytes of data from the mbuf chain pointed to by
.Fa mp .
If
.Fa req_len
is positive, the data will be trimmed from the head of the mbuf chain
and if it is negative, it will be trimmed from the tail of the mbuf
chain.
.It Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp" "int wait"
Copy data from a buffer pointed to by
.Fa cp
back into the mbuf chain pointed to by
.Fa m0
starting at
.Fa off
bytes from the beginning, extending the mbuf chain if
necessary, sleeping for mbufs if
.Fa wait
is
.Fa M_WAIT .
If
.Fa M_NOWAIT
is set and no mbufs are available,
.Fn m_copyback
returns
.Er ENOBUFS .
The mbuf chain must be initialized properly, including setting
.Fa m_len .
.It Fn m_defrag "struct mbuf *m" "int wait"
Defragment the data mbufs referenced by
.Fa m
by replacing the chain with a copy of their contents made into a
single mbuf or cluster.
.Fa wait
specifies whether it can wait or not for the replacement storage.
.Fn m_defrag
returns 0 on success or
.Er ENOBUFS
on failure.
The mbuf pointer
.Fa m
remains in existence and unchanged on failure.
.It Fn m_freem "struct mbuf *m"
Free the mbuf chain pointed to by
.Fa m .
.It Fn m_reclaim "void"
Ask protocols to free unused memory space.
.It Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
Copy data from the mbuf chain pointed to by
.Fa m
starting at
.Fa off
bytes from the beginning and continuing for
.Fa len
bytes into the buffer pointed to by
.Fa cp .
.It Fn m_cat "struct mbuf *m" "struct mbuf *n"
Concatenate the mbuf chain pointed to by
.Fa n
to the mbuf chain pointed to by
.Fa m .
The mbuf chains must be of the same type.
.It Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp"
Copy
.Fa totlen
bytes of data from device local memory pointed to by
.Fa buf .
The data is copied into an mbuf chain at offset
.Fa off
and a pointer to the head of the chain is returned.
Returns NULL on failure.
.It Fn m_apply "struct mbuf *m" "int off" "int len" \
"int (*func)(caddr_t, caddr_t, unsigned int)" "caddr_t fstate"
Apply the function
.Fa func
to the data in the mbuf chain pointed to by
.Fa m
starting at
.Fa off
bytes from the beginning and continuing for
.Fa len
bytes.
.It Fn mtod "struct mbuf *m" "datatype"
Return a pointer to the data contained in the specified mbuf
.Fa m
cast to
.Fa datatype .
.It Fn MCLGET "struct mbuf *m" "int how"
Allocate and add an mbuf cluster to the mbuf pointed to by
.Fa m .
On success, the flag M_EXT is set in the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MCLGETI "struct mbuf *m" "int how" "struct ifnet *ifp" "int len"
If
.Fa m
is NULL, allocate it.
Then allocate and add an mbuf cluster of length
.Fa len
to the mbuf pointed to by
.Fa m .
Returns either the mbuf
.Fa m
that was passed in, or the newly allocated one which was allocated; in
either case the flag M_EXT is set in the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int flags" \
"void (*free)(caddr_t, u_int, void *)" "void *arg"
Add pre-allocated storage to the mbuf pointed to by
.Fa m .
On success, the flag M_EXT is set in the mbuf, and M_EXTWR is specified in
.Fa flags .
.It Fn M_ALIGN "struct mbuf *m" "int len"
Set the
.Fa m_data
pointer of the newly allocated mbuf with
.Fn m_get
or
.Fn MGET
pointed to by
.Fa m
to an object of the specified size
.Fa len
at the end of the mbuf, longword aligned.
.It Fn MH_ALIGN "m" "len"
Same as
.Fn M_ALIGN
except it is for an mbuf allocated with
.Fn m_gethdr
or
.Fn MGETHDR .
.It Fn M_READONLY "struct mbuf *m"
Check if the data of the mbuf pointed to by
.Fa m
is read-only.
This is true for non-cluster external storage and for clusters that
are being referenced by more than one mbuf.
.It Fn M_LEADINGSPACE "struct mbuf *m"
Compute the amount of space available before the current start of data
in the mbuf pointed to by
.Fa m .
.It Fn M_TRAILINGSPACE "struct mbuf *m"
Compute the amount of space available after the end of data in the
mbuf pointed to by
.Fa m .
.It Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from" "int how"
Copy mbuf packet header, including mbuf tags, from
.Fa from
to
.Fa to .
See
.Fn m_get
for a description of
.Fa how .
.El
.Pp
The mbuf list and mbuf queue API provides implementions of data
structures and operations for managing lists of mbufs or for queueing
mbufs and lists of mbufs between contexts.
.Pp
mbuf_list structures support the following functionality:
.Pp
.Bl -enum -compact -offset indent
.It
Insertion of a new mbuf at the end of the list.
.It
Removal of an mbuf from the head of the list.
.It
Removal of the entire chain of mbufs on the list.
.El
.Bl -tag -width Ds
.It Fn "ml_init" "struct mbuf_list *ml"
Initialise the
.Fa ml
mbuf_list structure.
.It Fn "MBUF_LIST_INITIALIZER"
An initialiser for an mbuf_list structure declaration.
.It Fn "ml_enqueue" "struct mbuf_list *ml" "struct mbuf *m"
Enqueue mbuf
.Fa m
on the end of the
.Fa ml
mbuf list.
.It Fn "ml_dequeue" "struct mbuf_list *ml"
Dequeue an mbuf from the front of the
.Fa ml
mbuf list.
.It Fn "ml_dechain" "struct mbuf_list *ml"
Dequeues all mbufs from the
.Fa ml
mbuf list.
.It Fo ml_filter
.Fa "struct mbuf_list *ml"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
Iterates over the mbufs on the
.Fa ml
mbuf list, passing each of them to the
.Fa filter
function.
If the
.Fa filter
returns non-zero, the packet is removed from the
.Fa ml
mbuf list to be returned as part of an mbuf chain by
.Fn ml_filter .
.Fa context
is passed as the first argument to each call of
.Fa filter .
.It Fn "ml_len" "struct mbuf_list *ml"
Return the number of mbufs on the
.Fa ml
mbuf list.
.It Fn "ml_empty" "struct mbuf_list *ml"
Return if the
.Fa ml
mbuf list is empty.
.It Fn "MBUF_LIST_FOREACH" "struct mbuf_list *ml" "VARNAME"
A convenience macro that can be used to iterate over the contents of the
.Fa ml
mbuf list.
.Fa VARNAME
identifies the name (not the address) of an mbuf pointer that will
be set to each entry on the list.
Note that it is unsafe to modify the list while iterating over it.
.El
.Pp
mbuf_queue data structures provide a superset of the functionality
available in mbuf_lists, and protect themselves internally with a
.Xr mutex 9 ,
making them useful for moving mbufs between contexts or subsystems.
Additionally, mbuf_queues provide a limit on the number of mbufs that
may be queued.
The additional functionality mbuf_queues provides is:
.Pp
.Bl -enum -compact -offset indent
.It
Insertion of the mbufs in an mbuf_list at the end of the queue.
.It
Removal of all the mbufs on the queue as an mbuf_list.
.El
.Bl -tag -width Ds
.It Fn "mq_init" "struct mbuf_queue *mq" "unsigned int maxlen" "int ipl"
Initialises the mbuf queue structure
.Fa mq .
The maximum number of mbufs that can be queued is specified with
.Fa maxlen .
The highest interrupt priority level the queue will be operated at is
specified via
.Fa ipl .
.It Fn "MBUF_QUEUE_INITIALIZER" "unsigned int maxlen" "int ipl"
Initialises an mbuf queue structure declaration.
The maximum number of mbufs that can be queued is specified with
.Fa maxlen .
The highest interrupt priority level the queue will be operated at is
specified via
.Fa ipl .
.It Fn "mq_enqueue" "struct mbuf_queue *mq" "struct mbuf *m"
Enqueue mbuf
.Fa m
on the end of the
.Fa mq
mbuf queue.
.It Fn "mq_dequeue" "struct mbuf_queue *mq"
Dequeue an mbuf from the front of the
.Fa mq
mbuf queue.
.It Fn "mq_enlist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
Enqueue all the mbufs on the
.Fa ml
mbuf list on to the end of the
.Fa mq
mbuf queue.
Note, the number of mbufs placed on the queue may exceed its maximum length.
.Fn mq_enqueue .
.It Fn "mq_delist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
Dequeue all the mbufs on the
.Fa mq
mbuf queue on to the
.Fa ml
mbuf list.
.It Fn "mq_dechain" "struct mbuf_queue *mq"
Dequeue all mbufs from the
.Fa mq
mbuf queue.
.It Fo mq_filter
.Fa "struct mbuf_queue *mq"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
Iterates over the mbufs on the
.Fa mq
mbuf queue, passing each of them to the
.Fa filter
function.
If the
.Fa filter
returns non-zero, the packet is removed from the
.Fa mq
mbuf queue to be returned as part of an mbuf chain by
.Fn mq_filter .
.Fa context
is passed as the first argument to each call of
.Fa filter .
.It Fn "mq_len" "struct mbuf_queue *mq"
Return the number of mbufs on the
.Fa ml
mbuf queue.
.It Fn "mq_empty" "struct mbuf_queue *mq"
Return if the
.Fa mq
mbuf queue is empty.
.It Fn "mq_drops" "struct mbuf_queue *mq"
Return how many mbufs were dropped and freed by
.Xr m_freem 9
if the
.Fa mq
mbuf queue was too full.
.It Fn "mq_set_maxlen" "struct mbuf_queue *mq" "unsigned int"
Alter the maximum number of mbufs that can be queued on the
.Fa mq
mbuf queue.
Note,
.Fn mq_set_maxlen
will only set a new limit, it will not free any excess mbufs that may
already exist on the queue.
.El
.Sh CONTEXT
.Fn ml_init ,
.Fn ml_enqueue ,
.Fn ml_dequeue ,
.Fn ml_dechain ,
.Fn ml_len ,
.Fn ml_empty ,
.Fn MBUF_LIST_INITIALIZER ,
.Fn MBUF_LIST_FOREACH ,
.Fn mq_init ,
.Fn mq_enqueue ,
.Fn mq_dequeue ,
.Fn mq_enlist ,
.Fn mq_delist ,
.Fn mq_dechain ,
.Fn mq_len ,
.Fn mq_empty ,
.Fn mq_drops ,
.Fn mq_set_maxlen ,
.Fn MBUF_QUEUE_INITIALIZER
can be called during autoconf, from process context, or from interrupt context.
.Sh RETURN VALUES
.Fn ml_dequeue
and
.Fn mq_dequeue
return the mbuf that was at the head of their respective list or queue.
If the list or queue was empty,
.Dv NULL
is returned.
.Pp
.Fn ml_dechain
and
.Fn mq_dechain
return all the mbufs that were on the respective list or queues via
a pointer to an mbuf with the chain accessible via m_nextpkt members.
If the list or queue was empty,
.Dv NULL
is returned.
.Pp
.Fn ml_filter
and
.Fn mq_filter
return the mbufs that were successfully matched by the filter
function on the respective list or queue via a pointer to a chain
of mbufs.
If no packets matched the filter,
.Dv NULL
is returned.
.Pp
.Fn ml_len
and
.Fn mq_len
return the number of mbufs on the list or queue respectively.
.Pp
.Fn ml_empty
and
.Fn mq_empty
return a non-zero value if the list or queue is empty,
otherwise 0.
.Pp
.Fn mq_enqueue
returns 0 if the mbuf was successfully queued, or non-zero if the
mbuf was freed because it would cause the queue to exceed its maximum
length.
.Pp
.Fn mq_enlist
returns the number of mbufs that were dropped from the list if the
length of the queue exceeded its maximum length.
.Pp
.Fn mq_drops
returns the number of mbufs that were freed during
.Fn mq_enqueue
operations that would have caused the queue to exceed its maximum length.
.Sh CODE REFERENCES
The mbuf management functions are implemented in the files
.Pa sys/kern/uipc_mbuf.c
and
.Pa sys/kern/uipc_mbuf2.c .
The function prototypes and the macros are located in
.Pa sys/sys/mbuf.h .
.Sh SEE ALSO
.Xr netstat 1 ,
.Xr mbuf_tags 9 ,
.Xr mutex 9 ,
.Xr spl 9
.Rs
.%A Jun-Ichiro Hagino
.%T "Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)"
.%B "Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference"
.%D June 2000
.Re
