.\" $OpenBSD: video.4,v 1.9 2011/03/29 20:30:51 jakemsr Exp $
.\"
.\" Copyright (c) 2008 Marcus Glocker <mglocker@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: March 29 2011 $
.Dt VIDEO 4
.Os
.Sh NAME
.Nm video
.Nd device-independent video driver layer
.Sh SYNOPSIS
.Cd "video* at uvideo?"
.Pp
.Fd #include <sys/types.h>
.Fd #include <sys/ioctl.h>
.Fd #include <sys/videoio.h>
.Sh DESCRIPTION
The
.Nm
driver provides support for various video devices.
It provides a uniform programming interface layer
above different underlying video hardware drivers.
The
.Nm
driver uses the V4L2 (Video for Linux Two) API which is widely used by video
applications.
Therefore this document mainly describes the V4L2 API parts
which are supported by the
.Nm
driver.
.Sh IOCTLS
The following
.Xr ioctl 2
commands are supported:
.Bl -tag -width Ds
.It VIDIOC_QUERYCAP (struct v4l2_capability *)
Query device capabilities.
.Bd -literal
struct v4l2_capability {
	u_int8_t	driver[16];
	u_int8_t	card[32];
	u_int8_t	bus_info[32];
	u_int32_t	version;
	u_int32_t	capabilities;
	u_int32_t	reserved[4];
};
.Ed
.It VIDIOC_ENUM_FMT (struct v4l2_fmtdesc *)
Enumerate image formats.
.Bd -literal
struct v4l2_fmtdesc {
	u_int32_t		index;
	enum v4l2_buf_type	flags;
	u_int8_t		description[32];
	u_int32_t		pixelformat;
	u_int32_t		reserved[4];
};
.Ed
.It VIDIOC_S_FMT (struct v4l2_format *)
Set the data format.
.Bd -literal
struct v4l2_format {
	enum v4l2_buf_type	type;
	union {
		struct v4l2_pix_format		pix;
		struct v4l2_window		win;
		struct v4l2_vbi_format		vbi;
		struct v4l2_sliced_vbi_format	sliced;
		u_int8_t			raw_data[200];
        } fmt;
};
.Ed
.It VIDIOC_G_FMT (struct v4l2_format *)
Get the data format.
.Pp
Same structure as for VIDIOC_S_FMT.
.It VIDIOC_ENUMINPUT (struct v4l2_input *)
Enumerate video inputs.
.Bd -literal
struct v4l2_input {
	u_int32_t	index;
	u_int8_t	name[32];
	u_int32_t	type;
	u_int32_t	audioset;
	u_int32_t	tuner;
	v4l2_std_id	std;
	u_int32_t	status;
	u_int32_t	reserved[32];
};
.Ed
.It VIDIOC_S_INPUT (int *)
Select the current video input.
.It VIDIOC_REQBUFS (struct v4l2_requestbuffers *)
Initiate memory mapping or user pointer I/O.
.Bd -literal
struct v4l2_requestbuffers {
	u_int32_t		count;
	enum v4l2_buf_type	type;
	enum v4l2_memory	memory;
	u_int32_t		reserved[2];
};
.Ed
.It VIDIOC_QUERYBUF (struct v4l2_buffer *)
Query the status of a buffer.
.Bd -literal
struct v4l2_buffer {
	u_int32_t		index;
	enum v4l2_buf_type	type;
	u_int32_t		bytesused;
	u_int32_t		flags;
	enum v4l2_field		field;
	struct timeval		timestamp;
	struct v4l2_timecode	timecode;
	u_int32_t		sequence;
	enum v4l2_memory	memory;
	union {
		u_int32_t	offset;
		unsigned long	userptr;
	} m;
	u_int32_t		length;
	u_int32_t		input;
	u_int32_t		reserved;
};
.Ed
.It VIDIOC_QBUF (struct v4l2_buffer *)
Add a buffer to the queue.
.Pp
Same structure as for VIDIOC_QUERYBUF.
.It VIDIOC_DQBUF (struct v4l2_buffer *)
Remove a buffer from the queue.
.Pp
Same structure as for VIDIOC_QUERYBUF.
.It VIDIOC_STREAMON (int *)
Start video stream.
.It Dv VIDIOC_STREAMOFF (int *)
Stop video stream.
.It VIDIOC_TRY_FMT (struct v4l2_format *)
Try a data format.
.Pp
Same structure as for VIDIOC_S_FMT.
.It VIDIOC_ENUM_FRAMEINTERVALS (struct v4l2_frmivalenum *)
Enumerate frame intervals.
.Bd -literal
struct v4l2_frmivalemun {
	u_int32_t		index;
	u_int32_t		pixel_format;
	u_int32_t		width;
	u_int32_t		height;
	u_int32_t		type;
	union {
		struct v4l2_fract		discrete;
		struct v4l2_frmival_stepwise	stepwise;
	} un;
	u_int32_t		reserved[2];
};

struct v4l2_frmival_stepwise {
	struct v4l2_fract min;
	struct v4l2_fract max;
	struct v4l2_fract step;
};
.Ed
.It VIDIOC_S_PARM (struct v4l2_streamparm *)
Set streaming parameters.
.Bd -literal
struct v4l2_streamparm {
	enum v4l2_buf_type	type;
	union {
		struct v4l2_captureparm	capture;
		struct v4l2_outputparm	output;
		u_int8_t		raw_data[200];
	} parm;
};

struct v4l2_captureparm	{
	u_int32_t	capability;
	u_int32_t	capturemode;
	struct v4l2_fract	timeperframe;
	u_int32_t	extendedmode;
	u_int32_t	readbuffers;
	u_int32_t	reserved[4];
};

struct v4l2_outputparm	{
	u_int32_t	capability;
	u_int32_t	outputmode;
	struct v4l2_fract	timeperframe;
	u_int32_t	extendedmode;
	u_int32_t	writebuffers;
	u_int32_t	reserved[4];
};
.Ed
.It VIDIOC_G_PARM (struct v4l2_streamparm *)
Get the streaming parameters.
.Pp
Same structures as for VIDIOC_S_PARM.
.It VIDIOC_QUERYCTRL (struct v4l2_queryctrl *)
Enumerate control items.
.Bd -literal
struct v4l2_queryctrl {
	u_int32_t		id;
	enum v4l2_ctrl_type	type;
	u_int8_t		name[32];
	int32_t			minimum;
	int32_t			maximum;
	int32_t			step;
	int32_t			default_value;
	u_int32_t		flags;
	u_int32_t		reserved[2];
};
.Ed
.El
.Pp
Command independent enumerations are:
.Bd -literal
enum v4l2_buf_type {
	V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
	V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
	V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
	V4L2_BUF_TYPE_VBI_CAPTURE = 4,
	V4L2_BUF_TYPE_VBI_OUTPUT = 5,
	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
	V4L2_BUF_TYPE_PRIVATE = 0x80,
};

enum v4l2_memory {
	V4L2_MEMORY_MMAP = 1,
	V4L2_MEMORY_USERPTR = 2,
	V4L2_MEMORY_OVERLAY = 3,
};

enum v4l2_ctrl_type {
	V4L2_CTRL_TYPE_INTEGER = 1,
	V4L2_CTRL_TYPE_BOOLEAN = 2,
	V4L2_CTRL_TYPE_MENU = 3,
	V4L2_CTRL_TYPE_BUTTON = 4,
	V4L2_CTRL_TYPE_INTEGER64 = 5,
	V4L2_CTRL_TYPE_CTRL_CLASS = 6,
};

enum v4l2_frmivaltypes {
	V4L2_FRMIVAL_TYPE_DISCRETE = 1,
	V4L2_FRMIVAL_TYPE_CONTINUOUS = 2,
	V4L2_FRMIVAL_TYPE_STEPWISE = 3,
};
.Ed
.Pp
Command independent structures are:
.Bd -literal
struct v4l2_pix_format {
	u_int32_t		width;
	u_int32_t		height;
	u_int32_t		pixelformat;
	enum v4l2_field		field;
	u_int32_t		bytesperline;
	u_int32_t		sizeimage;
	enum v4l2_colorspace	colorspace;
	u_int32_t		priv;
};

struct v4l2_window {
	struct v4l2_rect	 w;
	enum v4l2_field		 chromakey;
	struct v4l2_clip	 __user *clips;
	u_int32_t		 clipcount;
	void __user		*bitmap;
	u_int8_t		 global_alpha;
};

struct v4l2_vbi_format {
	u_int32_t		sampling_rate;
	u_int32_t		offset;
	u_int32_t		samples_per_line;
	u_int32_t		sample_format;
	int32_t			start[2];
	u_int32_t		count[2];
	u_int32_t		flags;
	u_int32_t		reserved[2];
};

struct v4l2_sliced_vbi_format {
	u_int16_t	service_set;
	u_int16_t	service_lines[2][24];
	u_int32_t	io_size;
	u_int32_t	reserved[2];
};

struct v4l2_fract {
	u_int32_t	numerator;
	u_int32_t	denominator;
};
.Ed
.Pp
Command independent typedefs are:
.Bd -literal
typedef u_int64_t	v4l2_std_id;
.Ed
.Sh READ
Video data can be accessed via the
.Xr read 2
system call.
The main iteration for userland applications occurs as follow:
.Pp
.Bl -enum -compact -offset indent
.It
Open /dev/video* via the
.Xr open 2
system call.
.It
Read video data from the device via the
.Xr read 2
system call.
The video stream will be started automatically with the first
read, which means there is no need to issue a VIDIOC_STREAMON command.
The read will always return a consistent video frame, if no error occurs.
.It
Process video data and start over again with step 2.
.It
When finished stop the video stream via the
.Xr close 2
system call.
.El
.Pp
The
.Xr select 2
and
.Xr poll 2
system calls are supported for this access type.
They will signal when a frame is ready for reading without blocking.
.Sh MMAP
Video data can be accessed via the
.Xr mmap 2
system call.
The main iteration for userland applications occurs as follow:
.Pp
.Bl -enum -compact -offset indent
.It
Open /dev/video* via the
.Xr open 2
system call.
.It
Request desired number of buffers via the VIDIOC_REQBUFS ioctl command.
The maximum number of available buffers is normally limited by the hardware
driver.
.It
Get the length and offset for the previously requested buffers via the
VIDIOC_QUERYBUF ioctl command and map the buffers via the
.Xr mmap 2
system call.
.It
Initially queue the buffers via the VIDIOC_QBUF ioctl command.
.It
Start the video stream via the VIDIOC_STREAMON ioctl command.
.It
Dequeue one buffer via the VIDIOC_DQBUF ioctl command.
If the queue is empty
the ioctl will block until a buffer gets queued or an error occurs
(e.g. a timeout).
.It
Requeue the buffer via the VIDIOC_QBUF ioctl command.
.It
Process video data and start over again with step 6.
.It
When finished stop the video stream via the VIDIOC_STREAMOFF ioctl command.
.El
.Pp
The
.Xr select 2
and
.Xr poll 2
system calls are supported for this access type.
They will signal when at least one frame is ready for dequeuing,
allowing to call the VIDIOC_DQBUF ioctl command without blocking.
.Sh FILES
.Bl -tag -width /dev/video -compact
.It Pa /dev/video
.El
.Sh SEE ALSO
.Xr ioctl 2 ,
.Xr uvideo 4
.Sh HISTORY
The
.Nm
driver first appeared in
.Ox 4.4 .
