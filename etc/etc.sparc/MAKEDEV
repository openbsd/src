#!/bin/sh -
#
#	$OpenBSD: MAKEDEV,v 1.12 1996/12/06 10:49:47 deraadt Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	@(#)MAKEDEV	5.5 (Berkeley) 5/28/91
#
# Device "make" file.  Valid arguments:
#	std	standard devices
#	local	configuration specific devices
# Tapes:
#	st*	? tape
# Disks:
#	sd*	SCSI disks
#	cd*	SCSI cdrom drives
#	st*	SCSI tape
#	ch*	SCSI changer
#	uk*	unknown SCSI
#	ss*	SCSI scanners
#	xy*	Xylogic 450/451 disks
#	xd*	Xylogic 753/7053 disks
#	fd*	Floppies
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
# Printers:
# Call units:
# Special purpose devices:
#	audio
#	openprom
#	bwtwo*
#	cgthree*
#	cgfour*
#	cgsix*
#	cgeight*
#	bpf*	packet filter
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	random data source

PATH=/sbin:/bin/:/usr/bin:/usr/sbin:/usr/etc
umask 77

for i
do

unit=`expr $i : '[a-z][a-z]*\([0-9][0-9]*\)'`
[ "$unit" ] || unit=0

case $i in

all)
	sh MAKEDEV std sd0 sd1 sd2 sd3 sd4 xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3
	sh MAKEDEV cd0 st0 st1
	sh MAKEDEV fd0 fdB0 fdC0 fdD0 fdE0 fdF0 fdG0 fdH0
	sh MAKEDEV uk0 uk1
	sh MAKEDEV ss0 ss1
	sh MAKEDEV pty0 vnd0 vnd1 vnd2 vnd3 audio tun0 tun1 tun2 tun3
	sh MAKEDEV ccd0 ccd1 ccd2 ccd3
	sh MAKEDEV bpf0 bpf1 bpf2 bpf3 ipl bwtwo0 cgthree0 cgfour0 cgsix0
	sh MAKEDEV cgeight0
	sh MAKEDEV lkm random local
	;;
std)
	mknod console		c 0 0
	mknod tty		c 2 0	; chmod 666 tty
	mknod kmem		c 3 1	; chmod 640 kmem ; chown root.kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chown root.kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12	; chmod 666 zero
	mknod eeprom		c 3 11  ; chmod 640 eeprom ; chown root.kmem eeprom
	mknod openprom		c 70 0  ; chmod 644 openprom
	mknod drum		c 7 0	; chmod 640 drum ; chown root.kmem drum
	mknod klog		c 16 0	; chmod 600 klog
	mknod stdin		c 24 0	; chmod 666 stdin
	mknod stdout		c 24 1	; chmod 666 stdout
	mknod stderr		c 24 2	; chmod 666 stderr
	mkdir fd > /dev/null 2>&1
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
			printf("mknod %d c 24 %d;", i, i)}'`)
	chown -R bin.bin fd
	chmod 555 fd
	chmod 666 fd/*

	mknod ttya		c 12 0
	mknod ttyb		c 12 1
	mknod fb		c 22 0 ; chmod 666 fb
	mknod mouse		c 13 0 ; chmod 666 mouse
	mknod kbd		c 29 0 ; chmod 666 kbd
	;;

bwtwo*)
	mknod bwtwo$unit	c 27 $unit; chmod 666 bwtwo$unit
	;;

cgthree*)
	mknod cgthree$unit	c 55 $unit; chmod 666 cgthree$unit
	;;

cgfour*)
	mknod cgfour$unit	c 39 $unit; chmod 666 cgfour$unit
	;;

cgsix*)
	mknod cgsix$unit	c 67 $unit; chmod 666 cgsix$unit
	;;

cgeight*)
	mknod cgeight$unit	c 64 $unit; chmod 666 cgeight$unit
	;;

audio)
	mknod audio		c 69 0; chmod 666 audio
	;;

openprom)
	mknod openprom		c 70 0; chmod 600 openprom
	;;

bpf*)
	rm -f bpf$unit
	mknod bpf$unit c 105 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

ipl)
	mknod ipl c 59 0
	chown root.wheel ipl
	;;

tun*)
	rm -f tun$unit
	mknod tun$unit c 111 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
	;;

fd*)
	umask 2 ; unit=`expr $i : 'fd.*\(.\)$'`
	typnam=`expr $i : 'fd\(.\).*'`
	case $typnam in
	0|1)		typnam=; typnum=0;;	# no type specified, assume A
	A)		typnam=; typnum=0;;
	B)		typnum=1;;
	C)		typnum=2;;
	D)		typnum=3;;
	E)		typnum=4;;
	F)		typnum=5;;
	G)		typnum=6;;
	H)		typnum=7;;
	*)		echo bad type $typnam for $i; exit 1;;
	esac
	case $unit in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $unit for $i; exit 1;;
	esac
	nam=fd${typnam}${unit}
	rm -f ${nam}? r${nam}?
	basenum=`expr $unit '*' 128 + $typnum '*' 16`
	mknod ${nam}a	b $blk `expr $basenum + 0`
	mknod ${nam}b	b $blk `expr $basenum + 1`
	mknod ${nam}c	b $blk `expr $basenum + 2`
	#mknod ${nam}d	b $blk `expr $basenum + 3`
	#mknod ${nam}e	b $blk `expr $basenum + 4`
	#mknod ${nam}f	b $blk `expr $basenum + 5`
	#mknod ${nam}g	b $blk `expr $basenum + 6`
	#mknod ${nam}h	b $blk `expr $basenum + 7`
	#mknod ${nam}i	b $blk `expr $basenum + 8`
	#mknod ${nam}j	b $blk `expr $basenum + 9`
	#mknod ${nam}k	b $blk `expr $basenum + 10`
	#mknod ${nam}l	b $blk `expr $basenum + 11`
	#mknod ${nam}m	b $blk `expr $basenum + 12`
	#mknod ${nam}n	b $blk `expr $basenum + 13`
	#mknod ${nam}o	b $blk `expr $basenum + 14`
	#mknod ${nam}p	b $blk `expr $basenum + 15`
	mknod r${nam}a	c $chr `expr $basenum + 0`
	mknod r${nam}b	c $chr `expr $basenum + 1`
	mknod r${nam}c	c $chr `expr $basenum + 2`
	#mknod r${nam}d	c $chr `expr $basenum + 3`
	#mknod r${nam}e	c $chr `expr $basenum + 4`
	#mknod r${nam}f	c $chr `expr $basenum + 5`
	#mknod r${nam}g	c $chr `expr $basenum + 6`
	#mknod r${nam}h	c $chr `expr $basenum + 7`
	#mknod r${nam}i	c $chr `expr $basenum + 8`
	#mknod r${nam}j	c $chr `expr $basenum + 9`
	#mknod r${nam}k	c $chr `expr $basenum + 10`
	#mknod r${nam}l	c $chr `expr $basenum + 11`
	#mknod r${nam}m	c $chr `expr $basenum + 12`
	#mknod r${nam}n	c $chr `expr $basenum + 13`
	#mknod r${nam}o	c $chr `expr $basenum + 14`
	#mknod r${nam}p	c $chr `expr $basenum + 15`
	chown root.operator ${nam}[a-p] r${nam}[a-p]
	chmod 640 ${nam}[a-p] r${nam}[a-p]
	umask 77
	;;

ccd*|sd*|xd*|xy*|cd*|vnd*)
	umask 2
	case $i in
	ccd*) name=ccd; blk=9; chr=23;;
	sd*) name=sd; blk=7; chr=17;;
	xd*) name=xd; blk=10; chr=42;;
	xy*) name=xy; blk=3; chr=9;;
	cd*)  name=cd; blk=18; chr=58;;
	vnd*) name=vnd; blk=8; chr=110;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|\
	17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
		rm -f ${name}${unit}[a-p] r${name}${unit}[a-p]
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + 2`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + 2`
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + 1`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + 1`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + 15`
		chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

st*)
	umask 2
	case $i in
	st*) name=st; blk=11; chr=18;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit 
	mknod ${name}${unit}	b $blk `expr $unit '*' 16 + 0`
	mknod n${name}${unit}	b $blk `expr $unit '*' 16 + 1`
	mknod e${name}${unit}	b $blk `expr $unit '*' 16 + 2`
	mknod en${name}${unit}	b $blk `expr $unit '*' 16 + 3`
	mknod r${name}${unit}	c $chr `expr $unit '*' 16 + 0`
	mknod nr${name}${unit}	c $chr `expr $unit '*' 16 + 1`
	mknod er${name}${unit}	c $chr `expr $unit '*' 16 + 2`
	mknod enr${name}${unit}	c $chr `expr $unit '*' 16 + 3`
	chown root.operator ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit} 
	chmod 640 ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit} 
	umask 77
	;;

ch*)
	umask 2
	case $i in
	ch*) name=ch;  chr=19;;
	esac
	rm -f $name$unit
	mknod ${name}${unit}	c $chr `expr $unit '*' 16 + 0`
	chown root.operator ${name}${unit}
	chmod 640 ${name}${unit}
	umask 77
	;;

lkm)
	rm -f lkm
	mknod lkm c 112 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

pty*)
	case $unit in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $unit in
	0|1|2|3|4)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 16; i++)
				printf("mknod tty%s%x c 20 %d;" \
					"mknod pty%s%x c 21 %d; ", \
					n, i, b+i, n, i, b+i); }'`
		umask 77
		if [ $unit = 1 ]; then
			mv ttyqf ttyv0; mv ptyqf ptyv0
		fi
		;;
	esac
	;;

random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 119 0
	mknod srandom c 119 1
	mknod urandom c 119 2
	mknod prandom c 119 3
	mknod arandom c 119 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
	;;

uk*)
	unit=`expr $i : 'uk\(.*\)'`
	rm -f uk$unit
	mknod uk$unit c 98 $unit
	chown root.operator uk$unit
	chmod 640 uk$unit
	;;

ss*)
	unit=`expr $i : 'ss\(.*\)'`
	rm -f ss$unit
	mknod ss$unit c 99 $unit
	chown root.operator ss$unit
	chmod 440 ss$unit
#	backwards compatibility with older PINTs
	rm -f scan$unit
	ln -s ss$unit scan$unit
	;;

local)
	umask 0
	sh MAKEDEV.local
	;;
*)
	echo $i: unknown device
	;;
esac
done
