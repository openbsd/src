#!/bin/sh -
#
#	$OpenBSD: MAKEDEV,v 1.50 2003/01/06 05:57:40 deraadt Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
#
#	@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
#
# Device "make" file.  Valid arguments:
#	std	standard devices
#	local	configuration specific devices
#	all	create a reasonable amount of all files
# Tapes:
#	ht*	massbus tm03 & tu??
#	tm*	unibus tm11 & te10 emulations (e.g. Emulex tc-11)
#	mt*	MSCP tapes (e.g. TU81, TK50)
#	ts*	unibus ts11
#	ut*	unibus tu45 emulations (e.g.si 9700)
#	uu*	tu58 cassettes on dl11 controller
#	st*	SCSI tapes
# Disks:
#	hp*	massbus rm??
#	hk*	unibus rk06 and rk07
#	up*	other unibus devices (e.g. on Emulex sc-21v controller)
#	ra*	MSCP disks (ra??, hd??)
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
#	vnd*	"file" pseudo-disks
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	unibus dz11 and dz32
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
#	dl*	unibus dl11
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
# Printers:
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
# Call units:
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
# Special purpose devices:
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	systrace* system call tracing device
#
PATH=/sbin:/usr/sbin:/bin:/usr/bin
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in

all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	sh $0 ttyg0 ttyg1 ttyg2 ttyg3
	sh $0 crl std-extra systrace
	;;

floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;

ramdisk)
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 ra0 ra1 ra2 rx0 cd0 st0
	sh $0 bpf0 ttyg0
	;;

std)
	rm -f console drum
	rm -f kUmem kmem mem null zero tty klog
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

std-extra)
	rm -f floppy csa1 csa2 tu0 tu1
	mknod floppy		c 8 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	;;

crl)
	rm -f crl
	mknod crl		c 35 0
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
	;;

ht*|tm*|mt*|ts*|ut*)
	case $i in
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
	esac
	case $unit in
	[0-7])
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ]
		then
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
		then
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
		fi
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
	;;

st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
	;;

mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`;
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
	;;

random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
	;;

vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=128;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
	done
	umask 77
	;;

hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
	esac
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
	;;

ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
	;;

ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
	;;

xfs*)
	unit=${i#xfs}
	rm -f xfs$unit
	mknod xfs$unit c 74 $unit 
	chmod 600 xfs$unit 
	chown root.wheel xfs$unit
	;;

rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0))
	mknod rd${unit}c  b $blk $(($unit * 16 + 2))
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0))
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2))
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
	;;

ttyg*)
	unit=${i#ttyg};
	case $unit in
	[0-3])
		rm -f ttyg${unit}
		mknod ttyg$unit	c 25 $unit
		;;
	*)
		echo bad unit for ttyg: $i
		;;
	esac
	;;

dz*)
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
	*)
		echo bad unit for dz in: $i
		;;
	esac
	;;

dhu*|dh*|dmf*|dmz*|vt*)
	case $i in
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	esac
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
		else
			echo bad count for ${name}: $unit, $count, $i
		fi
		i=$(($i + 1))
	done

	;;

dl*)
	unit=${i#dl}
	major=66
	let=${cnvtbl[$unit]}
	if [ -n "$let" ] ;then
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
	else
		echo bad number for ${name}: $unit
	fi
	;;

lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
	;;

pty*)
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
	esac
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
	done
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
	;;

np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
	;;

dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
	;;

bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
	;;

tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
	;;

lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root._lkm lkm
	chmod 640 lkm
	;;

qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
	;;

systrace)
	rm -f systrace
	mknod systrace c 49 0
	chown root.wheel systrace
	chmod 644 systrace
	;;

local)
	umask 0
	sh $0.local all
	umask 77
	;;
*)
	echo $i: invalid device
	;;

esac
done
