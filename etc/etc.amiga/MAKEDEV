#!/bin/sh -
#
#	$OpenBSD: MAKEDEV,v 1.36 1998/09/15 10:23:21 pattonme Exp $
#	$NetBSD: MAKEDEV,v 1.21 1996/05/19 21:03:49 veego Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	from:
#	hp300/MAKEDEV (1/15/94), from:
#	@(#)MAKEDEV	5.5 (Berkeley) 5/28/91
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, including local devices,
#		Tries to make the ``standard'' number of each.
#	fd	makes fd/* for the fdescfs.
#	floppy	devices needed for install floppies
#	std	standard devices
#	local	configuration specific devices
#
# Tapes:
#	st*	SCSI tapes
#
# Disks:
#	fd*	Floppy disks
#	sd*	SCSI disks, includes flopticals
#	cd*	SCSI cdrom discs
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk driver
#	wd*	ISA "winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#	acd*	ISA ATAPI CD-ROM
#
# Console ports:
#	ttye*	ite bitmapped consoles
#
# Pointing devices:
#	mouse*	Amiga mice
#
# Terminal ports:
#	tty00	standard serial port.
#	ttyA*	mfc serial ports
#	ttyB*	ISA COM ports
#
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
#
# Printers:
#	par*	motherboard parallel port
#	lpt*	ISA lp
#	lpa*	interruptless ISA lp
#
# Special purpose devices:
#	grf*	custom chip (grf0), Retina Z2/Z3 (grf1/grf2),
#		Cirrus boards (grf3), A2410 (grf4) video or
#		CyberVision 64 (grf5)
#	kbd	Amiga keyboard
#	view*	generic interface to graphic displays.
#	aconf	autoconfig information (not yet)
#	lkm	loadable kernel modules interface.
#	bpf*	Berkeley Packet Filter
#	tun*	network tunnel driver
#	ipf	IP filter
#	ss*	SCSI scanners
#	uk*	unknown SCSI
#	*random	random data source
#       audio*  one unit of the audio device. Unit 0 is custom chip audio.

PATH=/sbin:/bin:/usr/sbin:/usr/bin
umask 77

hex ()
{
	case $1 in
		[0-9]) echo -n $1 ;;
		10) echo -n a;;
		11) echo -n b;;
		12) echo -n c;;
		13) echo -n d;;
		14) echo -n e;;
		15) echo -n f;;
	esac
}

for i
do
case $i in
all)
	sh MAKEDEV std fd st0 st1 ttye0 ttye1 ttye2 ttye3 ttye4 ttye5 ttye6
	sh MAKEDEV mouse0 mouse1 tty00 ttyA0 ttyA1
	sh MAKEDEV ttyB0 ttyB1 ttyB2 ttyB3 ttyB4 ttyB5 ttyB6 ttyB7 ttyB8 ttyB9
	sh MAKEDEV grf0 grf1 grf2 grf3 grf4 grf5 grf6
	sh MAKEDEV kbd sd0 sd1 sd2 sd3 sd4 sd5 sd6 sd7 sd8 sd9
	sh MAKEDEV vnd0 vnd1 vnd2 vnd3 vnd4 vnd5 vnd6 cd0 cd1 fd0 fd1 fd2 fd3
	sh MAKEDEV bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9
	sh MAKEDEV view00 view01 view02 view03 view04 view05 pty0 pty1
	sh MAKEDEV lpa0 lpa1 lpt0 lpt1 lpt2 ipl
	sh MAKEDEV ccd0 ccd1 ccd2 ccd3 wd0 wd1 acd0 ch0 uk0 uk1
	sh MAKEDEV tun0 tun1 par0 lkm ss0 random audio0 local
	;;

floppy|ramdisk)
	sh MAKEDEV std kbd pty0 tty00 ttyA0 ttyA1 ttyB0 ttyB1
	sh MAKEDEV ttye0 ttye1 ttye2 ttye3 ttye4 ttye5 ttye6
	sh MAKEDEV cd0 cd1 sd0 sd1 sd2 sd3 st0 st1
	sh MAKEDEV fd0 fd1 wd0 wd1 acd0 rd0 random
	;;

std)
	rm -f console drum kmem mem reload null zero tty
	rm -f klog stdin stdout stderr ipf ksyms
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chown root.kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chown root.kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chown root.kmem mem
	mknod reload		c 2 20	; chmod 600 reload
	mknod zero		c 2 12	; chmod 666 zero
	mknod null		c 2 2	; chmod 666 null
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	mknod stdin		c 21 0	; chmod 666 stdin
	mknod stdout		c 21 1	; chmod 666 stdout
	mknod stderr		c 21 2	; chmod 666 stderr
	mknod ipf		c 34 0	; chmod 444 ipf
	mknod ksyms		c 42 0  ; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	(cd fd && i=0 && while [ $i -lt 64 ]; do
		mknod $i c 21 $i
		i=$(($i+1))
		done)
	chown -R root.wheel fd
	chmod 555 fd
	chmod 666 fd/*
	;;

st*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	st*) name=st; blk=5; chr=20;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit 
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}	b $blk `expr $unit '*' 16 + 0`
		mknod n${name}${unit}	b $blk `expr $unit '*' 16 + 1`
		mknod e${name}${unit}	b $blk `expr $unit '*' 16 + 2`
		mknod en${name}${unit}	b $blk `expr $unit '*' 16 + 3`
		mknod r${name}${unit}	c $chr `expr $unit '*' 16 + 0`
		mknod nr${name}${unit}	c $chr `expr $unit '*' 16 + 1`
		mknod er${name}${unit}	c $chr `expr $unit '*' 16 + 2`
		mknod enr${name}${unit}	c $chr `expr $unit '*' 16 + 3`
		chown root.operator ${name}${unit} n${name}${unit} \
			e$name$unit en$name$unit \
			r${name}${unit} nr${name}${unit} \
			er${name}${unit} enr${name}${unit} 
		chmod 640 ${name}${unit} n${name}${unit} \
			e$name$unit en$name$unit \
			r${name}${unit} nr${name}${unit} \
			er${name}${unit} enr${name}${unit} 
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;

fd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	rm -f fd$unit? rfd$unit?
	case $unit in
	0|1|2|3)
		mknod fd${unit}a b 2 `expr $unit '*' 16`
		mknod fd${unit}b b 2 `expr $unit '*' 16 + 1`
		mknod rfd${unit}a c 18 `expr $unit '*' 16`
		mknod rfd${unit}b c 18 `expr $unit '*' 16 + 1`
		chown root.operator fd$unit? rfd$unit?
		chmod 640 fd$unit? rfd$unit?
		;;
	*)
		echo bad unit for floppy disk in: $i
		;;
	esac
	umask 77
	;;

sd*|ccd*|wd*|rd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	sd*) name=sd; blk=4; chr=8;;
	rd*) name=rd; blk=16; chr=41;;
	ccd*) name=ccd; blk=8; chr=7;;
	wd*) name=wd; blk=0; chr=37;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15)
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + 2`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + 2`
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + 1`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + 1`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + 15`
		chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

vnd*)
	umask 2 ; unit=`expr $i : 'vnd\(.*\)'`
	for name in vnd svnd; do
		blk=6; chr=19;
		case $name in
		vnd)	off=0;;
		svnd)	off=128;;
		esac
		rm -f $name$unit? r$name$unit?
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + $off + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + $off + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + $off + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + $off + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + $off + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + $off + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + $off + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + $off + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + $off + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + $off + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + $off + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + $off + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + $off + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + $off + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + $off + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + $off + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + $off + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + $off + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + $off + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + $off + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + $off + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + $off + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + $off + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + $off + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + $off + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + $off + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + $off + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + $off + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + $off + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + $off + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + $off + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + $off + 15`
		chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
	done
	umask 77
	;;

ch*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	ch*) name=ch;  chr=40;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $unit
	chown root.operator $name$unit
	chmod 640 $name$unit
	umask 77
	;;

cd*|acd*)
	umask 2 ; unit=`expr $i : '.*cd\(.*\)'`
	case $i in
	cd*) name=cd; blk=7; chr=9;;
	acd*) name=acd; blk=15; chr=38;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a   b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}c   b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}a  c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}c  c $chr `expr $unit '*' 8 + 2`
		chown root.operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

tty0*|ttyA*)
	type=`expr $i : 'tty\(.\).'`
	unit=`expr $i : 'tty.\(.\)'`
	rm -f ser${unit}
	case $type in
	0)	case $unit in
		0)	
			rm -f tty0${unit} cua0${unit}
			mknod tty0${unit} c 12 0
			mknod cua0${unit} c 12 128
			chown uucp.wheel tty0${unit} cua0${unit}
			;;
		*)
			echo bad unit for tty0 in: $i
			;;
		esac
		;;
	A)	case $unit in
		0|1)
			rm -f ttyA${unit} ttyM${unit}
			mknod ttyA${unit} c 17 $unit
			mknod ttyM${unit} c 17 `expr 128 + $unit`
			chown uucp.wheel ttyA${unit} ttyM${unit}
			;;
		*)
			echo bad unit for ttyA in: $i
			;;
		esac
		;;
	*)
		echo bad type for tty in: $i
		;;
	esac
	;;

par*)
	unit=`expr $i : 'par\(.*\)'`
	rm -f par${unit}
	case $unit in
	0)
		mknod par${unit} c 11 ${unit}
		;;
	*)
		echo bad unit for par in: $i
		;;
	esac
	;;


ttye*)
	unit=`expr $i : 'ttye\(.*\)'`
	rm -f ttye${unit}
	rm -f ite*
	case $unit in
	0|1|2|3|4|5|6)
		mknod ttye${unit} c 13 ${unit}
		;;
	*)
		echo bad unit for ttye in: $i
		;;
	esac
	;;

grf*)
	unit=`expr $i : 'grf\(.*\)'`
	rm -f grf${unit}
	case $unit in
	0|1|2|3|4|5|6)
		mknod grf${unit} c 10 ${unit}; chmod 666 grf${unit}
		;;
	*)
		echo bad unit for grf in: $i
		;;
	esac
# for those that need it, also make overlay and image devices:
	rm -f grfov${unit} grfim${unit}
	case $unit in
	4)
		unitov=`expr $unit + 16`
		unitim=`expr $unit + 32`
		mknod grfov${unit} c 10 ${unitov}; chmod 666 grf${unit}
		mknod grfim${unit} c 10 ${unitim}; chmod 666 grf${unit}
		;;
	esac
	;;

mouse*)
	unit=`expr $i : 'mouse\(.*\)'`
	rm -f mouse${unit}
	case $unit in
	0|1)
		mknod mouse${unit} c 15 ${unit}; chmod 666 mouse${unit}
		if [ $unit = 0 ]
		then 
			rm -f mouse; ln -s mouse${unit} mouse
		fi
		;;
	*)
		echo bad unit for mouse in: $i
		;;
	esac
	;;

kbd)
	rm -f kbd
	mknod kbd c 14 0
	;;


view*)
	unit=`expr $i : 'view\(.*\)'`
	rm -f view${unit}
	case $unit in
	00|01|02|03|04|05|06|07|08|09)
		mknod view${unit} c 16 ${unit}; chmod 666 view${unit}
		;;
	*)
		echo bad unit for view in: $i
		;;
	esac
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4)
		umask 0
		n=0
		while [ $n -lt 16 ]
                do
                        nam=$name`hex $n`
                        rm -f {tty,pty}$nam
                        mknod tty$nam c 4 "$(( $offset + $n ))"
                        mknod pty$nam c 5 "$(( $offset + $n ))"
                        n="$(( $n + 1 ))"
                done
		umask 77
		;;
	esac
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf$unit
	mknod bpf$unit c 22 $unit
	chown root.wheel bpf$unit
	;;

ttyB*)
	unit=`expr $i : '....\(.*\)'`
	rm -f ttyB$unit cuaB$unit
	mknod ttyB$unit c 32 $unit
	mknod cuaB$unit c 32 `expr $unit + 128`
	chown uucp.wheel ttyB$unit cuaB$unit
	;;

lpt*|lpa*)
	unit=`expr $i : '...\(.*\)'`
	case $i in
	lpt*) name=lpt; flags=0;;
	lpa*) name=lpa; flags=128;;
	esac
	rm -f $name$unit
	mknod $name$unit c 33 `expr $unit + $flags`
	chown root.wheel $name$unit
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 34 0
	mknod ipnat c 34 1
	mknod ipstate c 34 2
	mknod ipauth c 34 3
	chown root.wheel ipl ipnat ipstate ipauth
	;;

tun*)
	unit=`expr $i : 'tun\(.*\)'`
	rm -f tun$unit
	mknod tun$unit c 23 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
	;;

lkm)
        rm -f lkm
        mknod lkm c 24 0
        chown root.kmem lkm
        chmod 640 lkm
        ;;

ss*)
	unit=`expr $i : 'ss\(.*\)'`
	rm -f ss$unit
	mknod ss$unit c 25 $unit
	chown root.operator ss$unit
	chmod 440 ss$unit
#	backwards compatibility with older PINTs
	rm -f scan$unit
	ln -s ss$unit scan$unit
	;;


random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 35 0
	mknod srandom c 35 1
	mknod urandom c 35 2
	mknod prandom c 35 3
	mknod arandom c 35 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
	;;

uk*)
	unit=`expr $i : 'uk\(.*\)'`
	rm -f uk$unit
	mknod uk$unit c 36 $unit
	chown root.operator uk$unit
	chmod 640 uk$unit
	;;

audio*)
        unit=${i#audio}                                               
        audio=audio$unit                                                
        sound=sound$unit                             
        mixer=mixer$unit                                         
        major=39                                
        audioctl=audioctl$unit                                       
        if [ "$unit" = "" ]; then unit=0; fi
        rm -f $audio $sound $mixer $audioctl                             
        mknod $sound    c $major $(($unit + 0))
        mknod $audio    c $major $(($unit + 128))
        mknod $mixer    c $major $(($unit + 16))
        mknod $audioctl c $major $(($unit + 192))
        chown root.wheel $audio $sound $mixer $audioctl
        chmod 666 $audio $sound $mixer $audioctl
        ;;

local)
	umask 0
	test -s MAKEDEV.local && sh MAKEDEV.local
	umask 77
	;;

*)
	echo $i: unknown device
	;;
esac
done
