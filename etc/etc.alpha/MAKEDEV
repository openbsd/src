#!/bin/sh -
#	$OpenBSD: MAKEDEV,v 1.37 1998/09/21 23:15:52 deraadt Exp $
#	$NetBSD: MAKEDEV,v 1.8.4.1 1996/06/18 00:41:56 cgd Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, including local devices.
#		Tries to make the 'standard' number of each type.
#	std	standard devices
#	local	configuration specific devices
#
# Tapes:
#	st*	SCSI tape
#
# Disks:
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk driver
#	wd*	IDE disks
#	acd*	ATAPI CD-ROM
#
# Terminals:
#	ttyB?	DEC 3000 ZS8530 ("scc") serial ports
#	ttyC?	AlphaStation NS16550 ("com") serial ports
#	ttyE?	Workstation console (framebuffer & keyboard) tty emulators
#
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
#
# Printers:
#	lpt*	stock lp
#	lpa*	interruptless lp
#
# Special purpose devices:
#	ch*	SCSI media changer
#	bpf*	packet filter
#	fd	file descriptors
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	mmclock	memory mapped clock
#	kbd	keyboard (provides events, for X11)
#	mouse	mouse (provides events, for X11)
#	*random	inkernel random number generator
#	uk*	unknown SCSI
#	ss*	SCSI scanners
#	ipl	IP filter log

PATH=/sbin:/usr/sbin:/bin:/usr/bin
umask 77

hex ()
{
	case $1 in
		[0-9]) echo -n $1 ;;
		10) echo -n a;;
		11) echo -n b;;
		12) echo -n c;;
		13) echo -n d;;
		14) echo -n e;;
		15) echo -n f;;
	esac
}

for i
do
case $i in

all)
	sh MAKEDEV std fd sd0 sd1 sd2 sd3 sd4 pty0 pty1
	sh MAKEDEV st0 st1 ch0 cd0 cd1 vnd0 vnd1 vnd2 vnd3
	sh MAKEDEV ccd0 ccd1 ccd2 ccd3 wd0 wd1 wd2 wd3 acd0 acd1
	sh MAKEDEV bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9
	sh MAKEDEV tun0 tun1 tun2 tun3
	sh MAKEDEV ttyB0 ttyB1 ttyC0 ttyC1 ttyE0 ttyE1 lkm
	sh MAKEDEV mmclock kbd mouse lpa0 lpt0 random ipl
	sh MAKEDEV uk0 uk1 ss0 ss1
	sh MAKEDEV ttyc0 ttyc1 ttyc2 ttyc3 ttyc4 ttyc5 ttyc6 ttyc7
	sh MAKEDEV local
	;;

raminst)
	sh MAKEDEV std
	sh MAKEDEV sd0 sd1 sd2 wd0 wd1 st0
	sh MAKEDEV cd0 acd0
	sh MAKEDEV rd0 bpf0
	sh MAKEDEV ttyB0 ttyB1 ttyC0 ttyC1 ttyE0 ttyE1 pty0
	;;

std)
	rm -f console drum mem kmem null zero io tty klog stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chown root.kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chown root.kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chown root.kmem mem
	mknod null		c 2 2	; chmod 666 null
	mknod zero		c 2 12	; chmod 666 zero
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	mknod stdin		c 10 0	; chmod 666 stdin
	mknod stdout		c 10 1	; chmod 666 stdout
	mknod stderr		c 10 2	; chmod 666 stderr
	mknod ksyms		c 39 0  ; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	(cd fd && while [ $n -lt 64 ]; do mknod $n c 10 $n; n="$(( $n + 1 ))"; done)
	chown -R root.wheel fd
	chmod 555 fd
	chmod 666 fd/*
	;;

sd*|wd*|ccd*|rd*)
	umask 2 ; unit=`expr $i : '.*d\(.*\)'`
	case $i in
	rd*)	name=rd;	blk=6; chr=28;;
	sd*)	name=sd;	blk=8; chr=8;;
	ccd*)	name=ccd;	blk=7; chr=27;;
	wd*)	name=wd;	blk=0; chr=36;;
	esac
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + 0`
	mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + 1`
	mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + 2`
	mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + 3`
	mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + 4`
	mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + 5`
	mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + 6`
	mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + 7`
	mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + 8`
	mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + 9`
	mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + 10`
	mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + 11`
	mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + 12`
	mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + 13`
	mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + 14`
	mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + 15`
	mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + 0`
	mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + 1`
	mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + 2`
	mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + 3`
	mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + 4`
	mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + 5`
	mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + 6`
	mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + 7`
	mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + 8`
	mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + 9`
	mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + 10`
	mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + 11`
	mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + 12`
	mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + 13`
	mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + 14`
	mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + 15`
	chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
	chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
	umask 77
	;;

vnd*)
	umask 2 ; unit=`expr $i : 'vnd\(.*\)'`
	for name in vnd svnd; do
		blk=9; chr=9;
		case $name in
		vnd)	off=0;;
		svnd)	off=128;;
		esac
		rm -f $name$unit? r$name$unit?
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + $off + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + $off + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + $off + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + $off + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + $off + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + $off + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + $off + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + $off + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + $off + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + $off + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + $off + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + $off + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + $off + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + $off + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + $off + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + $off + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + $off + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + $off + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + $off + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + $off + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + $off + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + $off + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + $off + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + $off + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + $off + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + $off + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + $off + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + $off + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + $off + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + $off + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + $off + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + $off + 15`
		chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
	done
	umask 77
	;;

cd*|acd*)
	umask 2 ; unit=`expr $i : '.*cd\(.*\)'`
	case $i in
	cd*)	name=cd;	blk=3; chr=13;;
	acd*)	name=acd;	blk=4; chr=37;;
	esac
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + 0`
	mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + 2`
	mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + 0`
	mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + 2`
	chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
	chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
	umask 77
	;;

ttyE*)
        type=`expr $i : 'tty\(.\).'`
        unit=`expr $i : 'tty.\(.\)'`
	case $type in
	E)	major=25; minor=$unit ;;
	esac
        rm -f tty$type$unit
        mknod tty$type$unit c $major $minor
        chown root.wheel tty$type$unit
        ;;

ttyB*|ttyC*|ttyc*)
        type=`expr $i : 'tty\(.\).'`
        unit=`expr $i : 'tty.\(.\)'`
	case $type in
	B)	major=15; minor=`expr $unit \* 2` ;;
	C)	major=26; minor=$unit ;;
	c)	major=38; minor=$unit ;;
	esac
        rm -f tty$type$unit cua$type$unit
        mknod tty$type$unit c $major $minor
        mknod cua$type$unit c $major `expr $minor + 128`
        chown uucp.wheel tty$type$unit cua$type$unit
        ;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4)
		umask 0
		n=0
		while [ $n -lt 16 ]
		do
			nam=$name`hex $n`
			rm -f tty$nam pty$nam
			mknod tty$nam c 4 "$(( $offset + $n ))"
			mknod pty$nam c 5 "$(( $offset + $n ))"
			n="$(( $n + 1 ))"
		done
		umask 77
		;;
	esac
	;;

st*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	st*) name=st;	blk=2; chr=12;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
	r$name$unit nr$name$unit er$name$unit enr$name$unit
	mknod ${name}${unit}	b $blk `expr $unit '*' 16 + 0`
	mknod n${name}${unit}	b $blk `expr $unit '*' 16 + 1`
	mknod e${name}${unit}	b $blk `expr $unit '*' 16 + 2`
	mknod en${name}${unit}	b $blk `expr $unit '*' 16 + 3`
	mknod r${name}${unit}	c $chr `expr $unit '*' 16 + 0`
	mknod nr${name}${unit}	c $chr `expr $unit '*' 16 + 1`
	mknod er${name}${unit}	c $chr `expr $unit '*' 16 + 2`
	mknod enr${name}${unit} c $chr `expr $unit '*' 16 + 3`
	chown root.operator ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	chmod 640 ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	umask 77
	;;

ch*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	ch*) name=ch;	chr=14;;
	esac
	rm -f $name$unit
	mknod ${name}${unit}	c $chr $unit
	chown root.operator ${name}${unit}
	chmod 640 ${name}${unit}
	umask 77
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf$unit
	mknod bpf$unit c 11 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

tun*)
	unit=`expr $i : 'tun\(.*\)'`
	rm -f tun$unit
	mknod tun$unit c 7 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
	;;

lkm)
	rm -f lkm
	mknod lkm c 16 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

mmclock)
	rm -f mmclock
	mknod mmclock c 28 0
	chmod 444 mmclock
	;;

kbd)
	rm -f kbd
	mknod kbd c 29 0
	chmod 666 kbd
	;;

mouse)
	rm -f mouse
	mknod mouse c 30 0
	chmod 666 mouse
	;;

lpt*|lpa*)
	unit=`expr $i : '...\(.*\)'`
	case $i in
	lpt*) name=lpt; flags=0;;
	lpa*) name=lpa; flags=128;;
	esac
	rm -f $name$unit
	mknod $name$unit c 31 `expr $unit + $flags`
	chown root.wheel $name$unit
	;;

random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 34 0
	mknod srandom c 34 1
	mknod urandom c 34 2
	mknod prandom c 34 3
	mknod arandom c 34 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 35 0
	mknod ipnat c 35 1
	mknod ipstate c 35 2
	mknod ipauth c 35 3
	chown root.wheel ipl ipnat ipstate ipauth
	;;

uk*)
	unit=`expr $i : 'uk\(.*\)'`
	rm -f uk$unit
	mknod uk$unit c 33 $unit
	chown root.operator uk$unit
	chmod 640 uk$unit
	;;

ss*)
	unit=`expr $i : 'ss\(.*\)'`
	rm -f ss$unit
	mknod ss$unit c 32 $unit
	chown root.operator ss$unit
	chmod 440 ss$unit
#	backwards compatibility with older PINTs
	rm -f scan$unit
	ln -s ss$unit scan$unit
	;;

local)
	umask 0
	test -s MAKEDEV.local && sh MAKEDEV.local
	;;

*)
	echo $i: unknown device
	;;

esac
done
